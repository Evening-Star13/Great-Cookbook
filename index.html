<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recipe Manager Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      xintegrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.24.0/babel.min.js"></script>
    <style>
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #999;
      }
      .dark ::-webkit-scrollbar-track {
        background: #2d3748;
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #4a5568;
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #6a7788;
      }

      body.modal-open {
        overflow: hidden;
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translateY(10px);
        }
        15% {
          opacity: 1;
          transform: translateY(0);
        }
        85% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(10px);
        }
      }
      .animate-fade-in-out {
        animation: fadeInOut 3s ease-in-out forwards;
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.95);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .modal-scale-enter {
        animation: scaleIn 0.2s ease-out forwards;
      }

      .collapsible-content {
        transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        overflow: hidden;
        max-height: 0;
        opacity: 0;
      }
      .collapsible-content.expanded {
        max-height: 1000px;
        opacity: 1;
      }

      .btn-header {
        background-color: #f3f4f6;
        color: #374151;
        padding: 6px 10px;
        border-radius: 9999px;
        display: inline-flex;
        align-items: center;
        font-size: 0.875rem;
        transition: background-color 0.2s ease, color 0.2s ease;
        border: 1px solid transparent;
        white-space: nowrap;
      }
      .btn-header:hover {
        background-color: #e5e7eb;
      }
      .dark .btn-header {
        background-color: #374151;
        color: #d1d5db;
      }
      .dark .btn-header:hover {
        background-color: #4b5563;
      }
      .btn-header.bg-green-500 {
        border-color: transparent;
        color: white;
      }
      .dark .btn-header.bg-green-500 {
        color: white;
      }

      .filter-select {
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        background-color: #ffffff;
        color: #1f2937;
        font-size: 0.875rem;
        line-height: 1.25rem;
        appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%236b7280%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1em 1em;
        padding-right: 2rem;
      }
      .dark .filter-select {
        border-color: #4b5563;
        background-color: #374151;
        color: #f3f4f6;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%23d1d5db%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E");
      }
      .filter-select:focus {
        outline: none;
        border-color: #10b981;
        box-shadow: 0 0 0 1px #10b981;
      }

      .modal-input,
      .modal-textarea,
      .modal-input-sm {
        width: 100%;
        border-radius: 0.375rem;
        border: 1px solid #d1d5db;
        background-color: #f9fafb;
        color: #111827;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .modal-input,
      .modal-textarea {
        padding: 8px 12px;
      }
      .modal-input-sm {
        padding: 6px 10px;
        font-size: 0.875rem;
      }
      .dark .modal-input,
      .dark .modal-textarea,
      .dark .modal-input-sm {
        border-color: #4b5563;
        background-color: #374151;
        color: #f3f4f6;
      }
      .modal-input:focus,
      .modal-textarea:focus,
      .modal-input-sm:focus {
        outline: none;
        border-color: #10b981;
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3);
      }
      .modal-input.border-red-500,
      .modal-textarea.border-red-500,
      .modal-input-sm.border-red-500 {
        border-color: #ef4444;
      }
      .modal-input.border-red-500:focus,
      .modal-textarea.border-red-500:focus,
      .modal-input-sm.border-red-500:focus {
        box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
      }

      .btn-modal {
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.875rem;
        display: inline-flex;
        align-items: center;
        transition: all 0.2s ease;
        border: none;
        cursor: pointer;
      }
      .btn-modal:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-green {
        background-color: #10b981;
        color: white;
      }
      .btn-green:hover:not(:disabled) {
        background-color: #059669;
      }
      .btn-gray {
        background-color: #e5e7eb;
        color: #1f2937;
      }
      .btn-gray:hover:not(:disabled) {
        background-color: #d1d5db;
      }
      .dark .btn-gray {
        background-color: #4b5563;
        color: #e5e7eb;
      }
      .dark .btn-gray:hover:not(:disabled) {
        background-color: #6b7280;
      }
      .btn-blue {
        background-color: #3b82f6;
        color: white;
      }
      .btn-blue:hover:not(:disabled) {
        background-color: #2563eb;
      }
      .btn-red {
        background-color: #ef4444;
        color: white;
      }
      .btn-red:hover:not(:disabled) {
        background-color: #dc2626;
      }

      .adjust-btn {
        background-color: #d1d5db;
        color: #374151;
        width: 1.75rem;
        height: 1.75rem;
        border-radius: 9999px;
        font-size: 1rem;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .adjust-btn:hover:not(:disabled) {
        background-color: #9ca3af;
      }
      .adjust-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .dark .adjust-btn {
        background-color: #4b5563;
        color: #e5e7eb;
      }
      .dark .adjust-btn:hover:not(:disabled) {
        background-color: #6b7280;
      }

      .line-clamp-1 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
      }
      .line-clamp-2 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
      }
      .line-clamp-3 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
      }

      .tc {
        text-align: center;
      }
      .op-70 {
        opacity: 0.7;
      }
      .op-80 {
        opacity: 0.8;
      }
      .op-50 {
        opacity: 0.5;
      }
      .mr-0\.5 {
        margin-right: 0.125rem;
      }

      .tag-input-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        padding: 4px;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        background-color: #f9fafb;
        min-height: 38px;
      }
      .dark .tag-input-container {
        border-color: #4b5563;
        background-color: #374151;
      }
      .tag-item {
        background-color: #10b981;
        color: white;
        padding: 2px 8px;
        border-radius: 9999px;
        font-size: 0.875rem;
        margin: 2px;
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
      }
      .tag-item-remove {
        background: none;
        border: none;
        color: white;
        margin-left: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .tag-item-remove:hover {
        opacity: 1;
      }
      .tag-input {
        flex-grow: 1;
        border: none;
        outline: none;
        padding: 6px 8px;
        background-color: transparent;
        color: #111827;
        min-width: 100px;
      }
      .dark .tag-input {
        color: #f3f4f6;
      }
      .tag-input-container:focus-within {
        border-color: #10b981;
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3);
      }
      .tag-input-container.border-red-500 {
        border-color: #ef4444;
      }
    </style>
  </head>
  <body
    class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300 font-sans"
  >
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useMemo, useCallback } = React;

      const DB_NAME = "RecipeManagerDB";
      const DB_VERSION = 1;
      const STORE_NAMES = {
        RECIPES: "recipes",
        MEAL_PLAN: "mealPlan",
        SHOPPING_LIST: "shoppingList",
      };
      const LOCAL_STORAGE_KEYS = {
        RECIPES: "recipes",
        MEAL_PLAN: "mealPlan",
        SHOPPING_LIST: "shoppingList",
        THEME: "theme",
      };

      let db = null;

      const openDatabase = () => {
        return new Promise((resolve, reject) => {
          if (db) {
            resolve(db);
            return;
          }

          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            for (const storeName of Object.values(STORE_NAMES)) {
              if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName, { keyPath: "id" });
              }
            }
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };

          request.onerror = (event) => {
            console.error("IndexedDB error:", event.target.error);
            reject(event.target.error);
          };
        });
      };

      const getStore = async (storeName, mode) => {
        const database = await openDatabase();
        const transaction = database.transaction(storeName, mode);
        return transaction.objectStore(storeName);
      };

      const getAllItems = async (storeName) => {
        try {
          const store = await getStore(storeName, "readonly");
          const request = store.getAll();
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error getting all items from ${storeName}:`, error);
          return [];
        }
      };

      const addItem = async (storeName, item) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.add(item);
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(item);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error adding item to ${storeName}:`, error);
          throw error;
        }
      };

      const updateItem = async (storeName, id, updatedItem) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.put(updatedItem);
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(updatedItem);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error updating item in ${storeName}:`, error);
          throw error;
        }
      };

      const deleteItem = async (storeName, id) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.delete(id);
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error deleting item from ${storeName}:`, error);
          throw error;
        }
      };

      const clearStore = async (storeName) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.clear();
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error clearing store ${storeName}:`, error);
          throw error;
        }
      };

      const formatMinutesToHoursMinutes = (totalMinutes) => {
        if (isNaN(totalMinutes) || totalMinutes < 0) return "";
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        let parts = [];
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0 || totalMinutes === 0) parts.push(`${minutes}m`);
        return parts.join(" ");
      };

      const escapeHTML = (str) => {
        if (!str) return "";
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      };

      const parseIngredient = (ingredient) => {
        if (typeof ingredient !== "string")
          return { quantity: null, unit: null, description: "" };

        const regex =
          /^\s*(\d*\s*\d*\/\d+|\d+\.?\d*|\d*[\u00BC-\u00BE\u2150-\u215E])?\s*([a-zA-Z.]+)?\s*(.*)$/;
        const match = ingredient.match(regex);

        if (match) {
          let quantity = null;
          let unit = match[2]?.trim() || null;
          let description = match[3]?.trim() || "";
          const quantityString = match[1]?.trim();

          const unicodeFractions = {
            "½": 0.5,
            "¼": 0.25,
            "¾": 0.75,
            "⅓": 1 / 3,
            "⅔": 2 / 3,
            "⅕": 0.2,
            "⅖": 0.4,
            "⅗": 0.6,
            "⅘": 0.8,
            "⅙": 1 / 6,
            "⅚": 5 / 6,
            "⅛": 0.125,
            "⅜": 0.375,
            "⅝": 0.625,
            "⅞": 0.875,
          };

          if (quantityString) {
            try {
              let totalQuantity = 0;
              const parts = quantityString.split(/\s+/);
              if (parts.length === 2 && parts[1].includes("/")) {
                totalQuantity = parseFloat(parts[0]) + eval(parts[1]);
              } else if (parts.length === 1 && parts[0].includes("/")) {
                totalQuantity = eval(parts[0]);
              } else if (unicodeFractions[quantityString]) {
                totalQuantity = unicodeFractions[quantityString];
              } else {
                totalQuantity = parseFloat(quantityString);
              }

              if (!isNaN(totalQuantity)) {
                quantity = totalQuantity;
              } else {
                description = `${quantityString} ${
                  unit || ""
                } ${description}`.trim();
                unit = null;
              }
            } catch (e) {
              console.warn("Could not parse quantity:", quantityString, e);
              description = `${quantityString} ${
                unit || ""
              } ${description}`.trim();
              unit = null;
            }
          }

          const commonNonUnits = new Set([
            "large",
            "medium",
            "small",
            "fresh",
            "dried",
            "chopped",
            "diced",
            "minced",
            "sliced",
            "crushed",
            "finely",
            "roughly",
            "peeled",
            "seeded",
            "cored",
            "rinsed",
            "optional",
            "divided",
            "softened",
            "melted",
            "beaten",
            "cooked",
            "uncooked",
            "raw",
            "canned",
            "frozen",
            "thawed",
            "packed",
            "heaping",
            "scant",
            "about",
            "approximately",
            "plus",
            "more",
            "as",
            "needed",
            "to",
            "taste",
          ]);
          if (unit && commonNonUnits.has(unit.toLowerCase())) {
            description = `${unit} ${description}`.trim();
            unit = null;
          }

          if (quantity === null) {
            description = ingredient;
            unit = null;
          }

          return { quantity, unit, description };
        }
        return { quantity: null, unit: null, description: ingredient };
      };

      const formatQuantity = (quantity) => {
        if (quantity === null || quantity === undefined || isNaN(quantity))
          return "";
        if (quantity === 0) return "";

        if (quantity % 1 === 0) return quantity.toString();

        const tolerance = 0.001;
        const fractions = [
          { decimal: 1 / 8, fraction: "⅛" },
          { decimal: 1 / 4, fraction: "¼" },
          { decimal: 1 / 3, fraction: "⅓" },
          { decimal: 3 / 8, fraction: "⅜" },
          { decimal: 1 / 2, fraction: "½" },
          { decimal: 5 / 8, fraction: "⅝" },
          { decimal: 2 / 3, fraction: "⅔" },
          { decimal: 3 / 4, fraction: "¾" },
          { decimal: 7 / 8, fraction: "⅞" },
          { decimal: 1 / 5, fraction: "⅕" },
          { decimal: 2 / 5, fraction: "⅖" },
          { decimal: 3 / 5, fraction: "⅗" },
          { decimal: 4 / 5, fraction: "⅘" },
          { decimal: 1 / 6, fraction: "⅙" },
          { decimal: 5 / 6, fraction: "⅚" },
        ].sort((a, b) => a.decimal - b.decimal);

        const whole = Math.floor(quantity);
        const decimalPart = quantity - whole;

        for (let f of fractions) {
          if (Math.abs(decimalPart - f.decimal) < tolerance) {
            return whole > 0 ? `${whole} ${f.fraction}` : f.fraction;
          }
        }

        return parseFloat(quantity.toFixed(2)).toString();
      };

      const convertUnits = (quantity, unit, targetUnitSystem) => {
        if (
          quantity === null ||
          quantity === undefined ||
          isNaN(quantity) ||
          !unit
        ) {
          return { value: quantity, unit: unit };
        }

        const lowerCaseUnit = unit.toLowerCase();
        let convertedValue = quantity;
        let convertedUnit = unit;

        if (targetUnitSystem === "imperial") {
          if (
            lowerCaseUnit === "g" ||
            lowerCaseUnit === "gram" ||
            lowerCaseUnit === "grams"
          ) {
            convertedValue = quantity * 0.035274;
            convertedUnit = "oz";
          } else if (
            lowerCaseUnit === "kg" ||
            lowerCaseUnit === "kilogram" ||
            lowerCaseUnit === "kilograms"
          ) {
            convertedValue = quantity * 35.274;
            convertedUnit = "oz";
          } else if (
            lowerCaseUnit === "ml" ||
            lowerCaseUnit === "milliliter" ||
            lowerCaseUnit === "milliliters"
          ) {
            convertedValue = quantity * 0.033814;
            convertedUnit = "fl oz";
          } else if (
            lowerCaseUnit === "l" ||
            lowerCaseUnit === "liter" ||
            lowerCaseUnit === "liters"
          ) {
            convertedValue = quantity * 33.814;
            convertedUnit = "fl oz";
          } else if (
            lowerCaseUnit === "tsp" ||
            lowerCaseUnit === "teaspoon" ||
            lowerCaseUnit === "teaspoons"
          ) {
            convertedValue = quantity / 3;
            convertedUnit = "tbsp";
          }
        } else if (targetUnitSystem === "metric") {
          if (
            lowerCaseUnit === "oz" ||
            lowerCaseUnit === "ounce" ||
            lowerCaseUnit === "ounces"
          ) {
            convertedValue = quantity * 28.3495;
            convertedUnit = "g";
          } else if (
            lowerCaseUnit === "lb" ||
            lowerCaseUnit === "pound" ||
            lowerCaseUnit === "pounds"
          ) {
            convertedValue = quantity * 453.592;
            convertedUnit = "g";
          } else if (
            lowerCaseUnit === "fl oz" ||
            lowerCaseUnit === "fluid ounce" ||
            lowerCaseUnit === "fluid ounces"
          ) {
            convertedValue = quantity * 29.5735;
            convertedUnit = "ml";
          } else if (lowerCaseUnit === "cup" || lowerCaseUnit === "cups") {
            convertedValue = quantity * 236.588;
            convertedUnit = "ml";
          } else if (
            lowerCaseUnit === "tbsp" ||
            lowerCaseUnit === "tablespoon" ||
            lowerCaseUnit === "tablespoons"
          ) {
            convertedValue = quantity * 14.7868;
            convertedUnit = "ml";
          }
        }
        if (
          targetUnitSystem === "imperial" &&
          (lowerCaseUnit === "tbsp" ||
            lowerCaseUnit === "tablespoon" ||
            lowerCaseUnit === "tablespoons")
        ) {
          convertedValue = quantity * 3;
          convertedUnit = "tsp";
        } else if (
          targetUnitSystem === "metric" &&
          (lowerCaseUnit === "tsp" ||
            lowerCaseUnit === "teaspoon" ||
            lowerCaseUnit === "teaspoons")
        ) {
          convertedValue = quantity * 4.92892;
          convertedUnit = "ml";
        }

        return {
          value: parseFloat(convertedValue.toFixed(2)),
          unit: convertedUnit,
        };
      };

      const parseYield = (yieldString) => {
        if (typeof yieldString !== "string" || yieldString.trim() === "")
          return { quantity: null, unit: "" };

        const match = yieldString.trim().match(/^([\d./\s½¼¾⅓⅔⅛⅜⅝⅞]+)\s*(.*)/i);
        if (match) {
          const numericPart = match[1]?.trim();
          const unitPart = match[2]?.trim() || "";
          try {
            const mixedParts = numericPart.split(/[\s\+]+/);
            let totalQuantity = 0;
            const unicodeFractions = {
              "½": 0.5,
              "¼": 0.25,
              "¾": 0.75,
              "⅓": 1 / 3,
              "⅔": 2 / 3,
              "⅛": 1 / 8,
              "⅜": 3 / 8,
              "⅝": 5 / 8,
              "⅞": 7 / 8,
            };

            for (const part of mixedParts) {
              if (part.includes("/")) {
                const fractionParts = part.split("/");
                if (fractionParts.length === 2) {
                  const num = parseFloat(fractionParts[0]);
                  const den = parseFloat(fractionParts[1]);
                  if (!isNaN(num) && !isNaN(den) && den !== 0)
                    totalQuantity += num / den;
                  else throw new Error("Invalid fraction part");
                } else throw new Error("Invalid fraction format");
              } else if (unicodeFractions[part]) {
                totalQuantity += unicodeFractions[part];
              } else {
                const num = parseFloat(part);
                if (!isNaN(num)) totalQuantity += num;
                else throw new Error("Invalid numeric part");
              }
            }
            return { quantity: totalQuantity, unit: unitPart };
          } catch (e) {
            console.warn("Could not parse yield quantity:", numericPart, e);
            return { quantity: null, unit: yieldString.trim() };
          }
        }
        return { quantity: null, unit: yieldString.trim() };
      };

      const formatScaledYield = (originalYieldString, multiplier) => {
        if (
          multiplier === 1 ||
          !originalYieldString ||
          originalYieldString.trim() === ""
        ) {
          return originalYieldString;
        }

        const { quantity, unit } = parseYield(originalYieldString);

        if (quantity === null || quantity === 0) {
          return originalYieldString;
        }

        const scaledQuantity = quantity * multiplier;

        let formattedUnit = unit;
        if (
          scaledQuantity > 1 &&
          unit &&
          !unit.endsWith("s") &&
          !unit.endsWith("es")
        ) {
          if (
            ["cup", "serving", "loin", "piece"].includes(unit.toLowerCase())
          ) {
            formattedUnit = unit + "s";
          }
        } else if (
          scaledQuantity <= 1 &&
          unit &&
          (unit.endsWith("s") || unit.endsWith("es"))
        ) {
          if (
            ["cups", "servings", "loins", "pieces"].includes(unit.toLowerCase())
          ) {
            formattedUnit = unit.slice(0, -1);
          } else if (["batches", "washes"].includes(unit.toLowerCase())) {
            formattedUnit = unit.slice(0, -2);
          }
        }

        return `${formatQuantity(scaledQuantity)} ${formattedUnit}`.trim();
      };

      const normalizeIngredient = (ingredient) => {
        const { description } = parseIngredient(ingredient);
        if (!description) return "";

        const units = [
          "tbsp",
          "tablespoon",
          "tbs",
          "tsp",
          "teaspoon",
          "cup",
          "c",
          "oz",
          "ounce",
          "fl oz",
          "fluid ounce",
          "pt",
          "pint",
          "qt",
          "quart",
          "gal",
          "gallon",
          "lb",
          "pound",
          "g",
          "gram",
          "kg",
          "kilogram",
          "mg",
          "milligram",
          "ml",
          "milliliter",
          "l",
          "liter",
          "clove",
          "can",
          "jar",
          "slice",
          "pinch",
          "dash",
          "stalk",
          "head",
          "sprig",
          "bunch",
          "package",
          "pkg",
          "box",
          "container",
          "stick",
          "piece",
          "fillet",
          "ear",
        ];
        const descriptors = [
          "to taste",
          "diced",
          "minced",
          "sliced",
          "chopped",
          "crushed",
          "fresh",
          "for garnish",
          "finely",
          "roughly",
          "peeled",
          "seeded",
          "cored",
          "rinsed",
          "dried",
          "optional",
          "divided",
          "softened",
          "melted",
          "beaten",
          "cooked",
          "uncooked",
          "raw",
          "canned",
          "frozen",
          "thawed",
          "packed",
          "firmly packed",
          "lightly packed",
          "heaping",
          "scant",
          "large",
          "medium",
          "small",
          "thinly",
          "thickly",
          "cubed",
          "julienned",
          "grated",
          "zested",
          "juiced",
          "room temperature",
          "cold",
          "hot",
          "warm",
          "about",
          "approximately",
          "plus more",
          "or more",
          "as needed",
          "such as",
        ];

        let normalized = description
          .toLowerCase()
          .replace(/\(.*?\)/g, "")
          .replace(new RegExp(`\\b(${units.join("|")})s?\\b`, "g"), "")
          .replace(new RegExp(`\\b(${descriptors.join("|")})\\b`, "g"), "")
          .replace(/[^a-z\s]/g, "")
          .replace(/\s+/g, " ")
          .trim();

        if (
          normalized.endsWith("es") &&
          ["tomato", "potato"].some((base) => normalized.startsWith(base))
        ) {
          normalized = normalized.slice(0, -2);
        } else if (
          normalized.endsWith("s") &&
          !normalized.endsWith("ss") &&
          !["greens", "oats", "pasta", "rice", "hummus", "molasses"].includes(
            normalized
          ) &&
          normalized.length > 2
        ) {
          normalized = normalized.slice(0, -1);
        }

        return normalized;
      };

      const capitalizeFirstLetter = (string) => {
        if (!string) return "";
        return string.charAt(0).toUpperCase() + string.slice(1);
      };

      const SAMPLE_RECIPES = [
        {
          id: "1",
          name: "Classic Spaghetti Bolognese",
          description:
            "A rich and hearty meat sauce simmered slowly and served over pasta. Comfort food at its best.",
          type: "Dinner",
          cuisine: "Italian",
          dietaryTypes: ["Dairy-Free"],
          tags: ["Weeknight", "Comfort Food"],
          prepTime: 20,
          cookTime: 40,
          additionalTime: 0,
          calories: 650,
          protein: 32,
          carbs: 78,
          fat: 22,
          servings: 4,
          yield: "4 servings",
          ingredients: [
            "1 lb ground beef",
            "1 onion, diced",
            "3 cloves garlic, minced",
            "2 cans (14 oz each) crushed tomatoes",
            "1 lb spaghetti",
            "2 tbsp olive oil",
            "Salt and Pepper to taste",
            "Fresh basil for garnish",
          ],
          directions: [
            "Heat olive oil in a large pot over medium heat.",
            "Add onions and garlic, sauté until translucent.",
            "Add ground beef and cook until browned.",
            "Pour in crushed tomatoes and seasonings.",
            "Simmer for 30 minutes.",
            "Cook spaghetti according to package directions.",
            "Serve sauce over pasta with fresh basil.",
          ],
          tipsAndTricks: [
            "For a vegetarian version, substitute ground beef with lentils or mushrooms.",
            "Add a splash of red wine to the sauce for extra depth of flavor.",
          ],
          createdAt: new Date(Date.now() - 86400000 * 2).toISOString(),
          isFavorite: false,
          image: null,
          video: null,
        },
        {
          id: "2",
          name: "Quick Garden Salad",
          description:
            "A light and refreshing salad, perfect for a quick lunch or side dish. Easily customizable.",
          type: "Lunch",
          cuisine: "American",
          dietaryTypes: ["Vegan", "Gluten-Free"],
          tags: ["Quick", "Healthy", "Vegan"],
          prepTime: 15,
          cookTime: 0,
          additionalTime: 0,
          calories: 200,
          protein: 5,
          carbs: 20,
          fat: 12,
          servings: 2,
          yield: "1 large bowl",
          ingredients: [
            "2 cups mixed greens",
            "1 tomato, diced",
            "1/2 red onion, sliced",
            "1 cucumber, sliced",
            "2 tbsp olive oil",
            "1 tbsp balsamic vinegar",
            "Salt and pepper to taste",
          ],
          directions: [
            "Combine greens, tomato, onion, and cucumber in a bowl.",
            "Drizzle with olive oil and balsamic vinegar.",
            "Season with salt and pepper.",
            "Toss and serve immediately.",
          ],
          tipsAndTricks: [
            "Add some toasted nuts or seeds for extra crunch and protein.",
            "For a creamier dressing, mix in a teaspoon of Dijon mustard.",
          ],
          createdAt: new Date(Date.now() - 86400000).toISOString(),
          isFavorite: true,
          image: null,
          video: null,
        },
        {
          id: "3",
          name: "Simple Beef Burgers",
          description:
            "Juicy, classic beef burgers perfect for grilling or pan-frying. A crowd-pleaser for any occasion.",
          type: "Dinner",
          cuisine: "American",
          dietaryTypes: [],
          tags: ["Grill", "Quick", "Kid-Friendly"],
          prepTime: 10,
          cookTime: 15,
          additionalTime: 5,
          calories: 550,
          protein: 30,
          carbs: 35,
          fat: 30,
          servings: 4,
          yield: "4 burgers",
          ingredients: [
            "1 lb ground beef",
            "1 tsp garlic powder",
            "1/2 tsp salt",
            "1/4 tsp black pepper",
            "4 burger buns",
            "Lettuce, tomato, onion slices (optional toppings)",
            "3 cloves garlic",
          ],
          directions: [
            "Preheat grill or pan.",
            "Gently mix ground beef, garlic powder, salt, and pepper. Do not overmix.",
            "Form into 4 patties.",
            "Grill or pan-fry for 4-6 minutes per side for medium, or longer depending on desired doneness.",
            "Let rest for 5 minutes.",
            "Serve on buns with desired toppings.",
          ],
          tipsAndTricks: [
            "For juicier burgers, mix in 1/4 cup of grated onion or breadcrumbs soaked in milk.",
            "Make a small indentation in the center of each patty before cooking to prevent bulging.",
          ],
          createdAt: new Date().toISOString(),
          isFavorite: false,
          image: null,
          video: null,
        },
      ];

      const usePersistentStorage = (storeName, initialValue, addToast) => {
        const [storedValue, setStoredValue] = useState(initialValue);
        const [isLoading, setIsLoading] = useState(true);
        const isMounted = useRef(true);

        useEffect(() => {
          const loadData = async () => {
            if (!isMounted.current) return;
            setIsLoading(true);
            try {
              const localStorageItem = localStorage.getItem(storeName);
              if (localStorageItem) {
                try {
                  const parsedLocalStorageData = JSON.parse(localStorageItem);

                  let dataToMigrate = parsedLocalStorageData;
                  if (storeName === STORE_NAMES.MEAL_PLAN) {
                    const days = [
                      "Sunday",
                      "Monday",
                      "Tuesday",
                      "Wednesday",
                      "Thursday",
                      "Friday",
                      "Saturday",
                    ];
                    const mealTimes = [
                      "breakfast",
                      "morningSnack",
                      "lunch",
                      "afternoonSnack",
                      "dinner",
                    ];
                    const migratedMealPlan = {};
                    days.forEach((day) => {
                      migratedMealPlan[day] = migratedMealPlan[day] || {};
                      mealTimes.forEach((mealTime) => {
                        const existingValue =
                          parsedLocalStorageData[day]?.[mealTime];
                        if (Array.isArray(existingValue)) {
                          migratedMealPlan[day][mealTime] = existingValue;
                        } else if (existingValue) {
                          migratedMealPlan[day][mealTime] = [existingValue];
                        } else {
                          migratedMealPlan[day][mealTime] = [];
                        }
                      });
                    });
                    dataToMigrate = migratedMealPlan;
                  } else if (
                    storeName === STORE_NAMES.RECIPES &&
                    Array.isArray(parsedLocalStorageData)
                  ) {
                    dataToMigrate = parsedLocalStorageData.map((recipe) => ({
                      ...recipe,
                      tags: recipe.tags || [],
                      description: recipe.description || "",
                      cuisine: recipe.cuisine || "",
                      dietaryTypes: recipe.dietaryTypes || [],
                      ingredients: recipe.ingredients || [],
                      directions: recipe.directions || [],
                      tipsAndTricks: recipe.tipsAndTricks || [],
                      yield: recipe.yield || "",
                    }));
                  }

                  if (Array.isArray(dataToMigrate)) {
                    for (const item of dataToMigrate) {
                      await addItem(storeName, item);
                    }
                  } else if (
                    typeof dataToMigrate === "object" &&
                    dataToMigrate !== null
                  ) {
                    await updateItem(storeName, storeName, {
                      id: storeName,
                      data: dataToMigrate,
                    });
                  }

                  localStorage.removeItem(storeName);
                  addToast(
                    `Migrated ${storeName} data from localStorage to IndexedDB!`,
                    "info"
                  );
                } catch (migrationError) {
                  console.error(
                    `Error migrating ${storeName} from localStorage:`,
                    migrationError
                  );
                  addToast(
                    `Failed to migrate ${storeName} data. Using IndexedDB directly.`,
                    "error"
                  );
                }
              }

              let dataFromIndexedDB;
              if (storeName === STORE_NAMES.MEAL_PLAN) {
                const mealPlanObj = await getStore(storeName, "readonly").then(
                  (store) => {
                    const req = store.get(storeName);
                    return new Promise((resolve, reject) => {
                      req.onsuccess = () => resolve(req.result);
                      req.onerror = () => reject(req.error);
                    });
                  }
                );
                dataFromIndexedDB = mealPlanObj ? mealPlanObj.data : null;

                if (!dataFromIndexedDB) {
                  dataFromIndexedDB = {};
                }
                const days = [
                  "Sunday",
                  "Monday",
                  "Tuesday",
                  "Wednesday",
                  "Thursday",
                  "Friday",
                  "Saturday",
                ];
                const mealTimes = [
                  "breakfast",
                  "morningSnack",
                  "lunch",
                  "afternoonSnack",
                  "dinner",
                ];
                const structuredPlan = {};
                days.forEach((day) => {
                  structuredPlan[day] = structuredPlan[day] || {};
                  mealTimes.forEach((mealTime) => {
                    const existingValue = dataFromIndexedDB[day]?.[mealTime];
                    if (Array.isArray(existingValue)) {
                      structuredPlan[day][mealTime] = existingValue;
                    } else if (existingValue) {
                      structuredPlan[day][mealTime] = [existingValue];
                    } else {
                      structuredPlan[day][mealTime] = [];
                    }
                  });
                });
                dataFromIndexedDB = structuredPlan;
              } else {
                dataFromIndexedDB = await getAllItems(storeName);
                if (
                  storeName === STORE_NAMES.RECIPES &&
                  Array.isArray(dataFromIndexedDB)
                ) {
                  dataFromIndexedDB = dataFromIndexedDB.map((recipe) => ({
                    ...recipe,
                    tags: recipe.tags || [],
                    description: recipe.description || "",
                    cuisine: recipe.cuisine || "",
                    dietaryTypes: recipe.dietaryTypes || [],
                    ingredients: recipe.ingredients || [],
                    directions: recipe.directions || [],
                    tipsAndTricks: recipe.tipsAndTricks || [],
                    yield: recipe.yield || "",
                  }));
                }
              }

              setStoredValue(
                dataFromIndexedDB.length > 0 ||
                  (storeName === STORE_NAMES.MEAL_PLAN &&
                    Object.keys(dataFromIndexedDB).length > 0)
                  ? dataFromIndexedDB
                  : initialValue
              );
            } catch (error) {
              console.error(
                `Error loading data from IndexedDB for ${storeName}:`,
                error
              );
              addToast(`Error loading ${storeName} data.`, "error");
              setStoredValue(initialValue);
            } finally {
              if (isMounted.current) {
                setIsLoading(false);
              }
            }
          };

          loadData();

          return () => {
            isMounted.current = false;
          };
        }, [storeName, addToast]);

        const setValue = useCallback(
          async (value) => {
            let valueToStore;
            setStoredValue((prev) => {
              valueToStore = value instanceof Function ? value(prev) : value;
              return valueToStore;
            });

            try {
              if (storeName === STORE_NAMES.MEAL_PLAN) {
                await updateItem(storeName, storeName, {
                  id: storeName,
                  data: valueToStore,
                });
              } else {
                await clearStore(storeName);
                if (Array.isArray(valueToStore)) {
                  for (const item of valueToStore) {
                    await addItem(storeName, item);
                  }
                }
              }
            } catch (error) {
              console.error(
                `Error saving data to IndexedDB for ${storeName}:`,
                error
              );
              addToast(`Failed to save ${storeName} data.`, "error");
            }
          },
          [storeName, addToast]
        );

        return [storedValue, setValue, isLoading];
      };

      const Toast = ({ message, type, onClose }) => {
        useEffect(() => {
          const timer = setTimeout(onClose, 3000);
          return () => clearTimeout(timer);
        }, [onClose]);

        const bgColor =
          type === "success"
            ? "bg-green-500"
            : type === "error"
            ? "bg-red-500"
            : "bg-blue-500";

        return (
          <div
            className={`p-3 rounded-lg shadow-lg text-white text-sm ${bgColor} animate-fade-in-out`}
          >
            {message}
          </div>
        );
      };

      const App = () => {
        const [toasts, setToasts] = useState([]);

        const addToast = useCallback((message, type = "info") => {
          const newToast = { id: Date.now(), message, type };
          setToasts((prevToasts) => [...prevToasts, newToast]);
          setTimeout(() => removeToast(newToast.id), 3000);
        }, []);

        const removeToast = useCallback((id) => {
          setToasts((prevToasts) =>
            prevToasts.filter((toast) => toast.id !== id)
          );
        }, []);

        const [recipes, setRecipes, isLoadingRecipes] = usePersistentStorage(
          STORE_NAMES.RECIPES,
          SAMPLE_RECIPES.map((r) => ({
            ...r,
            tags: r.tags || [],
            description: r.description || "",
            cuisine: r.cuisine || "",
            dietaryTypes: r.dietaryTypes || [],
            ingredients: r.ingredients || [],
            directions: r.directions || [],
            tipsAndTricks: r.tipsAndTricks || [],
            yield: r.yield || "",
          })),
          addToast
        );
        const [mealPlan, setMealPlan, isLoadingMealPlan] = usePersistentStorage(
          STORE_NAMES.MEAL_PLAN,
          {},
          addToast
        );
        const [shoppingList, setShoppingList, isLoadingShoppingList] =
          usePersistentStorage(STORE_NAMES.SHOPPING_LIST, [], addToast);

        const [isDarkMode, setIsDarkMode] = useState(() => {
          return (
            typeof window.matchMedia === "function" &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
          );
        });
        const [showAddRecipeModal, setShowAddRecipeModal] = useState(false);
        const [showRecipeDetails, setShowRecipeDetails] = useState(null);
        const [showMealPlanModal, setShowMealPlanModal] = useState(false);
        const [showShoppingListModal, setShowShoppingListModal] =
          useState(false);
        const [editingRecipe, setEditingRecipe] = useState(null);
        const [displayUnitSystem, setDisplayUnitSystem] = useState("imperial");

        const isLoading =
          isLoadingRecipes || isLoadingMealPlan || isLoadingShoppingList;

        useEffect(() => {
          const root = window.document.documentElement;
          if (isDarkMode) {
            root.classList.add("dark");
          } else {
            root.classList.remove("dark");
          }

          const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
          const handleChange = (e) => setIsDarkMode(e.matches);
          mediaQuery.addEventListener("change", handleChange);

          return () => mediaQuery.removeEventListener("change", handleChange);
        }, [isDarkMode]);

        useEffect(() => {
          const body = document.body;
          const isModalOpen =
            showAddRecipeModal ||
            !!showRecipeDetails ||
            showMealPlanModal ||
            showShoppingListModal;

          if (isModalOpen) {
            body.classList.add("modal-open");
          } else {
            body.classList.remove("modal-open");
          }
          return () => body.classList.remove("modal-open");
        }, [
          showAddRecipeModal,
          showRecipeDetails,
          showMealPlanModal,
          showShoppingListModal,
        ]);

        const exportRecipes = useCallback(async () => {
          try {
            const allRecipes = await getAllItems(STORE_NAMES.RECIPES);
            if (!Array.isArray(allRecipes) || allRecipes.length === 0) {
              throw new Error("No recipes found to export");
            }

            const dataStr = JSON.stringify(allRecipes, null, 2);
            const blob = new Blob([dataStr], {
              type: "application/json",
            });

            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "my-recipes.json";

            if (document.body) {
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
            } else {
              throw new Error("Document body not available");
            }

            URL.revokeObjectURL(url);
            addToast("Recipes exported successfully!", "success");
          } catch (err) {
            console.error("Export error:", err);
            addToast(`Error exporting recipes: ${err.message}`, "error");
          }
        }, [addToast]);

        const deleteAllRecipes = useCallback(async () => {
          if (
            !window.confirm(
              "Are you sure you want to delete ALL recipes, meal plans, and shopping list? This cannot be undone!"
            )
          ) {
            return;
          }
          try {
            await clearStore(STORE_NAMES.RECIPES);
            await clearStore(STORE_NAMES.MEAL_PLAN);
            await clearStore(STORE_NAMES.SHOPPING_LIST);
            setRecipes([]);
            setMealPlan({});
            setShoppingList([]);
            addToast(
              "All recipes and related data have been deleted.",
              "success"
            );
          } catch (error) {
            console.error("Error deleting all data:", error);
            addToast("Failed to delete all data.", "error");
          }
        }, [setRecipes, setMealPlan, setShoppingList, addToast]);

        const addRecipe = useCallback(
          async (recipeData) => {
            const newRecipe = {
              id:
                Date.now().toString(36) +
                Math.random().toString(36).substr(2, 5),
              ...recipeData,
              description: recipeData.description || "",
              cuisine: recipeData.cuisine || "",
              tags: recipeData.tags || [],
              dietaryTypes: recipeData.dietaryTypes || [],
              ingredients: recipeData.ingredients || [],
              directions: recipeData.directions || [],
              tipsAndTricks: recipeData.tipsAndTricks || [],
              yield: recipeData.yield || "",
              createdAt: new Date().toISOString(),
              isFavorite: false,
            };
            try {
              await addItem(STORE_NAMES.RECIPES, newRecipe);
              setRecipes((prev) => [...prev, newRecipe]);
              setShowAddRecipeModal(false);
              setEditingRecipe(null);
              addToast("Recipe added!", "success");
            } catch (error) {
              console.error("Error adding recipe:", error);
              addToast("Failed to add recipe.", "error");
            }
          },
          [setRecipes, addToast]
        );

        const updateRecipe = useCallback(
          async (id, recipeData) => {
            const updatedRecipe = {
              ...recipeData,
              id: id,
              updatedAt: new Date().toISOString(),
            };
            try {
              await updateItem(STORE_NAMES.RECIPES, id, updatedRecipe);
              setRecipes((prev) =>
                prev.map((r) => (r.id === id ? updatedRecipe : r))
              );
              setShowAddRecipeModal(false);
              setEditingRecipe(null);
              addToast("Recipe updated!", "success");
            } catch (error) {
              console.error("Error updating recipe:", error);
              addToast("Failed to update recipe.", "error");
            }
          },
          [setRecipes, addToast]
        );

        const deleteRecipe = useCallback(
          async (id) => {
            if (
              !window.confirm(
                "Are you sure you want to delete this recipe permanently?"
              )
            )
              return;

            try {
              await deleteItem(STORE_NAMES.RECIPES, id);
              setRecipes((prev) => prev.filter((r) => r.id !== id));

              setMealPlan((prev) => {
                const newPlan = JSON.parse(JSON.stringify(prev));
                let changed = false;
                Object.keys(newPlan).forEach((day) => {
                  if (newPlan[day] && typeof newPlan[day] === "object") {
                    Object.keys(newPlan[day]).forEach((mealTime) => {
                      const currentRecipesInSlot = newPlan[day][mealTime] || [];
                      const updatedRecipesInSlot = currentRecipesInSlot.filter(
                        (recipeId) => recipeId !== id
                      );
                      if (
                        updatedRecipesInSlot.length !==
                        currentRecipesInSlot.length
                      ) {
                        newPlan[day][mealTime] = updatedRecipesInSlot;
                        changed = true;
                      }
                    });
                  }
                });
                return changed ? newPlan : prev;
              });

              setShoppingList((prev) =>
                prev.filter((item) => item.recipeId !== id)
              );

              if (showRecipeDetails?.id === id) setShowRecipeDetails(null);
              addToast("Recipe deleted.", "success");
            } catch (error) {
              console.error("Error deleting recipe:", error);
              addToast("Failed to delete recipe.", "error");
            }
          },
          [
            setRecipes,
            setMealPlan,
            setShoppingList,
            addToast,
            showRecipeDetails,
          ]
        );

        const toggleFavorite = useCallback(
          async (id) => {
            let isNowFavorite = false;
            const recipeToUpdate = recipes.find((r) => r.id === id);
            if (!recipeToUpdate) return;

            isNowFavorite = !recipeToUpdate.isFavorite;
            const updatedRecipe = {
              ...recipeToUpdate,
              isFavorite: isNowFavorite,
            };

            try {
              await updateItem(STORE_NAMES.RECIPES, id, updatedRecipe);
              setRecipes((prev) =>
                prev.map((r) => (r.id === id ? updatedRecipe : r))
              );
              addToast(
                isNowFavorite ? "Added to Favorites" : "Removed from Favorites",
                "success"
              );
            } catch (error) {
              console.error("Error toggling favorite:", error);
              addToast("Failed to update favorite status.", "error");
            }
          },
          [recipes, setRecipes, addToast]
        );

        const searchRecipes = useCallback(
          (query, filters) => {
            filters = filters || {};
            const normalizedQuery = query ? query.toLowerCase().trim() : "";

            return recipes.filter((recipe) => {
              if (!recipe || typeof recipe.name !== "string") return false;

              let matchesQuery = !normalizedQuery;
              if (normalizedQuery) {
                const nameMatch = recipe.name
                  .toLowerCase()
                  .includes(normalizedQuery);
                const typeMatch = recipe.type
                  ?.toLowerCase()
                  .includes(normalizedQuery);

                matchesQuery = nameMatch || typeMatch;
              }

              const matchesType = filters.type
                ? recipe.type === filters.type
                : true;
              const matchesCuisine = filters.cuisine
                ? recipe.cuisine === filters.cuisine
                : true;
              const matchesDietary = filters.dietaryType
                ? recipe.dietaryTypes?.includes(filters.dietaryType)
                : true;
              const normalizedTagQuery = filters.tag
                ? filters.tag.toLowerCase().trim()
                : "";
              const matchesTag = normalizedTagQuery
                ? recipe.tags?.some(
                    (tag) => tag.toLowerCase() === normalizedTagQuery
                  )
                : true;
              const matchesFavorite = filters.favorites
                ? recipe.isFavorite === true
                : true;

              const totalTime =
                parseInt(recipe.prepTime || 0) +
                parseInt(recipe.cookTime || 0) +
                parseInt(recipe.additionalTime || 0);
              const filterCookTime = filters.cookTime
                ? parseInt(filters.cookTime)
                : Infinity;
              const matchesCookTime = filters.cookTime
                ? totalTime <= filterCookTime
                : true;

              return (
                matchesQuery &&
                matchesType &&
                matchesCuisine &&
                matchesDietary &&
                matchesTag &&
                matchesFavorite &&
                matchesCookTime
              );
            });
          },
          [recipes]
        );

        const updateMealPlan = useCallback(
          async (day, mealTime, recipeId) => {
            setMealPlan((prev) => {
              const newPlan = { ...prev };
              newPlan[day] = newPlan[day] || {};
              const currentRecipesInSlot = newPlan[day][mealTime] || [];

              if (currentRecipesInSlot.includes(recipeId)) {
                newPlan[day][mealTime] = currentRecipesInSlot.filter(
                  (id) => id !== recipeId
                );
                addToast("Recipe removed from meal slot.", "info");
              } else {
                newPlan[day][mealTime] = [...currentRecipesInSlot, recipeId];
                addToast("Recipe added to meal slot!", "success");
              }
              return newPlan;
            });
          },
          [setMealPlan, addToast]
        );

        const removeMealFromPlan = useCallback(
          async (day, mealTime, recipeIdToRemove) => {
            setMealPlan((prev) => {
              const newPlan = { ...prev };
              newPlan[day] = newPlan[day] || {};
              const currentRecipesInSlot = newPlan[day][mealTime] || [];

              const updatedRecipesInSlot = currentRecipesInSlot.filter(
                (id) => id !== recipeIdToRemove
              );

              newPlan[day][mealTime] = updatedRecipesInSlot;
              addToast("Recipe removed from plan.", "success");
              return newPlan;
            });
          },
          [setMealPlan, addToast]
        );

        const addMultipleRecipesToShoppingList = useCallback(
          async (recipeIds) => {
            if (!Array.isArray(recipeIds) || recipeIds.length === 0) return;

            let totalIngredientsAdded = 0;
            const recipeNamesAdded = new Set();
            setShoppingList((prevList) => {
              const currentNormalizedItems = new Set(
                prevList.map((item) => item.normalizedText)
              );
              const newList = [...prevList];
              recipeIds.forEach((recipeId) => {
                const recipe = recipes.find((r) => r.id === recipeId);
                if (
                  !recipe ||
                  !Array.isArray(recipe.ingredients) ||
                  recipe.ingredients.length === 0
                ) {
                  console.warn(
                    `Recipe ${recipeId} not found or has no ingredients.`
                  );
                  return;
                }
                recipe.ingredients
                  .filter((ing) => typeof ing === "string" && ing.trim() !== "")
                  .forEach((ingredient) => {
                    const normalized = normalizeIngredient(ingredient);
                    if (!currentNormalizedItems.has(normalized)) {
                      const { quantity, unit, description } =
                        parseIngredient(ingredient);
                      newList.push({
                        id:
                          Date.now().toString(36) +
                          Math.random().toString(36).substr(2, 5),
                        originalText: ingredient.trim(),
                        quantity: quantity,
                        unit: unit,
                        description: description,
                        recipeId: recipe.id,
                        recipeName: recipe.name,
                        checked: false,
                        normalizedText: normalized,
                      });
                      currentNormalizedItems.add(normalized);
                      totalIngredientsAdded++;
                    }
                  });
                recipeNamesAdded.add(recipe.name);
              });
              if (totalIngredientsAdded > 0) {
                addToast(
                  `Added ${totalIngredientsAdded} ingredient(s) from ${recipeNamesAdded.size} recipe(s).`,
                  "success"
                );
              } else {
                addToast("No new ingredients to add.", "info");
              }
              return newList;
            });
          },
          [recipes, setShoppingList, addToast]
        );

        const addToShoppingList = useCallback(
          (recipeId) => {
            addMultipleRecipesToShoppingList([recipeId]);
          },
          [addMultipleRecipesToShoppingList]
        );

        const toggleShoppingItem = useCallback(
          async (itemId, normalizedTextToToggle) => {
            setShoppingList((prevList) => {
              let targetChecked;
              let targetNormalizedText;

              if (itemId) {
                const clickedItem = prevList.find((item) => item.id === itemId);
                if (!clickedItem) return prevList;
                targetChecked = !clickedItem.checked;
                targetNormalizedText = clickedItem.normalizedText;
              } else if (normalizedTextToToggle) {
                const groupItems = prevList.filter(
                  (item) => item.normalizedText === normalizedTextToToggle
                );
                if (groupItems.length === 0) return prevList;
                const allCurrentlyChecked = groupItems.every(
                  (item) => item.checked
                );
                targetChecked = !allCurrentlyChecked;
                targetNormalizedText = normalizedTextToToggle;
              } else {
                return prevList;
              }

              return prevList.map((item) => {
                if (item.normalizedText === targetNormalizedText) {
                  return { ...item, checked: targetChecked };
                }
                return item;
              });
            });
          },
          [setShoppingList]
        );

        const clearShoppingList = useCallback(async () => {
          if (
            window.confirm(
              "Are you sure you want to clear the entire shopping list?"
            )
          ) {
            try {
              await clearStore(STORE_NAMES.SHOPPING_LIST);
              setShoppingList([]);
              addToast("Shopping list cleared!", "success");
            } catch (error) {
              console.error("Error clearing shopping list:", error);
              addToast("Failed to clear shopping list.", "error");
            }
          }
        }, [setShoppingList, addToast]);

        const generateRecipePDF = useCallback(
          async (recipe) => {
            if (!recipe || typeof recipe !== "object") {
              addToast("Invalid recipe data.", "error");
              return;
            }
            if (typeof html2pdf === "undefined") {
              addToast("PDF library not loaded. Please refresh.", "error");
              console.error("html2pdf is not defined");
              return;
            }

            addToast("Generating PDF...", "info");

            const content = document.createElement("div");
            content.style.cssText = `font-family: sans-serif; padding: 30px; line-height: 1.6; color: #333; font-size: 10pt; max-width: 8.5in;`;

            const recipeName = escapeHTML(recipe.name || "Untitled");
            const recipeDescriptionHtml = recipe.description
              ? `<p style="font-size: 10pt; color: #555; margin-bottom: 20px; text-align: center; font-style: italic;">${escapeHTML(
                  recipe.description
                )}</p>`
              : "";
            const typeHtml = recipe.type
              ? `<p style="font-size: 9pt; color: #777;">Type: ${escapeHTML(
                  recipe.type
                )}</p>`
              : "";
            const cuisineHtml = recipe.cuisine
              ? `<p style="font-size: 9pt; color: #777;">Cuisine: ${escapeHTML(
                  recipe.cuisine
                )}</p>`
              : "";
            const dietaryTypesHtml =
              Array.isArray(recipe.dietaryTypes) &&
              recipe.dietaryTypes.length > 0
                ? `<p style="font-size: 9pt; color: #777;">Dietary: ${recipe.dietaryTypes
                    .map(escapeHTML)
                    .join(", ")}</p>`
                : "";
            const tagsHtml =
              Array.isArray(recipe.tags) && recipe.tags.length > 0
                ? `<p style="font-size: 9pt; color: #777;">Tags: ${recipe.tags
                    .map(escapeHTML)
                    .join(", ")}</p>`
                : "";

            let imageHtml = `<div style="text-align: center; margin-bottom: 25px; padding: 20px; border: 1px dashed #ccc; color: #888; border-radius: 8px;">No Image</div>`;
            if (recipe.image) {
              imageHtml = `<img src="${recipe.image}" style="max-width: 250px; max-height: 250px; display: block; margin: 0 auto 25px; border-radius: 8px; border: 1px solid #eee;" alt="${recipeName}"/>`;
            }

            const prepTimeFormatted = formatMinutesToHoursMinutes(
              recipe.prepTime
            );
            const cookTimeFormatted = formatMinutesToHoursMinutes(
              recipe.cookTime
            );
            const additionalTimeFormatted = formatMinutesToHoursMinutes(
              recipe.additionalTime
            );
            const totalTimeFormatted = formatMinutesToHoursMinutes(
              (recipe.prepTime || 0) +
                (recipe.cookTime || 0) +
                (recipe.additionalTime || 0)
            );

            const yieldHtml = recipe.yield
              ? `<p style="margin: 6px 0;">Yield: ${escapeHTML(
                  recipe.yield
                )}</p>`
              : "";

            const ingredientsHtml =
              Array.isArray(recipe.ingredients) && recipe.ingredients.length > 0
                ? recipe.ingredients
                    .map(
                      (ing) =>
                        `<li style="margin-bottom: 5px;">${escapeHTML(
                          ing || ""
                        )}</li>`
                    )
                    .join("")
                : "<li>No ingredients listed.</li>";

            const directionsHtml =
              Array.isArray(recipe.directions) && recipe.directions.length > 0
                ? recipe.directions
                    .map(
                      (dir, i) =>
                        `<li style="margin-bottom: 12px; padding-left: 5px; border-left: 2px solid #2ecc71;"><strong>Step ${
                          i + 1
                        }:</strong> ${escapeHTML(dir || "")}</li>`
                    )
                    .join("")
                : "<li>No directions listed.</li>";

            const tipsAndTricksHtml =
              Array.isArray(recipe.tipsAndTricks) &&
              recipe.tipsAndTricks.length > 0
                ? recipe.tipsAndTricks
                    .map(
                      (tip) =>
                        `<li style="margin-bottom: 8px; padding-left: 5px; border-left: 2px solid #f59e0b;"><strong>Tip:</strong> ${escapeHTML(
                          tip || ""
                        )}</li>`
                    )
                    .join("")
                : "<li>No tips and tricks listed.</li>";

            content.innerHTML = `
              <div style="text-align: center; margin-bottom: 10px;">
                <h1 style="color: #2ecc71; margin: 0 0 8px 0; font-size: 20pt; font-weight: bold;">${recipeName}</h1>
                <p style="margin: 0; font-size: 11pt; color: #555;">Servings: ${
                  recipe.servings || "N/A"
                }</p>
                ${typeHtml}
                ${cuisineHtml}
                ${dietaryTypesHtml}
                ${tagsHtml}
              </div>
              ${recipeDescriptionHtml}
              ${imageHtml}
              <div style="display: flex; flex-wrap: wrap; justify-content: space-between; gap: 20px; margin-bottom: 30px; border-top: 1px solid #eee; border-bottom: 1px solid #eee; padding: 20px 0;">
                <div style="flex: 1; min-width: 150px;">
                  <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Details</h3>
                  ${
                    prepTimeFormatted
                      ? `<p style="margin: 6px 0;">Prep: ${prepTimeFormatted}</p>`
                      : ""
                  }
                  ${
                    cookTimeFormatted
                      ? `<p style="margin: 6px 0;">Cook: ${cookTimeFormatted}</p>`
                      : ""
                  }
                  ${
                    additionalTimeFormatted
                      ? `<p style="margin: 6px 0;">Additional: ${additionalTimeFormatted}</p>`
                      : ""
                  }
                  <p style="margin: 10px 0 0 0; font-weight: bold;">Total: ${totalTimeFormatted}</p>
                  ${yieldHtml}
                </div>
                <div style="flex: 1; min-width: 150px;">
                  <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Nutrition (per serving)</h3>
                  <p style="margin: 6px 0;">Calories: ${
                    recipe.calories || "N/A"
                  }</p>
                  <p style="margin: 6px 0;">Protein: ${
                    recipe.protein ? recipe.protein + "g" : "N/A"
                  }</p>
                  <p style="margin: 6px 0;">Carbs: ${
                    recipe.carbs ? recipe.carbs + "g" : "N/A"
                  }</p>
                  <p style="margin: 6px 0;">Fat: ${
                    recipe.fat ? recipe.fat + "g" : "N/A"
                  }</p>
                </div>
              </div>
              <div style="margin-bottom: 30px;">
                <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Ingredients</h3>
                <ul style="list-style: disc; padding-left: 25px; margin: 0;">${ingredientsHtml}</ul>
              </div>
              <div style="margin-bottom: 30px;">
                <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Directions</h3>
                <ol style="list-style: none; padding-left: 0; margin: 0;">${directionsHtml}</ol>
              </div>
              <div>
                <h3 style="color: #f59e0b; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Tips & Tricks</h3>
                <ul style="list-style: none; padding-left: 0; margin: 0;">${tipsAndTricksHtml}</ul>
              </div>
            `;

            const opt = {
              margin: 0.5,
              filename: `${recipe.name
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")}-recipe.pdf`,
              image: { type: "jpeg", quality: 0.95 },
              html2canvas: {
                scale: 2,
                useCORS: true,
                logging: false,
                allowTaint: true,
              },
              jsPDF: { unit: "in", format: "letter", orientation: "portrait" },
              pagebreak: { mode: ["avoid-all", "css", "legacy"] },
            };

            try {
              const worker = html2pdf().set(opt).from(content);
              await worker.save();
              addToast("PDF downloaded!", "success");
            } catch (error) {
              console.error("PDF Generation Error:", error);
              addToast(
                `PDF generation failed: ${error.message || "Unknown error"}`,
                "error"
              );
              if (error.stack) {
                console.error(error.stack);
              }
            }
          },
          [addToast]
        );

        return (
          <div className="min-h-screen flex flex-col">
            <Header
              openAddRecipeModal={() => {
                setEditingRecipe(null);
                setShowAddRecipeModal(true);
              }}
              openMealPlanModal={() => setShowMealPlanModal(true)}
              openShoppingListModal={() => setShowShoppingListModal(true)}
              recipes={recipes}
              addToast={addToast}
              setRecipes={setRecipes}
              deleteAllRecipes={deleteAllRecipes}
              exportRecipes={exportRecipes}
            />
            <main className="flex-grow max-w-7xl mx-auto p-3 sm:p-4 w-full">
              {isLoading ? (
                <div className="text-center py-10 text-gray-500 dark:text-gray-400">
                  <i className="fas fa-spinner fa-spin text-4xl mb-3"></i>
                  <p className="text-lg">Loading recipes...</p>
                  <p className="text-sm">
                    This might take a moment if migrating from old storage.
                  </p>
                </div>
              ) : (
                <RecipeList
                  recipes={recipes}
                  searchRecipes={searchRecipes}
                  openRecipeDetails={(recipe) => setShowRecipeDetails(recipe)}
                  toggleFavorite={toggleFavorite}
                />
              )}
            </main>
            {showAddRecipeModal && (
              <AddRecipeModal
                onClose={() => {
                  setShowAddRecipeModal(false);
                  setEditingRecipe(null);
                }}
                addRecipe={addRecipe}
                updateRecipe={updateRecipe}
                editingRecipe={editingRecipe}
                addToast={addToast}
              />
            )}
            {showRecipeDetails && (
              <RecipeDetailsModal
                recipe={showRecipeDetails}
                onClose={() => setShowRecipeDetails(null)}
                addToShoppingList={addToShoppingList}
                generateRecipePDF={generateRecipePDF}
                deleteRecipe={deleteRecipe}
                editRecipe={(recipe) => {
                  setEditingRecipe(recipe);
                  setShowRecipeDetails(null);
                  setShowAddRecipeModal(true);
                }}
                toggleFavorite={toggleFavorite}
                addToast={addToast}
                updateMealPlan={updateMealPlan}
                mealPlan={mealPlan}
                recipes={recipes}
              />
            )}
            {showMealPlanModal && (
              <MealPlanModal
                mealPlan={mealPlan}
                recipes={recipes}
                updateMealPlan={updateMealPlan}
                removeMealFromPlan={removeMealFromPlan}
                addMultipleRecipesToShoppingList={
                  addMultipleRecipesToShoppingList
                }
                onClose={() => setShowMealPlanModal(false)}
              />
            )}
            {showShoppingListModal && (
              <ShoppingListModal
                shoppingList={shoppingList}
                toggleShoppingItem={toggleShoppingItem}
                clearShoppingList={clearShoppingList}
                addToast={addToast}
                onClose={() => setShowShoppingListModal(false)}
                displayUnitSystem={displayUnitSystem}
                setDisplayUnitSystem={setDisplayUnitSystem}
                convertUnits={convertUnits}
              />
            )}
            <div className="fixed bottom-4 right-4 z-[100] space-y-2">
              {toasts.map((toast) => (
                <Toast
                  key={toast.id}
                  message={toast.message}
                  type={toast.type}
                  onClose={() => removeToast(toast.id)}
                />
              ))}
            </div>
            <Footer />
          </div>
        );
      };

      const Header = ({
        openAddRecipeModal,
        openMealPlanModal,
        openShoppingListModal,
        recipes,
        addToast,
        setRecipes,
        deleteAllRecipes,
        exportRecipes,
      }) => {
        const [searchQuery, setSearchQuery] = useState("");
        const debounceTimeoutRef = useRef(null);

        const handleSearchChange = useCallback((e) => {
          const query = e.target.value;
          setSearchQuery(query);

          if (debounceTimeoutRef.current)
            clearTimeout(debounceTimeoutRef.current);

          debounceTimeoutRef.current = setTimeout(() => {
            document.dispatchEvent(
              new CustomEvent("searchRecipes", {
                detail: { query, type: "search" },
              })
            );
          }, 350);
        }, []);

        const handleToggleAllRecipes = useCallback(() => {
          document.dispatchEvent(
            new CustomEvent("searchRecipes", {
              detail: { type: "toggleAll" },
            })
          );
          setSearchQuery("");
        }, []);

        useEffect(
          () => () => {
            if (debounceTimeoutRef.current)
              clearTimeout(debounceTimeoutRef.current);
          },
          []
        );

        return (
          <header className="bg-white dark:bg-gray-800 shadow-md p-3 sticky top-0 z-30 transition-colors duration-300">
            <nav className="max-w-7xl mx-auto flex justify-between items-center flex-wrap gap-y-2 gap-x-3">
              <h1 className="text-lg sm:text-xl font-bold text-green-500 whitespace-nowrap flex items-center gap-2 order-1 sm:order-1">
                <i className="fas fa-book-open text-green-500"></i>
                <span className="hidden sm:inline">Recipe Manager Pro</span>
                <span className="sm:hidden">Recipes</span>
              </h1>

              <div className="flex-grow flex items-center bg-gray-100 dark:bg-gray-700 rounded-full px-3 py-1.5 w-full sm:w-auto sm:flex-grow sm:max-w-md md:mx-auto order-3 sm:order-2">
                <i className="fas fa-search text-gray-400 dark:text-gray-500 mr-2 text-sm"></i>
                <input
                  type="search"
                  placeholder="Search recipes..."
                  value={searchQuery}
                  className="bg-transparent outline-none text-sm text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 w-full"
                  onChange={handleSearchChange}
                  aria-label="Search recipes"
                />
              </div>

              <div className="flex items-center gap-1.5 sm:gap-2 order-2 sm:order-3">
                <button
                  onClick={handleToggleAllRecipes}
                  className="btn-header"
                  title="Show/Hide All Recipes"
                >
                  <i className="fas fa-list-alt text-green-500"></i>
                  <span className="hidden lg:inline ml-1">All</span>
                </button>
                <button
                  onClick={openMealPlanModal}
                  className="btn-header"
                  title="Meal Plan"
                >
                  <i className="fas fa-calendar-alt text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Plan</span>
                </button>
                <button
                  onClick={openShoppingListModal}
                  className="btn-header"
                  title="Shopping List"
                >
                  <i className="fas fa-shopping-cart text-green-500"></i>
                  <span className="hidden lg:inline ml-1">List</span>
                </button>
                <button
                  onClick={openAddRecipeModal}
                  className="btn-header bg-green-500 text-white hover:bg-green-600 dark:hover:bg-green-600"
                  title="Add Recipe"
                >
                  <i className="fas fa-plus text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Add</span>
                </button>
                <button
                  onClick={deleteAllRecipes}
                  className="btn-header bg-red-500 text-white hover:bg-red-600 dark:hover:bg-red-600"
                  title="Delete All Recipes"
                >
                  <i className="fas fa-trash-alt text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Delete All</span>
                </button>
                <button
                  onClick={exportRecipes}
                  className="btn-header"
                  title="Export Recipes"
                >
                  <i className="fas fa-file-export text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Export</span>
                </button>
                <button
                  onClick={() => {
                    const input = document.createElement("input");
                    input.type = "file";
                    input.accept = ".json";
                    input.onchange = async (e) => {
                      const file = e.target.files[0];
                      if (!file) return;

                      const reader = new FileReader();
                      reader.onload = async (e) => {
                        try {
                          const rawData = JSON.parse(e.target.result);
                          let importedRecipes = [];

                          if (Array.isArray(rawData)) {
                            importedRecipes = rawData;
                          } else if (
                            typeof rawData === "object" &&
                            rawData !== null &&
                            rawData.name
                          ) {
                            importedRecipes = [rawData];
                          } else {
                            throw new Error(
                              "Invalid file format: Expected a recipe object or an array of recipes."
                            );
                          }

                          const timestamp = Date.now();
                          const processedRecipes = importedRecipes
                            .filter((recipe) => {
                              const isValid =
                                recipe &&
                                typeof recipe === "object" &&
                                typeof recipe.name === "string" &&
                                recipe.name.trim() !== "";
                              if (!isValid) {
                                console.warn(
                                  "Skipping invalid recipe:",
                                  recipe
                                );
                              }
                              return isValid;
                            })
                            .map((recipe, index) => {
                              const uniqueId = `${timestamp.toString(
                                36
                              )}-${index}-${Math.random()
                                .toString(36)
                                .substr(2, 5)}`;

                              return {
                                id: uniqueId,
                                name: recipe.name?.trim() || "Untitled Recipe",
                                description: recipe.description?.trim() || "",
                                type: recipe.type?.trim() || "Other",
                                cuisine: recipe.cuisine?.trim() || "",
                                dietaryTypes: Array.isArray(recipe.dietaryTypes)
                                  ? recipe.dietaryTypes
                                      .filter(
                                        (t) => typeof t === "string" && t.trim()
                                      )
                                      .map((t) => t.trim())
                                  : [],
                                tags: Array.isArray(recipe.tags)
                                  ? recipe.tags
                                      .filter(
                                        (t) => typeof t === "string" && t.trim()
                                      )
                                      .map((t) => t.trim())
                                  : [],
                                prepTime: recipe.prepTime
                                  ? Math.max(0, parseInt(recipe.prepTime))
                                  : 0,
                                cookTime: recipe.cookTime
                                  ? Math.max(0, parseInt(recipe.cookTime))
                                  : 0,
                                additionalTime: recipe.additionalTime
                                  ? Math.max(0, parseInt(recipe.additionalTime))
                                  : 0,
                                servings: recipe.servings
                                  ? Math.max(1, parseInt(recipe.servings))
                                  : 1,
                                yield: recipe.yield?.trim() || "",
                                ingredients: Array.isArray(recipe.ingredients)
                                  ? recipe.ingredients
                                      .filter(
                                        (i) => typeof i === "string" && i.trim()
                                      )
                                      .map((i) => i.trim())
                                  : [],
                                directions: Array.isArray(recipe.directions)
                                  ? recipe.directions
                                      .filter(
                                        (d) => typeof d === "string" && d.trim()
                                      )
                                      .map((d) => d.trim())
                                  : [],
                                tipsAndTricks: Array.isArray(
                                  recipe.tipsAndTricks
                                )
                                  ? recipe.tipsAndTricks
                                      .filter(
                                        (tip) =>
                                          typeof tip === "string" && tip.trim()
                                      )
                                      .map((tip) => tip.trim())
                                  : [],
                                calories: recipe.calories
                                  ? Math.max(0, parseInt(recipe.calories))
                                  : null,
                                protein: recipe.protein
                                  ? Math.max(0, parseFloat(recipe.protein))
                                  : null,
                                carbs: recipe.carbs
                                  ? Math.max(0, parseFloat(recipe.carbs))
                                  : null,
                                fat: recipe.fat
                                  ? Math.max(0, parseFloat(recipe.fat))
                                  : null,
                                image:
                                  typeof recipe.image === "string"
                                    ? recipe.image
                                    : null,
                                video:
                                  typeof recipe.video === "string"
                                    ? recipe.video
                                    : null,
                                createdAt: new Date().toISOString(),
                                isFavorite: false,
                              };
                            });

                          if (processedRecipes.length === 0) {
                            addToast(
                              "No valid recipes found in import file.",
                              "error"
                            );
                            return;
                          }

                          for (const recipe of processedRecipes) {
                            await addItem(STORE_NAMES.RECIPES, recipe);
                          }
                          const updatedRecipesFromDB = await getAllItems(
                            STORE_NAMES.RECIPES
                          );
                          setRecipes(updatedRecipesFromDB);

                          addToast(
                            `Successfully imported ${processedRecipes.length} recipes!`,
                            "success"
                          );
                        } catch (err) {
                          console.error("Import error:", err);
                          addToast(
                            `Error importing recipes: ${
                              err.message || "Invalid file format"
                            }`,
                            "error"
                          );
                        }
                      };

                      reader.onerror = () => {
                        addToast(
                          "Error reading file. Please try again.",
                          "error"
                        );
                      };

                      reader.readAsText(file);
                    };
                    input.click();
                  }}
                  className="btn-header"
                  title="Import Recipes"
                >
                  <i className="fas fa-file-import text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Import</span>
                </button>
              </div>
            </nav>
          </header>
        );
      };

      const RecipeSuggestions = ({
        recipes,
        openRecipeDetails,
        toggleFavorite,
      }) => {
        const [isExpanded, setIsExpanded] = useState(false);

        const suggested = useMemo(() => {
          if (!Array.isArray(recipes) || recipes.length === 0) return [];

          const favorites = recipes.filter((r) => r?.isFavorite === true);
          const nonFavorites = recipes.filter((r) => r?.isFavorite !== true);

          favorites.sort(() => 0.5 - Math.random());
          nonFavorites.sort(() => 0.5 - Math.random());

          const suggestions = [...favorites.slice(0, 2), ...nonFavorites];

          const uniqueSuggestions = [];
          const seenIds = new Set();
          for (const recipe of suggestions) {
            if (recipe?.id && !seenIds.has(recipe.id)) {
              uniqueSuggestions.push(recipe);
              seenIds.add(recipe.id);
              if (uniqueSuggestions.length === 3) break;
            }
          }
          return uniqueSuggestions;
        }, [recipes]);

        if (!suggested || suggested.length === 0) return null;

        return (
          <section className="mb-6 sm:mb-8 p-3 sm:p-4 bg-gray-50 dark:bg-gray-800 rounded-lg shadow">
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="flex justify-between items-center w-full text-left mb-3 sm:mb-4"
              aria-expanded={isExpanded}
              aria-controls="suggestions-content"
            >
              <h2 className="text-lg sm:text-xl font-semibold text-gray-800 dark:text-gray-200">
                Suggestions For You
              </h2>
              <i
                className={`fas fa-chevron-down text-gray-500 dark:text-gray-400 transform transition-transform duration-200 ${
                  isExpanded ? "rotate-180" : ""
                }`}
                aria-hidden="true"
              ></i>
            </button>

            <div
              id="suggestions-content"
              className={`collapsible-content ${isExpanded ? "expanded" : ""}`}
            >
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
                {suggested.map((recipe) => (
                  <div
                    key={recipe.id}
                    className="bg-white dark:bg-gray-700 rounded-lg shadow overflow-hidden cursor-pointer hover:shadow-lg transition-shadow duration-300 flex flex-col"
                    onClick={() => openRecipeDetails(recipe)}
                    tabIndex="0"
                    aria-label={`View suggestion: ${recipe.name}`}
                  >
                    <div className="aspect-video w-full bg-gray-200 dark:bg-gray-600 overflow-hidden relative">
                      {recipe.image ? (
                        <img
                          src={recipe.image}
                          alt={recipe.name}
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                          <i className="fas fa-image text-3xl opacity-50"></i>
                        </div>
                      )}
                      {recipe.isFavorite && (
                        <div className="absolute top-2 right-2 bg-black bg-opacity-40 text-yellow-400 p-1 rounded-full text-xs">
                          <i className="fas fa-star"></i>
                        </div>
                      )}
                    </div>
                    <div className="p-3 flex-grow flex flex-col">
                      <h3
                        className="text-base font-semibold mb-1 line-clamp-1 flex-grow"
                        title={recipe.name}
                      >
                        {escapeHTML(recipe.name)}
                      </h3>
                      {recipe.description && (
                        <p
                          className="text-xs text-gray-500 dark:text-gray-400 mb-1 line-clamp-2"
                          title={recipe.description}
                        >
                          {escapeHTML(recipe.description)}
                        </p>
                      )}
                      <div className="flex justify-between items-center mt-auto pt-1">
                        <span className="inline-block bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 text-xs px-2 py-0.5 rounded-full">
                          {escapeHTML(recipe.type)}
                        </span>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleFavorite(recipe.id);
                          }}
                          className={`text-xl ml-2 ${
                            recipe.isFavorite
                              ? "text-yellow-500"
                              : "text-gray-300 dark:text-gray-500"
                          } hover:text-yellow-400 dark:hover:text-yellow-400`}
                          title={
                            recipe.isFavorite
                              ? "Remove Favorite"
                              : "Add Favorite"
                          }
                          aria-label={
                            recipe.isFavorite
                              ? "Remove Favorite"
                              : "Add Favorite"
                          }
                        >
                          <i className={`fas fa-star`}></i>
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </section>
        );
      };
      const RecipeList = ({
        recipes,
        searchRecipes,
        openRecipeDetails,
        toggleFavorite,
      }) => {
        const [filteredRecipes, setFilteredRecipes] = useState([]);
        const [filters, setFilters] = useState({
          query: "",
          type: "",
          cuisine: "",
          dietaryType: "",
          tag: "",
          cookTime: "",
          favorites: false,
        });
        const [hideAllExplicitly, setHideAllExplicitly] = useState(false);

        useEffect(() => {
          const isFilterActive =
            filters.query ||
            filters.type ||
            filters.cuisine ||
            filters.dietaryType ||
            filters.tag ||
            filters.cookTime ||
            filters.favorites;

          let results = recipes;

          if (isFilterActive || !hideAllExplicitly) {
            results = searchRecipes(filters.query, filters);
          }

          const sorted = [...results].sort((a, b) => {
            if (!a.createdAt && !b.createdAt) return 0;
            if (!a.createdAt) return 1;
            if (!b.createdAt) return -1;
            return new Date(b.createdAt) - new Date(a.createdAt);
          });

          setFilteredRecipes(sorted);
        }, [recipes, filters, searchRecipes, hideAllExplicitly]);

        useEffect(() => {
          const handler = (e) => {
            if (e.detail.type === "toggleAll") {
              setHideAllExplicitly((prev) => !prev);
              setFilters({
                query: "",
                type: "",
                cuisine: "",
                dietaryType: "",
                tag: "",
                cookTime: "",
                favorites: false,
              });
            } else if (e.detail.type === "search") {
              setHideAllExplicitly(false);
              setFilters((prev) => ({
                ...prev,
                query: e.detail.query,
              }));
            }
          };
          document.addEventListener("searchRecipes", handler);
          return () => document.removeEventListener("searchRecipes", handler);
        }, []);

        const handleFilterChange = useCallback((e) => {
          const { name, value, type, checked } = e.target;
          setHideAllExplicitly(false);
          setFilters((prev) => ({
            ...prev,
            [name]: type === "checkbox" ? checked : value,
          }));
        }, []);

        const recipesToDisplay = hideAllExplicitly ? [] : filteredRecipes;

        const hasActiveFiltersExcludingQuery =
          filters.type ||
          filters.cuisine ||
          filters.dietaryType ||
          filters.tag ||
          filters.cookTime ||
          filters.favorites;

        return (
          <section>
            <div className="mb-4 sm:mb-6 flex flex-wrap gap-5 items-center bg-gray-50 dark:bg-gray-800 p-2 sm:p-3 rounded-lg shadow-sm">
              <span className="text-sm font-medium mr-1 hidden md:inline text-gray-700 dark:text-gray-300">
                Filter:
              </span>
              <select
                name="type"
                value={filters.type}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Meal Type"
              >
                <option value="">All Types</option>
                {[...new Set(recipes.map((r) => r?.type).filter(Boolean))]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              <select
                name="cuisine"
                value={filters.cuisine}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter by Cuisine"
              >
                <option value="">All Cuisines</option>
                {[...new Set(recipes.map((r) => r?.cuisine).filter(Boolean))]
                  .sort()
                  .map((c) => (
                    <option key={c} value={c}>
                      {c}
                    </option>
                  ))}
              </select>
              <select
                name="dietaryType"
                value={filters.dietaryType}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Dietary Type"
              >
                <option value="">All Dietary</option>
                {[
                  ...new Set(
                    recipes
                      .flatMap((r) => r?.dietaryTypes || [])
                      .filter(Boolean)
                  ),
                ]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              <select
                name="tag"
                value={filters.tag}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter by Tag"
              >
                <option value="">All Tags</option>
                {[
                  ...new Set(
                    recipes.flatMap((r) => r?.tags || []).filter(Boolean)
                  ),
                ]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              <select
                name="cookTime"
                value={filters.cookTime}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Total Time"
              >
                <option value="">Any Time</option>
                {[15, 30, 45, 60, 90, 120].map((t) => (
                  <option key={t} value={t}>
                    ≤ {t} min
                  </option>
                ))}
              </select>
              <label
                className="flex items-center gap-1 cursor-pointer text-xs sm:text-sm whitespace-nowrap ml-1 sm:ml-2 text-gray-700 dark:text-gray-300"
                title="Favorites Only"
              >
                <input
                  type="checkbox"
                  name="favorites"
                  checked={filters.favorites}
                  onChange={handleFilterChange}
                  className="w-3.5 h-3.5 sm:w-4 sm:h-4 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-600"
                />
                <i className="fas fa-star text-yellow-400"></i>
                <span className="hidden sm:inline">Favs</span>
              </label>

              <div className="ml-auto text-sm font-semibold text-gray-700 dark:text-gray-300 flex items-center gap-1">
                <i className="fas fa-utensils text-green-500"></i>
                Recipes: {recipesToDisplay.length}
              </div>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-5">
              {recipesToDisplay.length > 0 ? (
                recipesToDisplay.map((recipe) => (
                  <div
                    key={recipe.id}
                    onClick={() => openRecipeDetails(recipe)}
                    tabIndex="0"
                    aria-label={`View recipe: ${recipe.name}`}
                    className="bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden cursor-pointer hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 transition-all duration-300 flex flex-col group"
                  >
                    <div className="aspect-video w-full bg-gray-200 dark:bg-gray-700 overflow-hidden relative">
                      {recipe.image ? (
                        <img
                          src={recipe.image}
                          alt={recipe.name}
                          className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                          <i className="fas fa-image text-4xl mb-3 opacity-50"></i>
                        </div>
                      )}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          toggleFavorite(recipe.id);
                        }}
                        aria-label={
                          recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                        }
                        className={`absolute top-2 right-2 text-2xl ${
                          recipe.isFavorite
                            ? "text-yellow-400 filter drop-shadow(0 1px 1px rgba(0,0,0,0.5))"
                            : "text-white text-opacity-50"
                        } hover:text-yellow-300 hover:text-opacity-100 transition-colors duration-200 z-10`}
                      >
                        <i
                          className={`fa-star ${
                            recipe.isFavorite ? "fas" : "far"
                          }`}
                        ></i>
                      </button>
                    </div>
                    <div className="p-3 sm:p-4 flex flex-col flex-grow">
                      <h3
                        className="text-base sm:text-lg font-semibold leading-tight mb-1 text-gray-900 dark:text-gray-100 line-clamp-2"
                        title={recipe.name}
                      >
                        {escapeHTML(recipe.name)}
                      </h3>
                      {recipe.description && (
                        <p
                          className="text-xs sm:text-sm text-gray-600 dark:text-gray-400 mt-1 mb-2 line-clamp-2"
                          title={recipe.description}
                        >
                          {escapeHTML(recipe.description)}
                        </p>
                      )}
                      <div className="flex flex-wrap gap-1 my-1 text-xs">
                        <span className="inline-flex items-center gap-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-2 py-0.5 rounded-full">
                          <i className="fas fa-utensils op-70"></i>{" "}
                          {escapeHTML(recipe.type)}
                        </span>
                        {recipe.cuisine && (
                          <span className="inline-flex items-center gap-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300 px-2 py-0.5 rounded-full">
                            <i className="fas fa-globe op-70"></i>{" "}
                            {escapeHTML(recipe.cuisine)}
                          </span>
                        )}
                        {recipe.dietaryTypes?.map((diet) => (
                          <span
                            key={diet}
                            className="inline-flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full"
                          >
                            <i className="fas fa-leaf opacity-70"></i>{" "}
                            {escapeHTML(diet)}
                          </span>
                        ))}
                        {recipe.tags?.map((tag) => (
                          <span
                            key={tag}
                            className="inline-flex items-center gap-1 bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded-full"
                          >
                            <i className="fas fa-tag opacity-70"></i>{" "}
                            {escapeHTML(tag)}
                          </span>
                        ))}
                      </div>
                      <div className="mt-auto pt-2 text-xs text-gray-500 dark:text-gray-400 grid grid-cols-2 gap-x-2 gap-y-1">
                        {recipe.prepTime > 0 && (
                          <span title="Prep Time">
                            <i className="fas fa-clock w-3 tc mr-0.5 op-70"></i>{" "}
                            Prep: {formatMinutesToHoursMinutes(recipe.prepTime)}
                          </span>
                        )}
                        {recipe.cookTime > 0 && (
                          <span title="Cook Time">
                            <i className="fas fa-fire w-3 tc mr-0.5 op-70"></i>{" "}
                            Cook: {formatMinutesToHoursMinutes(recipe.cookTime)}
                          </span>
                        )}
                        {recipe.additionalTime > 0 && (
                          <span title="Additional Time">
                            <i className="fas fa-hourglass-half w-3 tc mr-0.5 op-70"></i>{" "}
                            Additional:{" "}
                            {formatMinutesToHoursMinutes(recipe.additionalTime)}
                          </span>
                        )}
                        <span
                          className="col-span-2 text-green-600 dark:text-green-400 font-medium text-sm mt-1 inline-flex items-center gap-1"
                          title="Total Time"
                        >
                          <i className="fas fa-stopwatch"></i> Total:{" "}
                          {formatMinutesToHoursMinutes(
                            parseInt(recipe.prepTime || 0) +
                              parseInt(recipe.cookTime || 0) +
                              parseInt(recipe.additionalTime || 0)
                          )}
                        </span>
                      </div>
                    </div>
                  </div>
                ))
              ) : (
                <div className="col-span-full text-center text-gray-500 dark:text-gray-400 py-10 px-4 bg-white dark:bg-gray-800 rounded-lg shadow">
                  <i className="fas fa-search text-4xl mb-3 opacity-50"></i>
                  <p className="font-semibold">
                    {hideAllExplicitly
                      ? "Recipes are currently hidden."
                      : filters.query
                      ? "No recipes found matching your search."
                      : hasActiveFiltersExcludingQuery
                      ? "No recipes found matching your filters."
                      : "No recipes added yet."}
                  </p>
                  <p className="text-sm">
                    {hideAllExplicitly
                      ? "Click 'All' to show them."
                      : filters.query || hasActiveFiltersExcludingQuery
                      ? "Try adjusting filters or search terms."
                      : "Click 'Add' to create your first recipe!"}
                  </p>
                </div>
              )}{" "}
            </div>
          </section>
        );
      };

      const TagInput = ({ tags, setTags, maxTags = 10, addToast }) => {
        const [inputValue, setInputValue] = useState("");

        const handleKeyDown = (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const newTag = inputValue.trim();

            if (
              newTag &&
              tags.length < maxTags &&
              !tags.some((t) => t.toLowerCase() === newTag.toLowerCase())
            ) {
              setTags([...tags, newTag]);
            } else if (tags.length >= maxTags) {
              addToast(`Maximum ${maxTags} tags allowed.`, "error");
            } else if (
              newTag &&
              tags.some((t) => t.toLowerCase() === newTag.toLowerCase())
            ) {
              addToast(`Tag "${newTag}" already added.`, "info");
            }
            setInputValue("");
          } else if (e.key === "Backspace" && !inputValue && tags.length > 0) {
            removeTag(tags.length - 1);
          }
        };

        const removeTag = (indexToRemove) => {
          setTags(tags.filter((_, index) => index !== indexToRemove));
        };

        return (
          <div className="tag-input-container">
            {" "}
            {tags.map((tag, index) => (
              <span key={index} className="tag-item">
                {" "}
                {tag}
                <button
                  type="button"
                  className="tag-item-remove"
                  onClick={() => removeTag(index)}
                  aria-label={`Remove tag ${tag}`}
                >
                  &times;
                </button>
              </span>
            ))}
            <input
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="Add a tag"
              className="flex-grow border-none outline-none text-sm text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 bg-transparent"
              aria-label="Tag input"
            />
          </div>
        );
      };

      const AddRecipeModal = ({
        onClose,
        addRecipe,
        updateRecipe,
        editingRecipe,
        addToast,
      }) => {
        const initialFormState = useMemo(
          () => ({
            name: "",
            description: "",
            type: "",
            cuisine: "",
            dietaryTypes: "",
            prepHours: "",
            prepMinutes: "",
            cookHours: "",
            cookMinutes: "",
            additionalHours: "",
            additionalMinutes: "",
            calories: "",
            protein: "",
            carbs: "",
            fat: "",
            servings: "4",
            yield: "",
            ingredients: "",
            directions: "",
            tipsAndTricks: "",
            image: null,
            video: null,
          }),
          []
        );

        const [formData, setFormData] = useState(initialFormState);
        const [tags, setTags] = useState([]);
        const [tipsAndTricks, setTipsAndTricks] = useState([]);
        const [imagePreview, setImagePreview] = useState(null);
        const [videoPreview, setVideoPreview] = useState(null);
        const [formErrors, setFormErrors] = useState({});

        useEffect(() => {
          if (editingRecipe) {
            const getHours = (totalMins) => Math.floor(totalMins / 60);
            const getMinutes = (totalMins) => totalMins % 60;

            setFormData({
              name: editingRecipe.name || "",
              description: editingRecipe.description || "",
              type: editingRecipe.type || "",
              cuisine: editingRecipe.cuisine || "",
              dietaryTypes: Array.isArray(editingRecipe.dietaryTypes)
                ? editingRecipe.dietaryTypes.join(", ")
                : "",
              prepHours: getHours(editingRecipe.prepTime || 0),
              prepMinutes: getMinutes(editingRecipe.prepTime || 0),
              cookHours: getHours(editingRecipe.cookTime || 0),
              cookMinutes: getMinutes(editingRecipe.cookTime || 0),
              additionalHours: getHours(editingRecipe.additionalTime || 0),
              additionalMinutes: getMinutes(editingRecipe.additionalTime || 0),

              calories: editingRecipe.calories ?? "",
              protein: editingRecipe.protein ?? "",
              carbs: editingRecipe.carbs ?? "",
              fat: editingRecipe.fat ?? "",
              servings: editingRecipe.servings ?? "4",
              yield: editingRecipe.yield || "",
              ingredients: Array.isArray(editingRecipe.ingredients)
                ? editingRecipe.ingredients.join("\n")
                : "",
              directions: Array.isArray(editingRecipe.directions)
                ? editingRecipe.directions.join("\n")
                : "",
              tipsAndTricks: Array.isArray(editingRecipe.tipsAndTricks)
                ? editingRecipe.tipsAndTricks.join("\n")
                : "",
              image: editingRecipe.image || null,
              video: editingRecipe.video || null,
            });
            setTags(
              Array.isArray(editingRecipe.tags) ? editingRecipe.tags : []
            );
            setTipsAndTricks(
              Array.isArray(editingRecipe.tipsAndTricks)
                ? editingRecipe.tipsAndTricks
                : []
            );
            setImagePreview(editingRecipe.image || null);
            setVideoPreview(editingRecipe.video || null);
          } else {
            setFormData(initialFormState);
            setTags([]);
            setTipsAndTricks([]);
            setImagePreview(null);
            setVideoPreview(null);
          }
          setFormErrors({});
        }, [editingRecipe, initialFormState]);

        const handleChange = useCallback(
          (e) => {
            const { name, value } = e.target;
            setFormData((prev) => ({ ...prev, [name]: value }));
            if (formErrors[name])
              setFormErrors((prev) => ({ ...prev, [name]: null }));
          },
          [formErrors]
        );

        const handleFileChange = useCallback((e) => {
          const { name, files } = e.target;
          if (!files || files.length === 0) return;
          const file = files[0];

          const MAX_SIZE = 5 * 1024 * 1024;
          if (name === "image" && !file.type.startsWith("image/")) {
            setFormErrors((p) => ({ ...p, [name]: "File must be an image." }));
            return;
          }
          if (name === "video" && !file.type.startsWith("video/")) {
            setFormErrors((p) => ({ ...p, [name]: "File must be a video." }));
            return;
          }
          if (file.size > MAX_SIZE) {
            setFormErrors((p) => ({
              ...p,
              [name]: `File too large (Max ${MAX_SIZE / 1024 / 1024}MB).`,
            }));
            return;
          }

          const reader = new FileReader();
          reader.onload = (loadEvent) => {
            setFormData((prev) => ({
              ...prev,
              [name]: loadEvent.target.result,
            }));
            if (name === "image") setImagePreview(loadEvent.target.result);
            if (name === "video") setVideoPreview(loadEvent.target.result);
            setFormErrors((prev) => ({ ...prev, [name]: null }));
          };
          reader.onerror = () => {
            console.error("Error reading file:", reader.error);
            setFormErrors((prev) => ({
              ...p,
              [name]: "Error reading file.",
            }));
          };
          reader.readAsDataURL(file);
        }, []);

        const removeMedia = useCallback((mediaType) => {
          setFormData((prev) => ({ ...prev, [mediaType]: null }));
          if (mediaType === "image") setImagePreview(null);
          if (mediaType === "video") setVideoPreview(null);
          const fileInput = document.querySelector(`input[name=${mediaType}]`);
          if (fileInput) fileInput.value = "";
        }, []);

        const validateForm = useCallback(() => {
          const errors = {};
          if (!formData.name.trim()) errors.name = "Recipe name is required.";
          if (!formData.type.trim()) errors.type = "Recipe type is required.";
          if (!formData.ingredients.trim())
            errors.ingredients = "Ingredients are required.";
          if (!formData.directions.trim())
            errors.directions = "Directions are required.";
          const timeFields = ["prep", "cook", "additional"];
          timeFields.forEach((field) => {
            const hours = parseInt(formData[`${field}Hours`]) || 0;
            const minutes = parseInt(formData[`${field}Minutes`]) || 0;
            if (isNaN(hours) || hours < 0) {
              errors[`${field}Hours`] = `Invalid ${field} hours.`;
            }
            if (isNaN(minutes) || minutes < 0 || minutes >= 60) {
              errors[`${field}Minutes`] = `Invalid ${field} minutes (0-59).`;
            }
          });

          if (
            isNaN(parseInt(formData.servings)) ||
            parseInt(formData.servings) < 1
          )
            errors.servings = "Servings must be 1 or more.";
          if (formData.calories && isNaN(parseInt(formData.calories)))
            errors.calories = "Calories must be a number.";
          if (formData.protein && isNaN(parseFloat(formData.protein)))
            errors.protein = "Protein must be a number.";
          if (formData.carbs && isNaN(parseFloat(formData.carbs)))
            errors.carbs = "Carbs must be a number.";
          if (formData.fat && isNaN(parseFloat(formData.fat)))
            errors.fat = "Fat must be a number.";
          if (formData.yield && !formData.yield.trim()) {
            errors.yield = "Yield cannot be just empty spaces.";
          }

          setFormErrors(errors);
          return Object.keys(errors).length === 0;
        }, [formData]);

        const handleSubmit = useCallback(
          (e) => {
            e.preventDefault();
            if (!validateForm()) {
              addToast("Please fix errors before saving.", "error");
              return;
            }

            const calculateTotalMinutes = (hours, minutes) => {
              return (parseInt(hours) || 0) * 60 + (parseInt(minutes) || 0);
            };

            const recipeData = {
              name: formData.name.trim(),
              description: formData.description.trim(),
              type: formData.type.trim(),
              cuisine: formData.cuisine.trim(),
              dietaryTypes: formData.dietaryTypes
                .split(",")
                .map((t) => t.trim())
                .filter(Boolean),
              tags: tags,
              prepTime: calculateTotalMinutes(
                formData.prepHours,
                formData.prepMinutes
              ),
              cookTime: calculateTotalMinutes(
                formData.cookHours,
                formData.cookMinutes
              ),
              additionalTime: calculateTotalMinutes(
                formData.additionalHours,
                formData.additionalMinutes
              ),

              calories: formData.calories ? parseInt(formData.calories) : null,
              protein: formData.protein ? parseFloat(formData.protein) : null,
              carbs: formData.carbs ? parseFloat(formData.carbs) : null,
              fat: formData.fat ? parseFloat(formData.fat) : null,
              servings: parseInt(formData.servings) || 1,
              yield: formData.yield.trim(),
              ingredients: formData.ingredients
                .split("\n")
                .map((i) => i.trim())
                .filter(Boolean),
              directions: formData.directions
                .split("\n")
                .map((d) => d.trim())
                .filter(Boolean),
              tipsAndTricks: formData.tipsAndTricks
                .split("\n")
                .map((tip) => tip.trim())
                .filter(Boolean),
              image: formData.image,
              video: formData.video,
            };

            if (editingRecipe) {
              updateRecipe(editingRecipe.id, recipeData);
            } else {
              addRecipe(recipeData);
            }
          },
          [
            formData,
            tags,
            editingRecipe,
            validateForm,
            addRecipe,
            updateRecipe,
            addToast,
          ]
        );

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );
        const mealTypes = [
          "Appetizers",
          "Burgers",
          "Desserts",
          "Garnishes",
          "Hotdogs/Bratwurst/Etc",
          "Loins",
          "Meatloafs",
          "Pastas",
          "Ribs",
          "Roasts",
          "Salads",
          "Sandwiches",
          "Seafood",
          "Soups/Stews",
          "Spices/Seasoning/Marinades",
          "Steaks",
          "Wraps",
        ].sort();
        const cuisineTypes = [
          "American",
          "Asian",
          "Mexican",
          "Italian",
          "Indian",
          "Mediterranean",
          "French",
          "Japanese",
          "Chinese",
          "Thai",
          "Vietnamese",
          "Korean",
          "Middle Eastern",
          "African",
          "Caribbean",
          "South American",
          "German",
          "Spanish",
          "Greek",
          "British",
          "Australian",
          "Canadian",
          "Fusion",
          "Other",
        ].sort();
        const dietaryTypesList = [
          "Gluten-Free",
          "Dairy-Free",
          "Nut-Free",
          "Vegan",
          "Vegetarian",
          "Pescatarian",
          "Keto",
          "Paleo",
          "Low-Carb",
          "Low-Fat",
          "Sugar-Free",
          "Soy-Free",
        ];

        const ErrorMessage = ({ name }) =>
          formErrors[name] ? (
            <p className="text-red-500 text-xs mt-1">{formErrors[name]}</p>
          ) : null;

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-5 sm:p-6 w-full max-w-3xl max-h-[90vh] overflow-y-auto modal-scale-enter">
              <div className="flex justify-between items-center mb-5 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h2 className="text-xl sm:text-2xl font-semibold text-gray-900 dark:text-gray-100">
                  {editingRecipe ? "Edit Recipe" : "Add New Recipe"}
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>

              <form onSubmit={handleSubmit} className="space-y-4" noValidate>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="name"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Name *
                    </label>
                    <input
                      type="text"
                      id="name"
                      name="name"
                      value={formData.name}
                      onChange={handleChange}
                      required
                      className={`modal-input ${
                        formErrors.name
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <ErrorMessage name="name" />
                  </div>
                  <div>
                    <label
                      htmlFor="type"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Type *
                    </label>
                    <input
                      type="text"
                      id="type"
                      name="type"
                      value={formData.type}
                      onChange={handleChange}
                      list="meal-types"
                      required
                      className={`modal-input ${
                        formErrors.type
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <datalist id="meal-types">
                      {mealTypes.map((t) => (
                        <option key={t} value={t} />
                      ))}
                    </datalist>
                    <ErrorMessage name="type" />
                  </div>
                </div>

                <div>
                  <label
                    htmlFor="description"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Description <span className="text-xs">(optional)</span>
                  </label>
                  <textarea
                    id="description"
                    name="description"
                    value={formData.description}
                    onChange={handleChange}
                    rows="2"
                    className="modal-textarea border-gray-300 dark:border-gray-600"
                  ></textarea>
                  <ErrorMessage name="description" />
                </div>

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="servings"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Servings *
                    </label>
                    <input
                      type="number"
                      id="servings"
                      name="servings"
                      value={formData.servings}
                      onChange={handleChange}
                      min="1"
                      required
                      className={`modal-input ${
                        formErrors.servings
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <ErrorMessage name="servings" />
                  </div>
                  <div>
                    <label
                      htmlFor="yield"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Yield <span className="text-xs">(e.g., 1.5 cups)</span>
                    </label>
                    <input
                      type="text"
                      id="yield"
                      name="yield"
                      value={formData.yield}
                      onChange={handleChange}
                      className={`modal-input ${
                        formErrors.yield
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                      placeholder="e.g., 8 servings, 2 dozen, 1 gallon"
                    />
                    <ErrorMessage name="yield" />
                  </div>
                </div>

                <div>
                  <label
                    htmlFor="cuisine"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Cuisine <span className="text-xs">(optional)</span>
                  </label>
                  <input
                    type="text"
                    id="cuisine"
                    name="cuisine"
                    value={formData.cuisine}
                    onChange={handleChange}
                    list="cuisine-types"
                    className="modal-input border-gray-300 dark:border-gray-600"
                    placeholder="e.g., Italian, Mexican, American"
                  />
                  <datalist id="cuisine-types">
                    {cuisineTypes.map((c) => (
                      <option key={c} value={c} />
                    ))}
                  </datalist>
                </div>

                <div>
                  <label
                    htmlFor="dietaryTypes"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Dietary <span className="text-xs">(comma-sep)</span>
                  </label>
                  <input
                    type="text"
                    id="dietaryTypes"
                    name="dietaryTypes"
                    value={formData.dietaryTypes}
                    onChange={handleChange}
                    list="dietary-types"
                    className="modal-input border-gray-300 dark:border-gray-600"
                  />
                  <datalist id="dietary-types">
                    {dietaryTypesList.map((t) => (
                      <option key={t} value={t} />
                    ))}
                  </datalist>
                </div>

                <div>
                  <label
                    htmlFor="tags"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Tags <span className="text-xs">(press Enter/comma)</span>
                  </label>
                  <TagInput tags={tags} setTags={setTags} addToast={addToast} />
                  <ErrorMessage name="tags" />
                </div>

                <fieldset className="border border-gray-300 dark:border-gray-600 p-3 rounded">
                  <legend className="text-sm font-medium px-1 text-gray-700 dark:text-gray-300">
                    Time
                  </legend>
                  <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Prep Time *
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="prepHours"
                          value={formData.prepHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.prepHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="prepMinutes"
                          value={formData.prepMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.prepMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="prepHours" />
                      <ErrorMessage name="prepMinutes" />
                    </div>
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Cook Time *
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="cookHours"
                          value={formData.cookHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.cookHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="cookMinutes"
                          value={formData.cookMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.cookMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="cookHours" />
                      <ErrorMessage name="cookMinutes" />
                    </div>
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Additional Time
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="additionalHours"
                          value={formData.additionalHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.additionalHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="additionalMinutes"
                          value={formData.additionalMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.additionalMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="additionalHours" />
                      <ErrorMessage name="additionalMinutes" />
                    </div>
                  </div>
                </fieldset>

                <fieldset className="border border-gray-300 dark:border-gray-600 p-3 rounded">
                  <legend className="text-sm font-medium px-1 text-gray-700 dark:text-gray-300">
                    Nutrition (per serving, optional)
                  </legend>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                    <div>
                      <label
                        htmlFor="calories"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Calories
                      </label>
                      <input
                        type="number"
                        id="calories"
                        name="calories"
                        value={formData.calories}
                        onChange={handleChange}
                        min="0"
                        className={`modal-input-sm ${
                          formErrors.calories
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="calories" />
                    </div>
                    <div>
                      <label
                        htmlFor="protein"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Protein (g)
                      </label>
                      <input
                        type="number"
                        id="protein"
                        name="protein"
                        value={formData.protein}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.protein
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="protein" />
                    </div>
                    <div>
                      <label
                        htmlFor="carbs"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Carbs (g)
                      </label>
                      <input
                        type="number"
                        id="carbs"
                        name="carbs"
                        value={formData.carbs}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.carbs
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="carbs" />
                    </div>
                    <div>
                      <label
                        htmlFor="fat"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Fat (g)
                      </label>
                      <input
                        type="number"
                        id="fat"
                        name="fat"
                        value={formData.fat}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.fat
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="fat" />
                    </div>
                  </div>
                </fieldset>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="ingredients"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Ingredients *{" "}
                      <span className="text-xs">(one per line)</span>
                    </label>
                    <textarea
                      id="ingredients"
                      name="ingredients"
                      value={formData.ingredients}
                      onChange={handleChange}
                      rows="6"
                      required
                      className={`modal-textarea ${
                        formErrors.ingredients
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    ></textarea>
                    <ErrorMessage name="ingredients" />
                  </div>
                  <div>
                    <label
                      htmlFor="directions"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Directions *{" "}
                      <span className="text-xs">(one step per line)</span>
                    </label>
                    <textarea
                      id="directions"
                      name="directions"
                      value={formData.directions}
                      onChange={handleChange}
                      rows="6"
                      required
                      className={`modal-textarea ${
                        formErrors.directions
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    ></textarea>
                    <ErrorMessage name="directions" />
                  </div>
                </div>

                <div>
                  <label
                    htmlFor="tipsAndTricks"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Tips & Tricks{" "}
                    <span className="text-xs">(one tip per line)</span>
                  </label>
                  <textarea
                    id="tipsAndTricks"
                    name="tipsAndTricks"
                    value={formData.tipsAndTricks}
                    onChange={handleChange}
                    rows="4"
                    className="modal-textarea border-gray-300 dark:border-gray-600"
                    placeholder="e.g., If you don't have fresh basil, use 1 tsp dried basil. This recipe freezes well!"
                  ></textarea>
                </div>

                <div>
                  <label
                    htmlFor="image"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Image
                  </label>
                  <input
                    type="file"
                    id="image"
                    name="image"
                    accept="image/*"
                    onChange={handleFileChange}
                    className={`block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 dark:file:bg-gray-600 file:text-green-700 dark:file:text-gray-200 hover:file:bg-green-100 dark:hover:file:bg-gray-500 cursor-pointer ${
                      formErrors.image ? "border border-red-500 rounded-md" : ""
                    }`}
                  />
                  <ErrorMessage name="image" />
                  {imagePreview && (
                    <div className="mt-2 relative group w-32 h-32 border border-gray-300 dark:border-gray-600 rounded overflow-hidden">
                      <img
                        src={imagePreview}
                        alt="Preview"
                        className="w-full h-full object-cover"
                      />
                      <button
                        type="button"
                        onClick={() => removeMedia("image")}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                        aria-label="Remove image"
                      >
                        &times;
                      </button>
                    </div>
                  )}
                </div>

                <div>
                  <label
                    htmlFor="video"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Video
                  </label>
                  <input
                    type="file"
                    id="video"
                    name="video"
                    accept="video/*"
                    onChange={handleFileChange}
                    className={`block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-600 file:text-blue-700 dark:file:text-gray-200 hover:file:bg-blue-100 dark:hover:file:bg-gray-500 cursor-pointer ${
                      formErrors.video ? "border border-red-500 rounded-md" : ""
                    }`}
                  />
                  <ErrorMessage name="video" />
                  {videoPreview && (
                    <div className="mt-2 relative group max-w-xs border border-gray-300 dark:border-gray-600 rounded overflow-hidden">
                      <video
                        controls
                        className="w-full rounded max-h-40 block bg-black"
                      >
                        <source src={videoPreview} /> No video support.
                      </video>
                      <button
                        type="button"
                        onClick={() => removeMedia("video")}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                        aria-label="Remove video"
                      >
                        &times;
                      </button>
                    </div>
                  )}
                </div>

                <div className="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-600 mt-5">
                  <button
                    type="button"
                    onClick={onClose}
                    className="btn-modal btn-gray"
                  >
                    Cancel
                  </button>
                  <button type="submit" className="btn-modal btn-green">
                    {editingRecipe ? "Save Changes" : "Add Recipe"}
                  </button>
                </div>
              </form>
            </div>
          </div>
        );
      };

      const AddToMealPlanSelectorModal = ({
        recipe,
        mealPlan,
        updateMealPlan,
        onClose,
        addToast,
        recipes,
      }) => {
        const days = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];
        const mealTimes = [
          { id: "breakfast", label: "Breakfast", icon: "fa-coffee" },
          { id: "morningSnack", label: "M. Snack", icon: "fa-apple-alt" },
          { id: "lunch", label: "Lunch", icon: "fa-utensils" },
          { id: "afternoonSnack", label: "A. Snack", icon: "fa-cookie-bite" },
          { id: "dinner", label: "Dinner", icon: "fa-drumstick-bite" },
        ];

        const [selectedDay, setSelectedDay] = useState(days[0]);
        const [selectedMealTime, setSelectedMealTime] = useState(
          mealTimes[0].id
        );

        const currentRecipesInSlot = useMemo(() => {
          return mealPlan?.[selectedDay]?.[selectedMealTime] || [];
        }, [mealPlan, selectedDay, selectedMealTime]);

        const handleAdd = useCallback(() => {
          if (recipe && selectedDay && selectedMealTime) {
            if (currentRecipesInSlot.includes(recipe.id)) {
              addToast("Recipe is already in this slot.", "info");
            } else {
              updateMealPlan(selectedDay, selectedMealTime, recipe.id);
            }
            onClose();
          } else {
            addToast("Please select a day and meal time.", "error");
          }
        }, [
          recipe,
          selectedDay,
          selectedMealTime,
          updateMealPlan,
          onClose,
          addToast,
          currentRecipesInSlot,
        ]);

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[60] p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-5 w-full max-w-sm modal-scale-enter">
              <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h3 className="text-lg sm:text-xl font-semibold text-gray-900 dark:text-gray-100">
                  Add "{escapeHTML(recipe.name)}" to Meal Plan
                </h3>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-2xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>

              <div className="space-y-4">
                <div>
                  <label
                    htmlFor="selectDay"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Select Day:
                  </label>
                  <select
                    id="selectDay"
                    value={selectedDay}
                    onChange={(e) => setSelectedDay(e.target.value)}
                    className="modal-input-sm"
                  >
                    {days.map((day) => (
                      <option key={day} value={day}>
                        {day}
                      </option>
                    ))}
                  </select>
                </div>

                <div>
                  <label
                    htmlFor="selectMealTime"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Select Meal Time:
                  </label>
                  <select
                    id="selectMealTime"
                    value={selectedMealTime}
                    onChange={(e) => setSelectedMealTime(e.target.value)}
                    className="modal-input-sm"
                  >
                    {mealTimes.map((time) => (
                      <option key={time.id} value={time.id}>
                        {time.label}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="text-sm text-gray-600 dark:text-gray-400">
                  Current assignment for {selectedDay}{" "}
                  {mealTimes.find((mt) => mt.id === selectedMealTime)?.label}:{" "}
                  <div className="font-semibold mt-1">
                    {currentRecipesInSlot.length > 0
                      ? currentRecipesInSlot.map((id, index) => {
                          const assignedRecipe = recipes.find(
                            (r) => r.id === id
                          );
                          return (
                            <span key={id} className="block">
                              {assignedRecipe?.name || "Unknown Recipe"}
                              {index < currentRecipesInSlot.length - 1 && ", "}
                            </span>
                          );
                        })
                      : "None"}
                  </div>
                </div>

                <div className="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-600">
                  <button
                    type="button"
                    onClick={onClose}
                    className="btn-modal btn-gray"
                  >
                    Cancel
                  </button>
                  <button
                    type="button"
                    onClick={handleAdd}
                    className="btn-modal btn-green"
                  >
                    Add to Plan
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      const RecipeDetailsModal = ({
        recipe,
        onClose,
        addToShoppingList,
        generateRecipePDF,
        deleteRecipe,
        editRecipe,
        toggleFavorite,
        addToast,
        updateMealPlan,
        mealPlan,
        recipes,
      }) => {
        const baseServings = recipe?.servings > 0 ? recipe.servings : 1;
        const [currentServings, setCurrentServings] = useState(baseServings);
        const servingsMultiplier = currentServings / baseServings;
        const [showAddToMealPlanSelector, setShowAddToMealPlanSelector] =
          useState(false);

        const handleServingsChange = useCallback((value) => {
          setCurrentServings(Math.max(1, parseInt(value) || 1));
        }, []);

        const totalTime = useMemo(
          () =>
            parseInt(recipe?.prepTime || 0) +
            parseInt(recipe?.cookTime || 0) +
            parseInt(recipe?.additionalTime || 0),
          [recipe]
        );

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        const scaledYield = useMemo(() => {
          if (recipe.yield) {
            return formatScaledYield(recipe.yield, servingsMultiplier);
          }
          return null;
        }, [recipe.yield, servingsMultiplier]);

        const getShareableText = useCallback(() => {
          let text = `Check out this recipe: ${recipe.name}\n\n`;
          if (recipe.description) {
            text += `${recipe.description}\n\n`;
          }
          text += `Servings: ${recipe.servings}\n`;
          text += `Total Time: ${formatMinutesToHoursMinutes(totalTime)}\n\n`;

          if (recipe.ingredients && recipe.ingredients.length > 0) {
            text += "Ingredients:\n";
            recipe.ingredients.forEach((ing) => {
              const { quantity, unit, description } = parseIngredient(ing);
              const scaledQuantity = quantity
                ? quantity * servingsMultiplier
                : null;
              text += `- ${
                scaledQuantity !== null
                  ? formatQuantity(scaledQuantity) + " "
                  : ""
              }${unit ? unit + " " : ""}${description}\n`;
            });
            text += "\n";
          }

          if (recipe.directions && recipe.directions.length > 0) {
            text += "Directions:\n";
            recipe.directions.forEach((dir, index) => {
              text += `${index + 1}. ${dir}\n`;
            });
            text += "\n";
          }

          if (recipe.tipsAndTricks && recipe.tipsAndTricks.length > 0) {
            text += "Tips & Tricks:\n";
            recipe.tipsAndTricks.forEach((tip) => {
              text += `- ${tip}\n`;
            });
            text += "\n";
          }

          text += "Find more recipes with Recipe Manager Pro!";
          return text;
        }, [recipe, totalTime, servingsMultiplier]);

        const handleShareRecipe = useCallback(async () => {
          const shareData = {
            title: `Recipe: ${recipe.name}`,
            text: getShareableText(),
          };

          if (navigator.share) {
            try {
              await navigator.share(shareData);
              addToast("Recipe shared successfully!", "success");
            } catch (err) {
              if (err.name === "AbortError") {
                addToast("Sharing cancelled.", "info");
              } else {
                console.error("Error sharing recipe:", err);
                addToast("Failed to share recipe.", "error");
              }
            }
          } else {
            try {
              const textToCopy = shareData.text;
              const textarea = document.createElement("textarea");
              textarea.value = textToCopy;
              textarea.style.position = "absolute";
              textarea.style.left = "-9999px";
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand("copy");
              document.body.removeChild(textarea);
              addToast("Recipe details copied to clipboard!", "info");
            } catch (err) {
              console.error("Failed to copy recipe to clipboard:", err);
              addToast("Failed to copy recipe details.", "error");
            }
          }
        }, [recipe, getShareableText, addToast]);

        const handleExportSingleRecipe = useCallback(async () => {
          try {
            const dataStr = JSON.stringify(recipe, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${recipe.name
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, "-")}-recipe.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            addToast("Recipe exported successfully!", "success");
          } catch (err) {
            console.error("Export single recipe error:", err);
            addToast("Error exporting recipe.", "error");
          }
        }, [recipe, addToast]);

        if (!recipe) return null;

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-5 sm:p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto modal-scale-enter">
              <div className="flex justify-between items-start mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 gap-4">
                <div className="flex-1">
                  <h2 className="text-2xl md:text-3xl font-bold mb-1 text-gray-900 dark:text-gray-100">
                    {escapeHTML(recipe.name)}
                  </h2>
                  {recipe.description && (
                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-3 italic">
                      {escapeHTML(recipe.description)}
                    </p>
                  )}
                  <div className="flex flex-wrap gap-x-2 gap-y-1 items-center text-xs sm:text-sm">
                    <span className="inline-flex items-center gap-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-2 py-0.5 rounded-full">
                      <i className="fas fa-utensils op-70"></i>{" "}
                      {escapeHTML(recipe.type)}
                    </span>
                    {recipe.cuisine && (
                      <span className="inline-flex items-center gap-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300 px-2 py-0.5 rounded-full">
                        <i className="fas fa-globe op-70"></i>{" "}
                        {escapeHTML(recipe.cuisine)}
                      </span>
                    )}
                    {recipe.dietaryTypes?.map((t) => (
                      <span
                        key={t}
                        className="inline-flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full"
                      >
                        <i className="fas fa-leaf op-70"></i> {escapeHTML(t)}
                      </span>
                    ))}
                    {recipe.tags?.map((tag) => (
                      <span
                        key={tag}
                        className="inline-flex items-center gap-1 bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded-full"
                      >
                        <i className="fas fa-tag opacity-70"></i>{" "}
                        {escapeHTML(tag)}
                      </span>
                    ))}
                  </div>
                </div>
                <div className="flex items-center gap-2 flex-shrink-0">
                  <button
                    onClick={() => toggleFavorite(recipe.id)}
                    className={`text-2xl p-1 rounded-full ${
                      recipe.isFavorite
                        ? "text-yellow-400 hover:text-yellow-500"
                        : "text-gray-400 hover:text-gray-500 dark:text-gray-500 dark:hover:text-gray-400"
                    }`}
                    title={
                      recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                    }
                    aria-label={
                      recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                    }
                  >
                    <i
                      className={`fa-star ${recipe.isFavorite ? "fas" : "far"}`}
                    ></i>
                  </button>
                  <button
                    onClick={onClose}
                    className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                    aria-label="Close"
                  >
                    &times;
                  </button>
                </div>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div className="md:col-span-1 space-y-4">
                  {recipe.image && (
                    <img
                      src={recipe.image}
                      alt={recipe.name}
                      className="w-full aspect-video object-cover rounded-lg shadow-md border border-gray-200 dark:border-gray-700"
                    />
                  )}
                  {recipe.video && (
                    <div>
                      <h3 className="text-base font-semibold mb-1 text-gray-800 dark:text-gray-200">
                        Video
                      </h3>
                      <video
                        controls
                        className="w-full rounded-lg shadow-md max-h-48 border border-gray-200 dark:border-gray-700 block bg-black"
                      >
                        <source src={recipe.video} /> No video support.
                      </video>
                    </div>
                  )}
                  <div className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md shadow-sm">
                    <label
                      htmlFor="servingsAdj"
                      className="font-medium text-sm mb-1.5 block text-gray-700 dark:text-gray-300"
                    >
                      Servings:
                    </label>
                    <div className="flex items-center justify-between gap-2">
                      <span className="text-xs text-gray-600 dark:text-gray-400">
                        Base: {baseServings}
                      </span>
                      <div className="flex items-center gap-1">
                        <button
                          onClick={() =>
                            handleServingsChange(currentServings - 1)
                          }
                          className="adjust-btn"
                          disabled={currentServings <= 1}
                          aria-label="Decrease servings"
                        >
                          -
                        </button>
                        <input
                          type="number"
                          id="servingsAdj"
                          value={currentServings}
                          onChange={(e) => handleServingsChange(e.target.value)}
                          min="1"
                          className="w-12 tc p-1 rounded border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-600 text-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-gray-900 dark:text-gray-100"
                          aria-label="Current servings"
                        />
                        <button
                          onClick={() =>
                            handleServingsChange(currentServings + 1)
                          }
                          className="adjust-btn"
                          aria-label="Increase servings"
                        >
                          +
                        </button>
                      </div>
                    </div>
                    {recipe.yield && (
                      <div className="mt-2 text-sm text-gray-700 dark:text-gray-300 flex justify-between items-center border-t border-gray-200 dark:border-gray-600 pt-2">
                        <span className="font-medium">Yield:</span>
                        <span>{scaledYield}</span>
                      </div>
                    )}
                  </div>
                  <div className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md shadow-sm space-y-1.5 text-sm text-gray-700 dark:text-gray-300">
                    <h4 className="font-semibold border-b border-gray-200 dark:border-gray-600 pb-1 mb-1.5 text-gray-800 dark:text-gray-200">
                      Quick Info{" "}
                      <span className="text-xs font-normal text-gray-500">
                        (per serving)
                      </span>
                    </h4>
                    <div className="flex justify-between">
                      <span>Prep:</span>{" "}
                      <span className="font-medium">
                        {formatMinutesToHoursMinutes(recipe.prepTime)}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Cook:</span>{" "}
                      <span className="font-medium">
                        {formatMinutesToHoursMinutes(recipe.cookTime)}
                      </span>
                    </div>
                    {recipe.additionalTime > 0 && (
                      <div className="flex justify-between">
                        <span>Additional:</span>{" "}
                        <span className="font-medium">
                          {formatMinutesToHoursMinutes(recipe.additionalTime)}
                        </span>
                      </div>
                    )}
                    <div className="flex justify-between font-semibold pt-1 border-t border-gray-200 dark:border-gray-600 mt-1">
                      <span>Total:</span>{" "}
                      <span>{formatMinutesToHoursMinutes(totalTime)}</span>
                    </div>
                    <div className="flex justify-between pt-1 border-t border-gray-200 dark:border-gray-600 mt-1">
                      <span>Calories:</span>{" "}
                      <span className="font-medium">
                        {recipe.calories || "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Protein:</span>{" "}
                      <span className="font-medium">
                        {recipe.protein ? `${recipe.protein}g` : "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Carbs:</span>
                      <span className="font-medium">
                        {recipe.carbs ? `${recipe.carbs}g` : "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Fat:</span>
                      <span className="font-medium">
                        {recipe.fat ? `${recipe.fat}g` : "N/A"}
                      </span>
                    </div>
                  </div>
                </div>

                <div className="md:col-span-2">
                  <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                      <i className="fas fa-list text-green-500"></i>Ingredients{" "}
                      <span className="text-base font-normal text-gray-500">
                        ({currentServings} servings)
                      </span>
                    </h3>
                    <ul className="list-none space-y-1 text-sm border border-gray-200 dark:border-gray-700 rounded-md p-3 bg-gray-50 dark:bg-gray-900 shadow-inner text-gray-800 dark:text-gray-200">
                      {recipe.ingredients?.map((ing, index) => {
                        const { quantity, unit, description } =
                          parseIngredient(ing);
                        const scaledQuantity = quantity
                          ? quantity * servingsMultiplier
                          : null;
                        return (
                          <li
                            key={index}
                            className="flex items-baseline gap-2 py-1 border-b border-gray-200 dark:border-gray-700 last:border-b-0"
                          >
                            <i className="fas fa-check text-green-500 op-70 text-xs pt-1"></i>
                            <span>
                              {scaledQuantity !== null && (
                                <strong className="mr-1 font-medium">
                                  {formatQuantity(scaledQuantity)} {unit || ""}
                                </strong>
                              )}
                              {escapeHTML(description)}
                            </span>
                          </li>
                        );
                      }) || (
                        <li className="text-gray-500 italic">
                          No ingredients.
                        </li>
                      )}
                    </ul>
                  </div>
                  <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                      <i className="fas fa-shoe-prints text-green-500 -rotate-90 transform"></i>
                      Directions
                    </h3>
                    <ol className="list-none space-y-3">
                      {recipe.directions?.map((dir, index) => (
                        <li
                          key={index}
                          className="flex items-start gap-3 p-3 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm text-gray-800 dark:text-gray-200"
                        >
                          <span className="bg-green-500 text-white w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold mt-0.5 flex-shrink-0 shadow">
                            {index + 1}
                          </span>
                          <p className="text-sm flex-1">{escapeHTML(dir)}</p>
                        </li>
                      )) || (
                        <li className="text-gray-500 italic p-3 bg-gray-50 dark:bg-gray-700 rounded-md">
                          No directions.
                        </li>
                      )}
                    </ol>
                  </div>
                  {recipe.tipsAndTricks && recipe.tipsAndTricks.length > 0 && (
                    <div className="mt-6">
                      <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                        <i className="fas fa-lightbulb text-yellow-500"></i>Tips
                        & Tricks
                      </h3>
                      <ul className="list-none space-y-2 p-3 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm text-gray-800 dark:text-gray-200">
                        {recipe.tipsAndTricks.map((tip, index) => (
                          <li key={index} className="text-sm">
                            <i className="fas fa-caret-right text-yellow-500 mr-2"></i>
                            {escapeHTML(tip)}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>

              <div className="flex flex-wrap gap-3 mt-6 pt-4 border-t border-gray-200 dark:border-gray-600">
                <button
                  onClick={() => generateRecipePDF(recipe)}
                  className="btn-modal bg-pink-500 hover:bg-pink-600 text-white"
                >
                  <i className="fas fa-file-pdf mr-1.5"></i>PDF
                </button>
                <button
                  onClick={() => addToShoppingList(recipe.id)}
                  className="btn-modal btn-gray"
                >
                  <i className="fas fa-cart-plus mr-1.5"></i>Add to List
                </button>
                <button
                  onClick={() => setShowAddToMealPlanSelector(true)}
                  className="btn-modal bg-indigo-500 hover:bg-indigo-600 text-white"
                >
                  <i className="fas fa-calendar-plus mr-1.5"></i>Add to Plan
                </button>
                <button
                  onClick={handleShareRecipe}
                  className="btn-modal bg-purple-700 hover:bg-purple-800 text-white"
                >
                  <i className="fas fa-share-alt mr-1.5"></i>Share
                </button>
                <button
                  onClick={handleExportSingleRecipe}
                  className="btn-modal bg-green-500 hover:bg-green-600 text-white"
                  title="Export this recipe"
                >
                  <i className="fas fa-file-export mr-1.5"></i>Export
                </button>
                <button
                  onClick={() => editRecipe(recipe)}
                  className="btn-modal btn-blue"
                >
                  <i className="fas fa-edit mr-1.5"></i>Edit
                </button>
                <button
                  onClick={() => deleteRecipe(recipe.id)}
                  className="btn-modal btn-red ml-auto"
                >
                  <i className="fas fa-trash mr-1.5"></i>Delete
                </button>
              </div>
            </div>
            {showAddToMealPlanSelector && (
              <AddToMealPlanSelectorModal
                recipe={recipe}
                mealPlan={mealPlan}
                updateMealPlan={updateMealPlan}
                onClose={() => setShowAddToMealPlanSelector(false)}
                addToast={addToast}
                recipes={recipes}
              />
            )}
          </div>
        );
      };

      const MealPlanModal = ({
        mealPlan,
        recipes,
        updateMealPlan,
        removeMealFromPlan,
        addMultipleRecipesToShoppingList,
        onClose,
      }) => {
        const days = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];
        const mealTimes = [
          { id: "breakfast", label: "Breakfast", icon: "fa-coffee" },
          { id: "morningSnack", label: "M. Snack", icon: "fa-apple-alt" },
          { id: "lunch", label: "Lunch", icon: "fa-utensils" },
          { id: "afternoonSnack", label: "A. Snack", icon: "fa-cookie-bite" },
          { id: "dinner", label: "Dinner", icon: "fa-drumstick-bite" },
        ];

        const [showRecipeSelector, setShowRecipeSelector] = useState(null);
        const [selectorSearch, setSelectorSearch] = useState("");

        const filteredRecipesForSelector = useMemo(() => {
          const query = selectorSearch.toLowerCase().trim();
          if (!query)
            return recipes.sort((a, b) => a.name.localeCompare(b.name));
          return recipes
            .filter(
              (r) =>
                r?.name?.toLowerCase().includes(query) ||
                r?.type?.toLowerCase().includes(query) ||
                r?.cuisine?.toLowerCase().includes(query)
            )
            .sort((a, b) => a.name.localeCompare(b.name));
        }, [recipes, selectorSearch]);

        const handleSelectRecipeClick = useCallback((day, mealTimeId) => {
          setShowRecipeSelector({ day, mealTime: mealTimeId });
          setSelectorSearch("");
        }, []);

        const handleRecipeSelect = useCallback(
          (recipeId) => {
            if (showRecipeSelector) {
              updateMealPlan(
                showRecipeSelector.day,
                showRecipeSelector.mealTime,
                recipeId
              );
            }
            setShowRecipeSelector(null);
          },
          [showRecipeSelector, updateMealPlan]
        );

        const handleRemoveMeal = useCallback(
          (e, day, mealTimeId, recipeIdToRemove) => {
            e.stopPropagation();
            removeMealFromPlan(day, mealTimeId, recipeIdToRemove);
          },
          [removeMealFromPlan]
        );

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        const handleSelectorOverlayClick = useCallback((e) => {
          if (e.target === e.currentTarget) setShowRecipeSelector(null);
        }, []);

        const getRecipeIdsForDays = useCallback(
          (daysToGet) => {
            const recipeIds = new Set();
            daysToGet.forEach((day) => {
              if (mealPlan && mealPlan[day]) {
                Object.values(mealPlan[day]).forEach((recipeIdsInSlot) => {
                  if (Array.isArray(recipeIdsInSlot)) {
                    recipeIdsInSlot.forEach((recipeId) => {
                      if (recipeId) {
                        recipeIds.add(recipeId);
                      }
                    });
                  }
                });
              }
            });
            return Array.from(recipeIds);
          },
          [mealPlan]
        );

        const handleAddDayToList = useCallback(
          (day) => {
            const recipeIds = getRecipeIdsForDays([day]);
            if (recipeIds.length > 0) {
              addMultipleRecipesToShoppingList(recipeIds);
            }
          },
          [getRecipeIdsForDays, addMultipleRecipesToShoppingList]
        );

        const handleAddWeekToList = useCallback(() => {
          const recipeIds = getRecipeIdsForDays(days);
          if (recipeIds.length > 0) {
            addMultipleRecipesToShoppingList(recipeIds);
          }
        }, [getRecipeIdsForDays, addMultipleRecipesToShoppingList, days]);

        return (
          <>
            <div
              className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-2 sm:p-4"
              onClick={handleOverlayClick}
            >
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-7xl h-[90vh] flex flex-col modal-scale-enter">
                <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 flex-shrink-0 gap-4">
                  <h2 className="text-xl sm:text-2xl font-bold flex items-center gap-2 text-gray-900 dark:text-gray-100">
                    <i className="fas fa-calendar-alt text-green-500"></i>Weekly
                    Meal Plan
                  </h2>
                  <button
                    onClick={handleAddWeekToList}
                    className="btn-modal btn-green text-xs sm:text-sm ml-auto mr-2"
                    title="Add all ingredients for the week to the shopping list"
                  >
                    <i className="fas fa-cart-plus mr-1"></i> Add Week to List
                  </button>
                  <button
                    onClick={onClose}
                    className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                    aria-label="Close"
                  >
                    &times;
                  </button>
                </div>

                <div className="flex-1 overflow-y-auto pb-4 pr-2">
                  <div className="grid grid-cols-1 md:grid-cols-7 gap-3 md:gap-4">
                    {days.map((day) => (
                      <div
                        key={day}
                        className="bg-gray-50 dark:bg-gray-900 p-2 rounded-lg flex flex-col gap-2 shadow-inner"
                      >
                        <div className="flex justify-between items-center mb-1">
                          <h3 className="text-center text-sm font-semibold py-1 flex-grow text-gray-800 dark:text-gray-200">
                            {day}
                          </h3>
                          <button
                            onClick={() => handleAddDayToList(day)}
                            className="text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 text-xs p-1"
                            title={`Add ${day}'s ingredients to shopping list`}
                          >
                            <i className="fas fa-cart-plus"></i>
                          </button>
                        </div>
                        <div className="flex flex-col gap-2">
                          {mealTimes.map(({ id, label, icon }) => {
                            const recipeIdsInSlot = mealPlan?.[day]?.[id] || [];
                            return (
                              <div
                                key={id}
                                onClick={() => handleSelectRecipeClick(day, id)}
                                className="bg-white dark:bg-gray-700 rounded-md p-1.5 sm:p-2 shadow-sm flex flex-col min-h-[65px] border border-transparent hover:border-green-400 transition-colors cursor-pointer group relative"
                              >
                                <div className="flex justify-between items-center mb-1 text-xs text-gray-500 dark:text-gray-400">
                                  <span className="flex items-center gap-1 font-medium">
                                    <i
                                      className={`fas ${icon} w-3 tc op-80`}
                                    ></i>{" "}
                                    {label}
                                  </span>
                                </div>
                                <div className="flex-grow flex flex-col items-center justify-center text-center">
                                  {recipeIdsInSlot.length > 0 ? (
                                    recipeIdsInSlot.map((recipeId) => {
                                      const recipe = recipes.find(
                                        (r) => r?.id === recipeId
                                      );
                                      return (
                                        <div
                                          key={recipeId}
                                          className="relative w-full"
                                        >
                                          <p
                                            className="text-xs sm:text-sm text-green-600 dark:text-green-400 font-medium leading-tight group-hover:underline line-clamp-3"
                                            title={
                                              recipe?.name || "Unknown Recipe"
                                            }
                                          >
                                            {escapeHTML(
                                              recipe?.name || "Unknown Recipe"
                                            )}
                                          </p>
                                          <button
                                            onClick={(e) =>
                                              handleRemoveMeal(
                                                e,
                                                day,
                                                id,
                                                recipeId
                                              )
                                            }
                                            className="text-red-400 hover:text-red-600 text-xs absolute top-0 right-0 bg-white dark:bg-gray-700 rounded-full w-4 h-4 flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                                            title="Remove"
                                            aria-label="Remove"
                                          >
                                            <i className="fas fa-times"></i>
                                          </button>
                                        </div>
                                      );
                                    })
                                  ) : (
                                    <p className="text-[10px] sm:text-xs text-gray-400 dark:text-gray-500 italic group-hover:text-gray-600 dark:group-hover:text-gray-300">
                                      + Add Recipe
                                    </p>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            {showRecipeSelector && (
              <div
                className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[60] p-4"
                onClick={handleSelectorOverlayClick}
              >
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-5 w-full max-w-md max-h-[70vh] flex flex-col modal-scale-enter">
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="text-base sm:text-lg font-semibold text-gray-900 dark:text-gray-100">
                      Select for{" "}
                      <span className="text-green-500">
                        {showRecipeSelector?.day}{" "}
                        {
                          mealTimes.find(
                            (mt) => mt.id === showRecipeSelector?.mealTime
                          )?.label
                        }
                      </span>
                    </h3>
                    <button
                      onClick={() => setShowRecipeSelector(null)}
                      className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-2xl leading-none"
                      aria-label="Close"
                    >
                      &times;
                    </button>
                  </div>
                  <div className="relative mb-3">
                    <input
                      type="search"
                      placeholder="Search recipes..."
                      value={selectorSearch}
                      onChange={(e) => setSelectorSearch(e.target.value)}
                      className="w-full p-2 pl-8 rounded border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-green-500 text-sm text-gray-900 dark:text-gray-100"
                      aria-label="Search recipes"
                    />
                    <i className="fas fa-search absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 text-xs"></i>
                  </div>
                  <div className="flex-1 overflow-y-auto space-y-1.5 pr-1">
                    {filteredRecipesForSelector.length > 0 ? (
                      filteredRecipesForSelector.map((recipe) => (
                        <div
                          key={recipe.id}
                          onClick={() => handleRecipeSelect(recipe.id)}
                          role="button"
                          className="bg-gray-50 dark:bg-gray-700 rounded p-2 cursor-pointer hover:bg-green-100 dark:hover:bg-green-900 hover:shadow-sm transition-all duration-150 flex items-center gap-2 border border-transparent hover:border-green-200 dark:hover:border-green-700"
                        >
                          {recipe.image ? (
                            <img
                              src={recipe.image}
                              alt=""
                              className="w-10 h-10 rounded object-cover flex-shrink-0 border border-gray-200 dark:border-gray-600"
                            />
                          ) : (
                            <div className="w-10 h-10 rounded bg-gray-200 dark:bg-gray-600 flex items-center justify-center text-gray-400 text-sm flex-shrink-0 border border-gray-300 dark:border-gray-600">
                              <i className="fas fa-image"></i>
                            </div>
                          )}
                          <div className="flex-grow overflow-hidden">
                            <h4
                              className="text-sm font-medium leading-tight truncate text-gray-800 dark:text-gray-200"
                              title={recipe.name}
                            >
                              {escapeHTML(recipe.name)}
                            </h4>
                            <p className="text-xs text-gray-500 dark:text-gray-400">
                              {escapeHTML(recipe.type)}
                            </p>
                          </div>
                        </div>
                      ))
                    ) : (
                      <div className="text-center text-gray-500 dark:text-gray-400 text-sm py-6">
                        <i className="fas fa-ghost text-2xl mb-2 op-50"></i>
                        <p>No recipes found.</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </>
        );
      };

      const ShoppingListModal = ({
        shoppingList,
        toggleShoppingItem,
        clearShoppingList,
        addToast,
        onClose,
        displayUnitSystem,
        setDisplayUnitSystem,
        convertUnits,
      }) => {
        const [showChecked, setShowChecked] = useState(true);

        const groupedByRecipe = useMemo(() => {
          const groups = {};
          if (!Array.isArray(shoppingList)) return groups;

          shoppingList.forEach((item) => {
            if (!item || typeof item !== "object") return;
            const recipeName = item.recipeName || "Manually Added";

            const normalized =
              item.normalizedText || normalizeIngredient(item.originalText);
            if (!normalized) return;

            if (!groups[recipeName]) {
              groups[recipeName] = {
                id: item.recipeId || "manual",
                name: recipeName,
                items: [],
              };
            }
            groups[recipeName].items.push({
              ...item,
              normalizedText: normalized,
            });
          });

          Object.values(groups).forEach((group) => {
            group.items.sort((a, b) =>
              a.originalText.localeCompare(b.originalText)
            );
          });

          return groups;
        }, [shoppingList]);

        const commonIngredientsData = useMemo(() => {
          const normalizedDetails = {};

          shoppingList.forEach((item) => {
            const norm = item.normalizedText;
            if (!norm) return;

            if (!normalizedDetails[norm]) {
              normalizedDetails[norm] = {
                display_name: capitalizeFirstLetter(norm),
                checked: item.checked,
                recipeSources: new Set(),
                instanceCount: 0,
                uncheckedCount: 0,
                quantity: 0,
                unit: item.unit,
                originalItems: [],
              };
            }

            if (
              item.quantity !== null &&
              item.unit === normalizedDetails[norm].unit
            ) {
              normalizedDetails[norm].quantity += item.quantity;
            } else if (
              item.quantity !== null &&
              !normalizedDetails[norm].unit
            ) {
              normalizedDetails[norm].unit = item.unit;
              normalizedDetails[norm].quantity += item.quantity;
            }
            normalizedDetails[norm].originalItems.push(item);

            normalizedDetails[norm].recipeSources.add(
              item.recipeName || "Manually Added"
            );
            normalizedDetails[norm].instanceCount++;
            if (!item.checked) normalizedDetails[norm].uncheckedCount++;
            if (!item.checked) {
              normalizedDetails[norm].checked = false;
            } else if (normalizedDetails[norm].uncheckedCount === 0) {
              normalizedDetails[norm].checked = true;
            }
          });

          const commonList = Object.entries(normalizedDetails)
            .filter(([norm, details]) => details.recipeSources.size > 1)
            .map(([norm, details]) => ({
              normalizedText: norm,
              text: details.display_name,
              checked: details.uncheckedCount === 0,
              recipeSources: Array.from(details.recipeSources),
              quantity: details.quantity,
              unit: details.unit,
              originalItems: details.originalItems,
            }));

          return commonList.sort((a, b) => a.text.localeCompare(b.text));
        }, [shoppingList]);

        const displayRecipeGroups = useMemo(() => {
          return Object.values(groupedByRecipe)
            .map((group) => ({
              ...group,
              items: showChecked
                ? group.items
                : group.items.filter((item) => !item.checked),
            }))
            .filter((group) => group.items.length > 0)
            .sort((a, b) => a.name.localeCompare(b.name));
        }, [groupedByRecipe, showChecked]);

        const displayCommonIngredients = useMemo(() => {
          return showChecked
            ? commonIngredientsData
            : commonIngredientsData.filter((item) => !item.checked);
        }, [commonIngredientsData, showChecked]);

        const getFormattedListText = useCallback(() => {
          let listText = "Shopping List\n==============\n\n";
          const itemsToInclude = showChecked
            ? shoppingList
            : shoppingList.filter((item) => !item.checked);
          if (itemsToInclude.length === 0) return "";

          const outputGroups = {};
          itemsToInclude.forEach((item) => {
            const recipeName = item.recipeName || "Other Items";
            if (!outputGroups[recipeName]) outputGroups[recipeName] = [];
            const { value, unit: convertedUnit } = convertUnits(
              item.quantity,
              item.unit,
              displayUnitSystem
            );
            const displayQuantity = value !== null ? formatQuantity(value) : "";
            const displayUnit = convertedUnit || "";
            const displayIngredient =
              `${displayQuantity} ${displayUnit} ${item.description}`.trim();

            outputGroups[recipeName].push(
              `${item.checked ? "[x]" : "[ ]"} ${displayIngredient}`
            );
          });

          const sortedGroupNames = Object.keys(outputGroups).sort((a, b) => {
            if (a === "Other Items") return 1;
            if (b === "Other Items") return -1;
            return a.localeCompare(b);
          });

          sortedGroupNames.forEach((groupName) => {
            listText += `--- ${groupName} ---\n`;
            outputGroups[groupName]
              .sort((a, b) => a.substring(4).localeCompare(b.substring(4)))
              .forEach((itemText) => {
                listText += `${itemText}\n`;
              });
            listText += "\n";
          });

          return listText.trim();
        }, [shoppingList, showChecked, convertUnits, displayUnitSystem]);

        const copyToClipboard = useCallback(async () => {
          try {
            const listText = getFormattedListText();
            if (!listText) {
              addToast("List is empty or all items hidden.", "info");
              return;
            }
            const textarea = document.createElement("textarea");
            textarea.value = listText;
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
            addToast("List copied to clipboard!", "success");
          } catch (err) {
            console.error("Failed to copy list:", err);
            addToast("Failed to copy list.", "error");
          }
        }, [getFormattedListText, addToast]);

        const handleToggleItem = useCallback(
          (itemId) => {
            toggleShoppingItem(itemId, null);
          },
          [toggleShoppingItem]
        );

        const handleToggleCommonItem = useCallback(
          (normalizedText) => {
            toggleShoppingItem(null, normalizedText);
          },
          [toggleShoppingItem]
        );

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        const handleClearList = useCallback(() => {
          if (
            shoppingList.length > 0 &&
            window.confirm(
              "Are you sure you want to clear the entire shopping list? This cannot be undone."
            )
          ) {
            clearShoppingList();
          } else if (shoppingList.length === 0) {
            addToast("Shopping list is already empty.", "info");
          }
        }, [shoppingList, clearShoppingList, addToast]);

        const totalUncheckedItems = useMemo(
          () => shoppingList.filter((item) => !item.checked).length,
          [shoppingList]
        );

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-2xl max-h-[90vh] flex flex-col modal-scale-enter">
              <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h2 className="text-xl sm:text-2xl font-bold flex items-center gap-2 text-gray-900 dark:text-gray-100">
                  <i className="fas fa-shopping-cart text-green-500"></i>{" "}
                  Shopping List ({totalUncheckedItems} items)
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>

              <div className="flex justify-between items-center mb-4 gap-4 flex-wrap">
                <label className="flex items-center gap-1.5 cursor-pointer text-sm order-2 sm:order-1 text-gray-700 dark:text-gray-300">
                  <input
                    type="checkbox"
                    checked={showChecked}
                    onChange={() => setShowChecked((p) => !p)}
                    className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-600"
                  />{" "}
                  Show purchased
                </label>
                <div className="flex gap-2 order-3 sm:order-2">
                  <div className="flex items-center text-sm">
                    <label
                      htmlFor="unitSystem"
                      className="mr-2 text-gray-700 dark:text-gray-300"
                    >
                      Units:
                    </label>
                    <select
                      id="unitSystem"
                      className="filter-select text-xs"
                      value={displayUnitSystem}
                      onChange={(e) => setDisplayUnitSystem(e.target.value)}
                    >
                      <option value="imperial">Imperial</option>
                      <option value="metric">Metric</option>
                    </select>
                  </div>
                  <button
                    onClick={copyToClipboard}
                    className="btn-modal btn-gray text-xs"
                    title="Copy list to clipboard"
                    disabled={shoppingList.length === 0}
                  >
                    <i className="fas fa-copy mr-1"></i> Copy
                  </button>
                </div>
                <button
                  onClick={handleClearList}
                  className="btn-modal btn-red text-xs order-1 sm:order-3 ml-auto sm:ml-0"
                  disabled={shoppingList.length === 0}
                >
                  <i className="fas fa-trash mr-1"></i>Clear List
                </button>
              </div>

              <div className="flex-1 overflow-y-auto pr-2 space-y-4">
                {displayRecipeGroups.length === 0 &&
                displayCommonIngredients.length === 0 ? (
                  <div className="text-center text-gray-500 dark:text-gray-400 py-8 px-4">
                    <i className="fas fa-clipboard-list text-4xl mb-3 opacity-50"></i>
                    <p className="font-semibold">Shopping list is empty</p>
                    <p className="text-sm">
                      {showChecked
                        ? "Add ingredients from recipes!"
                        : "All items purchased."}
                    </p>
                  </div>
                ) : (
                  <>
                    {displayCommonIngredients.length > 0 && (
                      <div className="pb-3 mb-3 border-b border-gray-200 dark:border-gray-600">
                        <h3 className="text-sm font-semibold mb-1 text-blue-600 dark:text-blue-400">
                          Common Ingredients
                        </h3>
                        <ul className="space-y-1 mt-1">
                          {displayCommonIngredients.map((item) => {
                            const { value, unit: convertedUnit } = convertUnits(
                              item.quantity,
                              item.unit,
                              displayUnitSystem
                            );
                            const displayQuantity =
                              value !== null ? formatQuantity(value) : "";
                            const displayUnit = convertedUnit || "";

                            let displayIngredient = "";
                            if (displayQuantity) {
                              displayIngredient += `${displayQuantity} `;
                            }
                            if (displayUnit) {
                              displayIngredient += `${displayUnit} `;
                            }
                            displayIngredient += item.text;

                            return (
                              <li
                                key={item.normalizedText}
                                className={`p-1 rounded flex items-start gap-2 transition-opacity duration-200 ${
                                  item.checked
                                    ? "opacity-50 hover:opacity-70"
                                    : "hover:bg-gray-50 dark:hover:bg-gray-700"
                                }`}
                              >
                                <input
                                  type="checkbox"
                                  checked={item.checked}
                                  onChange={() =>
                                    handleToggleCommonItem(item.normalizedText)
                                  }
                                  className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-500 flex-shrink-0 cursor-pointer"
                                  aria-label={`Mark all '${item.text}' as ${
                                    item.checked ? "not purchased" : "purchased"
                                  }`}
                                />
                                <span
                                  className={`block leading-tight text-sm font-medium ${
                                    item.checked
                                      ? "line-through text-gray-500 dark:text-gray-400"
                                      : "text-gray-800 dark:text-gray-100"
                                  }`}
                                >
                                  {escapeHTML(displayIngredient.trim())}
                                  <span className="text-xs text-gray-400 dark:text-gray-500 ml-2 font-normal">
                                    ({item.recipeSources.join(", ")})
                                  </span>
                                </span>
                              </li>
                            );
                          })}
                        </ul>
                      </div>
                    )}

                    {displayRecipeGroups.length > 0 && (
                      <div>
                        <h3 className="text-sm font-semibold mb-1 text-green-600 dark:text-green-400 border-b border-green-200 dark:border-green-700 pb-0.5">
                          Ingredients by Recipe
                        </h3>
                        <ul className="space-y-1 mt-1">
                          {displayRecipeGroups.map((group) => (
                            <li key={group.id}>
                              <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mt-2 mb-1">
                                {escapeHTML(group.name)}
                              </h4>
                              <ul className="space-y-0.5 pl-4">
                                {group.items.map((item) => {
                                  const { value, unit: convertedUnit } =
                                    convertUnits(
                                      item.quantity,
                                      item.unit,
                                      displayUnitSystem
                                    );
                                  const displayQuantity =
                                    value !== null ? formatQuantity(value) : "";
                                  const displayUnit = convertedUnit || "";

                                  let displayIngredient = "";
                                  if (displayQuantity) {
                                    displayIngredient += `${displayQuantity} `;
                                  }
                                  if (displayUnit) {
                                    displayIngredient += `${displayUnit} `;
                                  }
                                  displayIngredient += item.description;

                                  return (
                                    <li
                                      key={item.id}
                                      className={`flex items-start gap-2 transition-opacity duration-200 ${
                                        item.checked
                                          ? "opacity-50 hover:opacity-70"
                                          : "hover:bg-gray-50 dark:hover:bg-gray-700"
                                      }`}
                                    >
                                      <input
                                        type="checkbox"
                                        checked={item.checked}
                                        onChange={() =>
                                          handleToggleItem(item.id)
                                        }
                                        className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-500 flex-shrink-0 cursor-pointer"
                                        aria-label={`Mark ${
                                          item.originalText
                                        } as ${
                                          item.checked
                                            ? "not purchased"
                                            : "purchased"
                                        }`}
                                      />
                                      <span
                                        className={`block leading-tight text-sm ${
                                          item.checked
                                            ? "line-through text-gray-500 dark:text-gray-400"
                                            : "text-gray-800 dark:text-gray-100"
                                        }`}
                                      >
                                        {escapeHTML(displayIngredient.trim())}
                                      </span>
                                    </li>
                                  );
                                })}
                              </ul>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          </div>
        );
      };

      const Footer = () => {
        const currentYear = new Date().getFullYear();
        const emailAddress = "BarrTechSolutions@gmail.com";

        return (
          <footer className="bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-300 py-4 text-center text-sm mt-8">
            <div className="max-w-7xl mx-auto px-4">
              <p>
                &copy; {currentYear} BarrTech Solutions. All rights reserved.
              </p>
              <p className="mt-1">
                Contact:{" "}
                <a
                  href={`mailto:${emailAddress}`}
                  className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-green-500"
                >
                  {emailAddress}
                </a>
              </p>
            </div>
          </footer>
        );
      };

      const rootElement = document.getElementById("root");
      if (rootElement) {
        const reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(<App />);
      } else {
        console.error("Root element not found! React app cannot be mounted.");
      }
    </script>
  </body>
</html>
