<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recipe Manager Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      xintegrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.24.0/babel.min.js"></script>
    <style>
      /* Card Hover Animation */
      .recipe-card {
        transition:
          transform 0.18s cubic-bezier(0.4, 2, 0.6, 1),
          box-shadow 0.18s cubic-bezier(0.4, 2, 0.6, 1);
      }
      .recipe-card:hover {
        transform: scale(1.07) translateY(-8px);
        box-shadow:
          0 16px 48px 0 rgba(16, 185, 129, 0.18),
          0 6px 24px 0 rgba(0, 0, 0, 0.16);
        z-index: 3;
      }
      /* Tag Hover Effect */
      .tag-hover {
        transition:
          background 0.18s,
          color 0.18s;
      }
      .tag-hover:hover {
        background: #a78bfa !important;
        color: #fff !important;
      }
      .dark .tag-hover:hover {
        background: #7c3aed !important;
        color: #fff !important;
      }
      /* Modal Fade/Scale Animation */
      .modal-fade {
        animation: modalFadeIn 0.22s cubic-bezier(0.4, 2, 0.6, 1);
      }
      @keyframes modalFadeIn {
        0% {
          opacity: 0;
          transform: scale(0.96);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      /* Button Ripple Effect */
      .ripple {
        position: relative;
        overflow: hidden;
      }
      .ripple:after {
        content: "";
        display: block;
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        width: 100px;
        height: 100px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: rgba(16, 185, 129, 0.18);
        animation: ripple-effect 0.5s linear;
        opacity: 0;
      }
      .ripple:active:after {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        transition: 0s;
      }
      @keyframes ripple-effect {
        to {
          opacity: 0;
          transform: translate(-50%, -50%) scale(2.5);
        }
      }
      /* Card Entry Animation */
      .card-appear {
        opacity: 0;
        transform: translateY(16px) scale(0.98);
        animation: cardFadeIn 0.38s cubic-bezier(0.4, 2, 0.6, 1) forwards;
      }
      @keyframes cardFadeIn {
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      /* Spinner */
      .spinner {
        border: 3px solid #e5e7eb;
        border-top: 3px solid #10b981;
        border-radius: 50%;
        width: 2.5rem;
        height: 2.5rem;
        animation: spin 0.7s linear infinite;
        margin: 2rem auto;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #999;
      }
      .dark ::-webkit-scrollbar-track {
        background: #2d3748;
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #4a5568;
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #6a7788;
      }

      body.modal-open {
        overflow: hidden;
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translateY(10px);
        }
        15% {
          opacity: 1;
          transform: translateY(0);
        }
        85% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(10px);
        }
      }
      .animate-fade-in-out {
        animation: fadeInOut 3s ease-in-out forwards;
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.95);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .modal-scale-enter {
        animation: scaleIn 0.2s ease-out forwards;
      }

      .collapsible-content {
        transition:
          max-height 0.3s ease-out,
          opacity 0.3s ease-out;
        overflow: hidden;
        max-height: 0;
        opacity: 0;
      }
      .collapsible-content.expanded {
        max-height: 1000px;
        opacity: 1;
      }

      .btn-header {
        background-color: #f3f4f6;
        color: #374151;
        padding: 6px 10px;
        border-radius: 9999px;
        display: inline-flex;
        align-items: center;
        font-size: 0.875rem;
        transition:
          background-color 0.2s ease,
          color 0.2s ease;
        border: 1px solid transparent;
        white-space: nowrap;
      }
      .btn-header:hover {
        background-color: #e5e7eb;
      }
      .dark .btn-header {
        background-color: #374151;
        color: #d1d5db;
      }
      .dark .btn-header:hover {
        background-color: #4b5563;
      }
      .btn-header.bg-green-500 {
        border-color: transparent;
        color: white;
      }
      .dark .btn-header.bg-green-500 {
        color: white;
      }

      .filter-select {
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        background-color: #ffffff;
        color: #1f2937;
        font-size: 0.875rem;
        line-height: 1.25rem;
        appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%236b7280%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1em 1em;
        padding-right: 2rem;
      }
      .dark .filter-select {
        border-color: #4b5563;
        background-color: #374151;
        color: #f3f4f6;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%23d1d5db%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E");
      }
      .filter-select:focus {
        outline: none;
        border-color: #10b981;
        box-shadow: 0 0 0 1px #10b981;
      }

      .modal-input,
      .modal-textarea,
      .modal-input-sm {
        width: 100%;
        border-radius: 0.375rem;
        border: 1px solid #d1d5db;
        background-color: #f9fafb;
        color: #111827;
        transition:
          border-color 0.2s ease,
          box-shadow 0.2s ease;
      }
      .modal-input,
      .modal-textarea {
        padding: 8px 12px;
      }
      .modal-input-sm {
        padding: 6px 10px;
        font-size: 0.875rem;
      }
      .dark .modal-input,
      .dark .modal-textarea,
      .dark .modal-input-sm {
        border-color: #4b5563;
        background-color: #374151;
        color: #f3f4f6;
      }
      .modal-input:focus,
      .modal-textarea:focus,
      .modal-input-sm:focus {
        outline: none;
        border-color: #10b981;
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3);
      }
      .modal-input.border-red-500,
      .modal-textarea.border-red-500,
      .modal-input-sm.border-red-500 {
        border-color: #ef4444;
      }
      .modal-input.border-red-500:focus,
      .modal-textarea.border-red-500:focus,
      .modal-input-sm.border-red-500:focus {
        box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
      }

      .btn-modal {
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.875rem;
        display: inline-flex;
        align-items: center;
        transition: all 0.2s ease;
        border: none;
        cursor: pointer;
      }
      .btn-modal:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-green {
        background-color: #10b981;
        color: white;
      }
      .btn-green:hover:not(:disabled) {
        background-color: #059669;
      }
      .btn-gray {
        background-color: #e5e7eb;
        color: #1f2937;
      }
      .btn-gray:hover:not(:disabled) {
        background-color: #d1d5db;
      }
      .dark .btn-gray {
        background-color: #4b5563;
        color: #e5e7eb;
      }
      .dark .btn-gray:hover:not(:disabled) {
        background-color: #6b7280;
      }
      .btn-blue {
        background-color: #3b82f6;
        color: white;
      }
      .btn-blue:hover:not(:disabled) {
        background-color: #2563eb;
      }
      .btn-red {
        background-color: #ef4444;
        color: white;
      }
      .btn-red:hover:not(:disabled) {
        background-color: #dc2626;
      }

      .adjust-btn {
        background-color: #d1d5db;
        color: #374151;
        width: 1.75rem;
        height: 1.75rem;
        border-radius: 9999px;
        font-size: 1rem;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .adjust-btn:hover:not(:disabled) {
        background-color: #9ca3af;
      }
      .adjust-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .dark .adjust-btn {
        background-color: #4b5563;
        color: #e5e7eb;
      }
      .dark .adjust-btn:hover:not(:disabled) {
        background-color: #6b7280;
      }

      .line-clamp-1 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
        line-clamp: 1;
      }
      .line-clamp-2 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
        line-clamp: 2;
      }
      .line-clamp-3 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
        line-clamp: 3;
      }

      .tc {
        text-align: center;
      }
      .op-70 {
        opacity: 0.7;
      }
      .op-80 {
        opacity: 0.8;
      }
      .op-50 {
        opacity: 0.5;
      }
      .mr-0\.5 {
        margin-right: 0.125rem;
      }

      .tag-input-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        padding: 4px;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        background-color: #f9fafb;
        min-height: 38px;
      }
      .dark .tag-input-container {
        border-color: #4b5563;
        background-color: #374151;
      }
      .tag-item {
        background-color: #10b981;
        color: white;
        padding: 2px 8px;
        border-radius: 9999px;
        font-size: 0.875rem;
        margin: 2px;
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
      }
      .tag-item-remove {
        background: none;
        border: none;
        color: white;
        margin-left: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .tag-item-remove:hover {
        opacity: 1;
      }
      .tag-input {
        flex-grow: 1;
        border: none;
        outline: none;
        padding: 6px 8px;
        background-color: transparent;
        color: #111827;
        min-width: 100px;
      }
      .dark .tag-input {
        color: #f3f4f6;
      }
      .tag-input-container:focus-within {
        border-color: #10b981;
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3);
      }
      .tag-input-container.border-red-500 {
        border-color: #ef4444;
      }

      /* Print Styles */
      @media print {
        body {
          background: white !important;
          color: black !important;
        }

        /* Hide navigation, buttons, and non-essential elements */
        header,
        footer,
        .btn-modal,
        button,
        .fixed,
        [class*="z-50"],
        [class*="z-40"],
        .bg-black,
        .modal-scale-enter {
          display: none !important;
        }

        /* Show only recipe details */
        .bg-white,
        .dark\\:bg-gray-800 {
          background: white !important;
          box-shadow: none !important;
          border-radius: 0 !important;
          max-width: 100% !important;
          padding: 20px !important;
        }

        /* Recipe title and metadata */
        h2,
        h3 {
          color: black !important;
          page-break-after: avoid;
        }

        /* Ingredients and directions */
        ul,
        ol,
        li {
          color: black !important;
          page-break-inside: avoid;
        }

        /* Ensure proper spacing */
        .mb-6,
        .mt-6 {
          margin-top: 1rem !important;
          margin-bottom: 1rem !important;
        }

        /* Hide decorative icons in print */
        i.fas,
        i.far {
          display: none !important;
        }

        /* Page breaks */
        .page-break {
          page-break-after: always;
        }
      }
    </style>
  </head>
  <body
    class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300 font-sans"
  >
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useMemo, useCallback } = React;

      // --- Database and Utility Functions (No Changes) ---
      const DB_NAME = "RecipeManagerDB";
      const DB_VERSION = 2;
      const STORE_NAMES = {
        RECIPES: "recipes",
        MEAL_PLAN: "mealPlan",
        SHOPPING_LIST: "shoppingList",
        PANTRY: "pantry",
        COLLECTIONS: "collections",
      };
      // End of RecipeSuggestionsModal
      const LOCAL_STORAGE_KEYS = {
        RECIPES: "recipes",
        MEAL_PLAN: "mealPlan",
        SHOPPING_LIST: "shoppingList",
        THEME: "theme",
      };

      let db = null;

      const openDatabase = () => {
        return new Promise((resolve, reject) => {
          if (db) {
            resolve(db);
            return;
          }

          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            for (const storeName of Object.values(STORE_NAMES)) {
              if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName, { keyPath: "id" });
              }
            }
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };

          request.onerror = (event) => {
            console.error("IndexedDB error:", event.target.error);
            reject(event.target.error);
          };
        });
      };

      const getStore = async (storeName, mode) => {
        const database = await openDatabase();
        const transaction = database.transaction(storeName, mode);
        return transaction.objectStore(storeName);
      };

      const getAllItems = async (storeName) => {
        try {
          const store = await getStore(storeName, "readonly");
          const request = store.getAll();
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error getting all items from ${storeName}:`, error);
          return [];
        }
      };

      const addItem = async (storeName, item) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.add(item);
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(item);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error adding item to ${storeName}:`, error);
          throw error;
        }
      };

      const updateItem = async (storeName, id, updatedItem) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.put(updatedItem);
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(updatedItem);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error updating item in ${storeName}:`, error);
          throw error;
        }
      };

      const deleteItem = async (storeName, id) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.delete(id);
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error deleting item from ${storeName}:`, error);
          throw error;
        }
      };

      const clearStore = async (storeName) => {
        try {
          const store = await getStore(storeName, "readwrite");
          const request = store.clear();
          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error(`Error clearing store ${storeName}:`, error);
          throw error;
        }
      };

      const formatMinutesToHoursMinutes = (totalMinutes) => {
        if (isNaN(totalMinutes) || totalMinutes < 0) return "";
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        let parts = [];
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0 || totalMinutes === 0) parts.push(`${minutes}m`);
        return parts.join(" ");
      };

      const escapeHTML = (str) => {
        if (!str) return "";
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      };

      const parseIngredient = (ingredient) => {
        if (typeof ingredient !== "string")
          return { quantity: null, unit: null, description: "" };

        const regex =
          /^\s*(\d*\s*\d*\/\d+|\d+\.?\d*|\d*[\u00BC-\u00BE\u2150-\u215E])?\s*([a-zA-Z.]+)?\s*(.*)$/;
        const match = ingredient.match(regex);

        if (match) {
          let quantity = null;
          let unit = match[2]?.trim() || null;
          let description = match[3]?.trim() || "";
          const quantityString = match[1]?.trim();

          const unicodeFractions = {
            "¬Ω": 0.5,
            "¬º": 0.25,
            "¬æ": 0.75,
            "‚Öì": 1 / 3,
            "‚Öî": 2 / 3,
            "‚Öï": 0.2,
            "‚Öñ": 0.4,
            "‚Öó": 0.6,
            "‚Öò": 0.8,
            "‚Öô": 1 / 6,
            "‚Öö": 5 / 6,
            "‚Öõ": 0.125,
            "‚Öú": 0.375,
            "‚Öù": 0.625,
            "‚Öû": 0.875,
          };

          if (quantityString) {
            try {
              let totalQuantity = 0;
              const parts = quantityString.split(/\s+/);
              if (parts.length === 2 && parts[1].includes("/")) {
                totalQuantity = parseFloat(parts[0]) + eval(parts[1]);
              } else if (parts.length === 1 && parts[0].includes("/")) {
                totalQuantity = eval(parts[0]);
              } else if (unicodeFractions[quantityString]) {
                totalQuantity = unicodeFractions[quantityString];
              } else {
                totalQuantity = parseFloat(quantityString);
              }

              if (!isNaN(totalQuantity)) {
                quantity = totalQuantity;
              } else {
                description =
                  `${quantityString} ${unit || ""} ${description}`.trim();
                unit = null;
              }
            } catch (e) {
              console.warn("Could not parse quantity:", quantityString, e);
              description =
                `${quantityString} ${unit || ""} ${description}`.trim();
              unit = null;
            }
          }

          const commonNonUnits = new Set([
            "large",
            "medium",
            "small",
            "fresh",
            "dried",
            "chopped",
            "diced",
            "minced",
            "sliced",
            "crushed",
            "finely",
            "roughly",
            "peeled",
            "seeded",
            "cored",
            "rinsed",
            "optional",
            "divided",
            "softened",
            "melted",
            "beaten",
            "cooked",
            "uncooked",
            "raw",
            "canned",
            "frozen",
            "thawed",
            "packed",
            "heaping",
            "scant",
            "about",
            "approximately",
            "plus",
            "more",
            "as",
            "needed",
            "to",
            "taste",
          ]);
          if (unit && commonNonUnits.has(unit.toLowerCase())) {
            description = `${unit} ${description}`.trim();
            unit = null;
          }

          if (quantity === null) {
            description = ingredient;
            unit = null;
          }

          return { quantity, unit, description };
        }
        // If no match, return as description
        return { quantity: null, unit: null, description: ingredient };
      };

      // PantryModal: Card-based, with name, quantity, amount, expiration, and auto-populate from checked shopping list
      // InventoryModal from reference, renamed to PantryModal for integration
      const PantryModal = ({
        inventory,
        addInventoryItem,
        updateInventoryItem,
        deleteInventoryItem,
        clearAllInventory,
        checkRecipeAvailability,
        recipes,
        onClose,
        addToast,
      }) => {
        console.log(
          `[PantryModal] Rendered with ${inventory?.length || 0} inventory items`,
        );

        const [showAddForm, setShowAddForm] = React.useState(false);
        const [editingItem, setEditingItem] = React.useState(null);
        const [formData, setFormData] = React.useState({
          name: "",
          quantity: 1,
          unit: "",
          category: "Pantry",
          expirationDate: "",
          location: "Pantry",
          notes: "",
        });
        const [filter, setFilter] = React.useState("all");

        // Add missing categories array
        const categories = [
          "Pantry",
          // "Spices",
          "Frozen",
          "Other",
        ];
        const locations = ["Pantry", "Fridge", "Freezer", "Cabinet", "Other"];

        const handleSubmit = async (e) => {
          e.preventDefault();
          if (!formData.name.trim()) {
            addToast("Please enter an item name", "error");
            return;
          }

          if (editingItem) {
            await updateInventoryItem(editingItem.id, formData);
            setEditingItem(null);
          } else {
            await addInventoryItem(formData);
          }

          setFormData({
            name: "",
            quantity: 1,
            unit: "",
            category: "Pantry",
            expirationDate: "",
            location: "Pantry",
            notes: "",
          });
          setShowAddForm(false);
        };

        const handleEdit = (item) => {
          setEditingItem(item);
          setFormData({
            name: item.name,
            quantity: item.quantity,
            unit: item.unit,
            category: item.category,
            expirationDate: item.expirationDate || "",
            location: item.location,
            notes: item.notes || "",
          });
          setShowAddForm(true);
        };

        const handleClearAll = async () => {
          if (
            window.confirm(
              `Are you sure you want to clear all ${inventory.length} items from inventory? This cannot be undone.`,
            )
          ) {
            await clearAllInventory();
          }
        };

        const handleDelete = async (id) => {
          if (window.confirm("Remove this item from inventory?")) {
            await deleteInventoryItem(id);
          }
        };

        const filteredInventory =
          filter === "all"
            ? inventory
            : inventory.filter((item) => item.category === filter);

        const expiringSoon = inventory.filter((item) => {
          if (!item.expirationDate) return false;
          const expDate = new Date(item.expirationDate);
          const today = new Date();
          const daysUntilExpiry = Math.ceil(
            (expDate - today) / (1000 * 60 * 60 * 24),
          );
          return daysUntilExpiry >= 0 && daysUntilExpiry <= 7;
        });

        const canMakeRecipes = Array.isArray(recipes)
          ? recipes.filter((recipe) => {
              const { canMake } = checkRecipeAvailability(recipe);
              return canMake;
            })
          : [];

        // Fix: define handleOpenRecipeDetails in this scope
        function handleOpenRecipeDetails(recipe) {
          if (typeof window !== "undefined" && window.dispatchEvent) {
            window.dispatchEvent(
              new CustomEvent("openRecipeDetailsFromPantry", {
                detail: { recipeId: recipe.id },
              }),
            );
          }
        }

        return (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-40 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-lg max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col">
              <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                <div>
                  <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
                    üì¶ Ingredient Inventory
                  </h2>
                  <p className="text-sm text-gray-600 dark:text-gray-400">
                    {inventory.length} items ‚Ä¢ {canMakeRecipes.length} recipes
                    you can make
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  {inventory.length > 0 && (
                    <button
                      onClick={handleClearAll}
                      className="btn-modal btn-red inventory-clear-btn"
                    >
                      <i className="fas fa-trash-alt mr-2"></i>
                      Clear
                    </button>
                  )}
                  <button onClick={onClose} className="btn-modal btn-gray">
                    <i className="fas fa-times"></i>
                  </button>
                </div>
              </div>

              {expiringSoon.length > 0 && (
                <div className="bg-yellow-50 dark:bg-yellow-900/20 border-b border-yellow-200 dark:border-yellow-800 p-3">
                  <div className="flex items-center gap-2 text-yellow-800 dark:text-yellow-300">
                    <i className="fas fa-exclamation-triangle"></i>
                    <span className="font-semibold">
                      {expiringSoon.length} item(s) expiring within 7 days
                    </span>
                  </div>
                </div>
              )}

              <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex flex-wrap gap-2">
                <button
                  onClick={() => setFilter("all")}
                  className={`btn-header ${filter === "all" ? "bg-green-500 text-white" : ""}`}
                >
                  All ({inventory.length})
                </button>
                {categories.map((cat) => (
                  <button
                    key={cat}
                    onClick={() => setFilter(cat)}
                    className={`btn-header ${filter === cat ? "bg-green-500 text-white" : ""}`}
                  >
                    {cat} ({inventory.filter((i) => i.category === cat).length})
                  </button>
                ))}
              </div>

              <div className="flex-grow overflow-y-auto p-4">
                {!showAddForm && (
                  <button
                    onClick={() => {
                      setShowAddForm(true);
                      setEditingItem(null);
                    }}
                    className="w-full btn-modal btn-green mb-4"
                  >
                    <i className="fas fa-plus mr-2"></i>
                    Add Item to Inventory
                  </button>
                )}

                {showAddForm && (
                  <form
                    onSubmit={handleSubmit}
                    className="bg-gray-50 dark:bg-gray-900 rounded-lg p-4 mb-4"
                  >
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">
                      {editingItem ? "Edit Item" : "Add New Item"}
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                      <input
                        type="text"
                        placeholder="Item name *"
                        value={formData.name}
                        onChange={(e) =>
                          setFormData({ ...formData, name: e.target.value })
                        }
                        className="modal-input"
                        required
                      />
                      <div className="flex gap-2">
                        <input
                          type="number"
                          placeholder="Qty"
                          value={formData.quantity}
                          onChange={(e) =>
                            setFormData({
                              ...formData,
                              quantity: parseFloat(e.target.value) || 1,
                            })
                          }
                          className="modal-input flex-grow"
                          min="0"
                          step="0.1"
                        />
                        <input
                          type="text"
                          placeholder="Unit"
                          value={formData.unit}
                          onChange={(e) =>
                            setFormData({ ...formData, unit: e.target.value })
                          }
                          className="modal-input w-24"
                        />
                      </div>
                      <select
                        value={formData.category}
                        onChange={(e) =>
                          setFormData({ ...formData, category: e.target.value })
                        }
                        className="modal-input"
                      >
                        {categories.map((cat) => (
                          <option key={cat} value={cat}>
                            {cat}
                          </option>
                        ))}
                      </select>
                      <select
                        value={formData.location}
                        onChange={(e) =>
                          setFormData({ ...formData, location: e.target.value })
                        }
                        className="modal-input"
                      >
                        {locations.map((loc) => (
                          <option key={loc} value={loc}>
                            {loc}
                          </option>
                        ))}
                      </select>
                      <input
                        type="date"
                        value={formData.expirationDate}
                        onChange={(e) =>
                          setFormData({
                            ...formData,
                            expirationDate: e.target.value,
                          })
                        }
                        className="modal-input"
                        placeholder="Expiration date"
                      />
                      <input
                        type="text"
                        placeholder="Notes (optional)"
                        value={formData.notes}
                        onChange={(e) =>
                          setFormData({ ...formData, notes: e.target.value })
                        }
                        className="modal-input"
                      />
                    </div>
                    <div className="flex gap-2 mt-3">
                      <button type="submit" className="btn-modal btn-green">
                        <i
                          className={`fas fa-${editingItem ? "save" : "plus"} mr-2`}
                        ></i>
                        {editingItem ? "Save Changes" : "Add Item"}
                      </button>
                      <button
                        type="button"
                        onClick={() => {
                          setShowAddForm(false);
                          setEditingItem(null);
                          setFormData({
                            name: "",
                            quantity: 1,
                            unit: "",
                            category: "Pantry",
                            expirationDate: "",
                            location: "Pantry",
                            notes: "",
                          });
                        }}
                        className="btn-modal btn-gray"
                      >
                        Cancel
                      </button>
                    </div>
                  </form>
                )}

                {filteredInventory.length === 0 ? (
                  <div className="text-center py-10 text-gray-500 dark:text-gray-400">
                    <i className="fas fa-box-open text-4xl mb-3"></i>
                    <p>No items in this category</p>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                    {filteredInventory.map((item) => {
                      const expDate = item.expirationDate
                        ? new Date(item.expirationDate)
                        : null;
                      const today = new Date();
                      const daysUntilExpiry = expDate
                        ? Math.ceil((expDate - today) / (1000 * 60 * 60 * 24))
                        : null;
                      const isExpiring =
                        daysUntilExpiry !== null &&
                        daysUntilExpiry >= 0 &&
                        daysUntilExpiry <= 7;
                      const isExpired =
                        daysUntilExpiry !== null && daysUntilExpiry < 0;

                      return (
                        <div
                          key={item.id}
                          className={`bg-white dark:bg-gray-700 rounded-lg p-3 border-2 ${
                            isExpired
                              ? "border-red-500"
                              : isExpiring
                                ? "border-yellow-500"
                                : "border-gray-200 dark:border-gray-600"
                          }`}
                        >
                          <div className="flex justify-between items-start mb-2">
                            <div>
                              <h3 className="font-semibold text-gray-900 dark:text-white">
                                {item.name}
                              </h3>
                              <p className="text-sm text-gray-600 dark:text-gray-400">
                                {item.quantity} {item.unit}
                              </p>
                            </div>
                            <div className="flex gap-2">
                              <button
                                onClick={() => handleEdit(item)}
                                className="text-blue-500 hover:text-blue-700 text-sm"
                                title="Edit item"
                              >
                                <i className="fas fa-edit"></i>
                              </button>
                              <button
                                onClick={() => handleDelete(item.id)}
                                className="text-red-500 hover:text-red-700 text-sm"
                                title="Delete item"
                              >
                                <i className="fas fa-trash"></i>
                              </button>
                            </div>
                          </div>
                          <div className="text-xs text-gray-500 dark:text-gray-400 space-y-1">
                            <p>üìç {item.location}</p>
                            <p>üè∑Ô∏è {item.category}</p>
                            {expDate && (
                              <p
                                className={
                                  isExpired
                                    ? "text-red-500"
                                    : isExpiring
                                      ? "text-yellow-600"
                                      : ""
                                }
                              >
                                ‚è∞{" "}
                                {isExpired
                                  ? "Expired"
                                  : isExpiring
                                    ? `Expires in ${daysUntilExpiry}d`
                                    : expDate.toLocaleDateString()}
                              </p>
                            )}
                            {item.notes && <p>üìù {item.notes}</p>}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}

                {canMakeRecipes.length > 0 && (
                  <div className="mt-6">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-3">
                      ‚ú® Recipes You Can Make Now ({canMakeRecipes.length})
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2 max-h-96 overflow-y-auto">
                      {canMakeRecipes.map((recipe) => (
                        <button
                          key={recipe.id}
                          className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-3 text-left hover:bg-green-100 dark:hover:bg-green-800/40 focus:outline-none focus:ring-2 focus:ring-green-400 transition cursor-pointer"
                          onClick={() => handleOpenRecipeDetails(recipe)}
                          tabIndex={0}
                          aria-label={`Open recipe details for ${recipe.name}`}
                        >
                          <p className="font-medium text-gray-900 dark:text-white">
                            {recipe.name}
                          </p>
                          <p className="text-sm text-gray-600 dark:text-gray-400">
                            {recipe.type} ‚Ä¢ {recipe.cuisine}
                          </p>
                        </button>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      // --- FIXED parseYield function ---
      const parseYield = (yieldString) => {
        if (typeof yieldString !== "string" || yieldString.trim() === "")
          return { quantity: null, unit: "" };

        const match = yieldString.trim().match(/^([\d./\s¬Ω¬º¬æ‚Öì‚Öî‚Öõ‚Öú‚Öù‚Öû]+)\s*(.*)/i);
        if (match) {
          const numericPart = match[1]?.trim();
          const unitPart = match[2]?.trim() || "";
          try {
            const mixedParts = numericPart.split(/[\s\+]+/);
            let totalQuantity = 0;
            const unicodeFractions = {
              "¬Ω": 0.5,
              "¬º": 0.25,
              "¬æ": 0.75,
              "‚Öì": 1 / 3,
              "‚Öî": 2 / 3,
              "‚Öõ": 1 / 8,
              "‚Öú": 3 / 8,
              "‚Öù": 5 / 8,
              "‚Öû": 7 / 8,
            };

            for (const part of mixedParts) {
              if (part.includes("/")) {
                const fractionParts = part.split("/");
                if (fractionParts.length === 2) {
                  const num = parseFloat(fractionParts[0]);
                  const den = parseFloat(fractionParts[1]);
                  if (!isNaN(num) && !isNaN(den) && den !== 0)
                    totalQuantity += num / den;
                  else throw new Error("Invalid fraction part");
                } else throw new Error("Invalid fraction format");
              } else if (unicodeFractions[part]) {
                totalQuantity += unicodeFractions[part];
              } else {
                const num = parseFloat(part);
                if (!isNaN(num)) totalQuantity += num;
                else throw new Error("Invalid numeric part");
              }
            }
            return { quantity: totalQuantity, unit: unitPart };
          } catch (e) {
            console.warn("Could not parse yield quantity:", numericPart, e);
            return { quantity: null, unit: yieldString.trim() };
          }
        }
        return { quantity: null, unit: yieldString.trim() };
      };

      const formatScaledYield = (originalYieldString, multiplier) => {
        if (
          multiplier === 1 ||
          !originalYieldString ||
          originalYieldString.trim() === ""
        ) {
          return originalYieldString;
        }

        const { quantity, unit } = parseYield(originalYieldString);

        if (quantity === null || quantity === 0) {
          return originalYieldString;
        }

        const scaledQuantity = quantity * multiplier;

        let formattedUnit = unit;
        if (
          scaledQuantity > 1 &&
          unit &&
          !unit.endsWith("s") &&
          !unit.endsWith("es")
        ) {
          if (
            ["cup", "serving", "loin", "piece"].includes(unit.toLowerCase())
          ) {
            formattedUnit = unit + "s";
          }
        } else if (
          scaledQuantity <= 1 &&
          unit &&
          (unit.endsWith("s") || unit.endsWith("es"))
        ) {
          if (
            ["cups", "servings", "loins", "pieces"].includes(unit.toLowerCase())
          ) {
            formattedUnit = unit.slice(0, -1);
          } else if (["batches", "washes"].includes(unit.toLowerCase())) {
            formattedUnit = unit.slice(0, -2);
          }
        }

        return `${formatQuantity(scaledQuantity)} ${formattedUnit}`.trim();
      };

      const normalizeIngredient = (ingredient) => {
        const { description } = parseIngredient(ingredient);
        if (!description) {
          // Fallback: if parseIngredient fails, use the whole ingredient string
          const fallback = ingredient
            .toLowerCase()
            .replace(/[^a-z\s]/g, "")
            .replace(/\s+/g, " ")
            .trim();
          return fallback || ingredient.toLowerCase();
        }

        const units = [
          "tbsp",
          "tablespoon",
          "tbs",
          "tsp",
          "teaspoon",
          "cup",
          "c",
          "oz",
          "ounce",
          "fl oz",
          "fluid ounce",
          "pt",
          "pint",
          "qt",
          "quart",
          "gal",
          "gallon",
          "lb",
          "pound",
          "g",
          "gram",
          "kg",
          "kilogram",
          "mg",
          "milligram",
          "ml",
          "milliliter",
          "l",
          "liter",
          "clove",
          "can",
          "jar",
          "slice",
          "pinch",
          "dash",
          "stalk",
          "head",
          "sprig",
          "bunch",
          "package",
          "pkg",
          "box",
          "container",
          "stick",
          "piece",
          "fillet",
          "ear",
        ];

        const descriptors = [
          "to taste",
          "diced",
          "minced",
          "sliced",
          "chopped",
          "crushed",
          "fresh",
          "for garnish",
          "finely",
          "roughly",
          "peeled",
          "seeded",
          "cored",
          "rinsed",
          "dried",
          "optional",
          "divided",
          "softened",
          "melted",
          "beaten",
          "cooked",
          "uncooked",
          "raw",
          "canned",
          "frozen",
          "thawed",
          "packed",
          "firmly packed",
          "lightly packed",
          "heaping",
          "scant",
          "large",
          "medium",
          "small",
          "thinly",
          "thickly",
          "cubed",
          "julienned",
          "grated",
          "zested",
          "juiced",
          "room temperature",
          "cold",
          "hot",
          "warm",
          "about",
          "approximately",
          "plus more",
          "or more",
          "as needed",
          "such as",
        ];

        let normalized = description
          .toLowerCase()
          .replace(/\(.*?\)/g, "")
          .replace(new RegExp(`\\b(${units.join("|")})s?\\b`, "g"), "")
          .replace(new RegExp(`\\b(${descriptors.join("|")})\\b`, "g"), "")
          .replace(/[^a-z\s]/g, "")
          .replace(/\s+/g, " ")
          .trim();

        // If normalization resulted in empty string, use the original description
        if (!normalized) {
          normalized = description
            .toLowerCase()
            .replace(/[^a-z\s]/g, "")
            .replace(/\s+/g, " ")
            .trim();
        }

        // If still empty, use the original ingredient as fallback
        if (!normalized) {
          return (
            ingredient
              .toLowerCase()
              .replace(/[^a-z\s]/g, "")
              .replace(/\s+/g, " ")
              .trim() || ingredient.toLowerCase()
          );
        }

        if (
          normalized.endsWith("es") &&
          ["tomato", "potato"].some((base) => normalized.startsWith(base))
        ) {
          normalized = normalized.slice(0, -2);
        } else if (
          normalized.endsWith("s") &&
          !normalized.endsWith("ss") &&
          !["greens", "oats", "pasta", "rice", "hummus", "molasses"].includes(
            normalized,
          ) &&
          normalized.length > 2
        ) {
          normalized = normalized.slice(0, -1);
        }

        return normalized || description.toLowerCase();
      };

      // Helper: compute match between a recipe and current pantry
      const computeRecipeMatch = (recipe, pantryList) => {
        const pantryNames = new Set(
          (pantryList || []).map((i) =>
            normalizeIngredient(i.name).toLowerCase(),
          ),
        );

        console.log(
          `[computeRecipeMatch] Recipe: ${recipe.name}, Pantry items: ${pantryList?.length || 0}`,
        );
        console.log(
          `[computeRecipeMatch] Normalized pantry:`,
          Array.from(pantryNames),
        );

        const total = Array.isArray(recipe.ingredients)
          ? recipe.ingredients.length
          : 0;
        if (total === 0) {
          return {
            matchedCount: 0,
            totalIngredients: 0,
            percentage: 0,
            canMake: false,
            missing: [],
          };
        }

        let matched = 0;
        const missing = [];

        for (const ing of recipe.ingredients) {
          const normIng = normalizeIngredient(ing).toLowerCase();
          const found = Array.from(pantryNames).some(
            (pn) =>
              pn && normIng && (normIng.includes(pn) || pn.includes(normIng)),
          );
          console.log(
            `[computeRecipeMatch] Ingredient "${ing}" -> normalized "${normIng}" -> ${found ? "FOUND" : "NOT FOUND"}`,
          );
          if (found) matched += 1;
          else missing.push(ing);
        }

        const percentage = Math.round((matched / total) * 100);
        const canMake = matched === total && total > 0;

        console.log(
          `[computeRecipeMatch] Result: ${matched}/${total} = ${percentage}%, canMake: ${canMake}`,
        );

        return {
          matchedCount: matched,
          totalIngredients: total,
          percentage,
          canMake,
          missing,
        };
      };

      // expose computeRecipeMatch globally so components below can use it
      window.computeRecipeMatch = computeRecipeMatch;

      // Ingredient Substitutions Database
      const INGREDIENT_SUBSTITUTIONS = {
        butter: ["margarine", "coconut oil", "vegetable oil", "olive oil"],
        margarine: ["butter", "coconut oil", "vegetable oil"],
        milk: [
          "almond milk",
          "soy milk",
          "oat milk",
          "coconut milk",
          "water + milk powder",
        ],
        "heavy cream": [
          "half and half + butter",
          "coconut cream",
          "evaporated milk",
        ],
        "sour cream": [
          "greek yogurt",
          "plain yogurt",
          "cream cheese",
          "cottage cheese blended",
        ],
        yogurt: ["sour cream", "buttermilk", "cottage cheese blended"],
        egg: [
          "flax egg (1 tbsp flax + 3 tbsp water)",
          "chia egg",
          "applesauce (1/4 cup)",
          "mashed banana",
        ],
        "bread crumbs": [
          "crushed crackers",
          "panko",
          "oats",
          "crushed cornflakes",
        ],
        "all-purpose flour": [
          "whole wheat flour",
          "bread flour",
          "cake flour",
          "gluten-free flour blend",
        ],
        sugar: [
          "honey (reduce liquid)",
          "maple syrup (reduce liquid)",
          "agave nectar",
          "brown sugar",
        ],
        "brown sugar": [
          "white sugar + molasses",
          "coconut sugar",
          "maple sugar",
        ],
        honey: [
          "maple syrup",
          "agave nectar",
          "corn syrup",
          "sugar dissolved in water",
        ],
        "lemon juice": ["lime juice", "white vinegar", "apple cider vinegar"],
        vinegar: ["lemon juice", "lime juice", "white wine"],
        wine: [
          "grape juice + vinegar",
          "broth + vinegar",
          "water + lemon juice",
        ],
        broth: ["bouillon cube + water", "stock", "water + soy sauce"],
        "tomato sauce": [
          "tomato paste + water",
          "crushed tomatoes blended",
          "ketchup thinned",
        ],
        "tomato paste": ["tomato sauce reduced", "ketchup"],
        ketchup: ["tomato sauce + sugar + vinegar"],
        mayonnaise: ["greek yogurt", "sour cream", "avocado mashed"],
        mustard: ["horseradish", "wasabi", "mayonnaise + vinegar"],
        garlic: ["garlic powder (1/8 tsp per clove)", "shallots", "onion"],
        onion: ["shallots", "leeks", "onion powder (1 tbsp = 1 onion)"],
        parsley: ["cilantro", "basil", "chervil"],
        cilantro: ["parsley", "basil", "mint"],
        basil: ["oregano", "thyme", "parsley + mint"],
        thyme: ["oregano", "marjoram", "basil"],
        oregano: ["thyme", "marjoram", "basil"],
        cumin: ["chili powder", "caraway seeds"],
        cinnamon: ["nutmeg", "allspice", "cardamom"],
        "baking powder": ["baking soda (1/4 tsp) + cream of tartar (1/2 tsp)"],
        "baking soda": ["baking powder (3x the amount)"],
        cornstarch: [
          "flour (2 tbsp per 1 tbsp)",
          "arrowroot powder",
          "tapioca starch",
        ],
        "chocolate chips": [
          "chopped chocolate bar",
          "cocoa powder + butter + sugar",
        ],
        "cocoa powder": ["melted chocolate (reduce fat in recipe)"],
        "vanilla extract": ["vanilla bean", "almond extract", "maple syrup"],
        buttermilk: ["milk + lemon juice (1 tbsp per cup)", "milk + vinegar"],
        "cream cheese": [
          "mascarpone",
          "ricotta blended smooth",
          "cottage cheese blended",
        ],
        ricotta: ["cottage cheese", "cream cheese", "tofu blended"],
        parmesan: [
          "pecorino romano",
          "asiago",
          "grana padano",
          "nutritional yeast",
        ],
        mozzarella: ["provolone", "monterey jack", "white cheddar"],
        beef: [
          "ground turkey",
          "ground pork",
          "plant-based meat",
          "lentils cooked",
        ],
        chicken: ["turkey", "pork", "tofu", "tempeh"],
        bacon: ["turkey bacon", "ham", "smoked paprika (for flavor)"],
        anchovies: ["worcestershire sauce", "soy sauce", "miso paste"],
        capers: ["chopped green olives", "chopped pickles"],
      };

      // Helper to find substitutions for an ingredient
      const findSubstitutions = (ingredient) => {
        if (!ingredient) return [];
        const normalized = normalizeIngredient(ingredient).toLowerCase();

        for (const [key, subs] of Object.entries(INGREDIENT_SUBSTITUTIONS)) {
          if (normalized.includes(key) || key.includes(normalized)) {
            return subs;
          }
        }
        return [];
      };

      const capitalizeFirstLetter = (string) => {
        if (!string) return "";
        return string.charAt(0).toUpperCase() + string.slice(1);
      };

      // Format quantity for display with fractions
      const formatQuantity = (quantity) => {
        if (!quantity && quantity !== 0) return "";
        const num = parseFloat(quantity);
        if (isNaN(num)) return quantity.toString();

        // Check if it's a whole number
        if (Math.abs(num - Math.round(num)) < 0.001) {
          return Math.round(num).toString();
        }

        // Check for common fractions
        const fractions = {
          0.25: "¬º",
          0.33: "‚Öì",
          0.5: "¬Ω",
          0.67: "‚Öî",
          0.75: "¬æ",
        };

        const whole = Math.floor(num);
        const decimal = num - whole;

        // Check if decimal matches a common fraction
        for (const [dec, frac] of Object.entries(fractions)) {
          if (Math.abs(decimal - parseFloat(dec)) < 0.05) {
            return whole > 0 ? `${whole} ${frac}` : frac;
          }
        }

        // Otherwise return rounded to 2 decimal places
        return num.toFixed(2).replace(/\.?0+$/, "");
      };

      const SAMPLE_RECIPES = [
        {
          id: "1",
          name: "Classic Spaghetti Bolognese",
          description:
            "A rich and hearty meat sauce simmered slowly and served over pasta. Comfort food at its best.",
          type: "Dinner",
          cuisine: "Italian",
          dietaryTypes: ["Dairy-Free"],
          tags: ["Weeknight", "Comfort Food"],
          prepTime: 20,
          cookTime: 40,
          additionalTime: 0,
          calories: 650,
          protein: 32,
          carbs: 78,
          fat: 22,
          servings: 4,
          yield: "4 servings",
          ingredients: [
            "1 lb ground beef",
            "1 onion, diced",
            "3 cloves garlic, minced",
            "2 cans (14 oz each) crushed tomatoes",
            "1 lb spaghetti",
            "2 tbsp olive oil",
            "Salt and Pepper to taste",
            "Fresh basil for garnish",
          ],
          directions: [
            "Heat olive oil in a large pot over medium heat.",
            "Add onions and garlic, saut√© until translucent.",
            "Add ground beef and cook until browned.",
            "Pour in crushed tomatoes and seasonings.",
            "Simmer for 30 minutes.",
            "Cook spaghetti according to package directions.",
            "Serve sauce over pasta with fresh basil.",
          ],
          tipsAndTricks: [
            "For a vegetarian version, substitute ground beef with lentils or mushrooms.",
            "Add a splash of red wine to the sauce for extra depth of flavor.",
          ],
          createdAt: new Date(Date.now() - 86400000 * 2).toISOString(),
          isFavorite: false,
          image: null,
          video: null,
        },
        {
          id: "2",
          name: "Quick Garden Salad",
          description:
            "A light and refreshing salad, perfect for a quick lunch or side dish. Easily customizable.",
          type: "Lunch",
          cuisine: "American",
          dietaryTypes: ["Vegan", "Gluten-Free"],
          tags: ["Quick", "Healthy", "Vegan"],
          prepTime: 15,
          cookTime: 0,
          additionalTime: 0,
          calories: 200,
          protein: 5,
          carbs: 20,
          fat: 12,
          servings: 2,
          yield: "1 large bowl",
          ingredients: [
            "2 cups mixed greens",
            "1 tomato, diced",
            "1/2 red onion, sliced",
            "1 cucumber, sliced",
            "2 tbsp olive oil",
            "1 tbsp balsamic vinegar",
            "Salt and pepper to taste",
          ],
          directions: [
            "Combine greens, tomato, onion, and cucumber in a bowl.",
            "Drizzle with olive oil and balsamic vinegar.",
            "Season with salt and pepper.",
            "Toss and serve immediately.",
          ],
          tipsAndTricks: [
            "Add some toasted nuts or seeds for extra crunch and protein.",
            "For a creamier dressing, mix in a teaspoon of Dijon mustard.",
          ],
          createdAt: new Date(Date.now() - 86400000).toISOString(),
          isFavorite: true,
          image: null,
          video: null,
        },
        {
          id: "3",
          name: "Simple Beef Burgers",
          description:
            "Juicy, classic beef burgers perfect for grilling or pan-frying. A crowd-pleaser for any occasion.",
          type: "Dinner",
          cuisine: "American",
          dietaryTypes: [],
          tags: ["Grill", "Quick", "Kid-Friendly"],
          prepTime: 10,
          cookTime: 15,
          additionalTime: 5,
          calories: 550,
          protein: 30,
          carbs: 35,
          fat: 30,
          servings: 4,
          yield: "4 burgers",
          ingredients: [
            "1 lb ground beef",
            "1 tsp garlic powder",
            "1/2 tsp salt",
            "1/4 tsp black pepper",
            "4 burger buns",
            "Lettuce, tomato, onion slices (optional toppings)",
            "3 cloves garlic",
          ],
          directions: [
            "Preheat grill or pan.",
            "Gently mix ground beef, garlic powder, salt, and pepper. Do not overmix.",
            "Form into 4 patties.",
            "Grill or pan-fry for 4-6 minutes per side for medium, or longer depending on desired doneness.",
            "Let rest for 5 minutes.",
            "Serve on buns with desired toppings.",
          ],
          tipsAndTricks: [
            "For juicier burgers, mix in 1/4 cup of grated onion or breadcrumbs soaked in milk.",
            "Make a small indentation in the center of each patty before cooking to prevent bulging.",
          ],
          createdAt: new Date().toISOString(),
          isFavorite: false,
          image: null,
          video: null,
        },
      ];

      // --- React Components (App, Modals, etc.) ---

      const usePersistentStorage = (storeName, initialValue, addToast) => {
        const [storedValue, setStoredValue] = useState(initialValue);
        const [isLoading, setIsLoading] = useState(true);
        const isMounted = useRef(true);
        const storedValueRef = useRef(storedValue);
        useEffect(() => {
          storedValueRef.current = storedValue;
        }, [storedValue]);

        useEffect(() => {
          const loadData = async () => {
            if (!isMounted.current) return;
            setIsLoading(true);
            try {
              // First, check if IndexedDB already has data - if so, skip migration
              let existingDataCheck;
              if (storeName === STORE_NAMES.MEAL_PLAN) {
                try {
                  const store = await getStore(storeName, "readonly");
                  const req = store.get(storeName);
                  const mealPlanObj = await new Promise((resolve, reject) => {
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                  });
                  existingDataCheck = mealPlanObj ? true : false;
                } catch (error) {
                  existingDataCheck = false;
                }
              } else {
                const items = await getAllItems(storeName);
                existingDataCheck = Array.isArray(items) && items.length > 0;
              }

              // Only attempt migration if IndexedDB is empty
              const localStorageItem = localStorage.getItem(storeName);
              if (localStorageItem && !existingDataCheck) {
                console.log(
                  `[${storeName}] Attempting migration from localStorage...`,
                );
                try {
                  const parsedLocalStorageData = JSON.parse(localStorageItem);

                  let dataToMigrate = parsedLocalStorageData;
                  if (storeName === STORE_NAMES.MEAL_PLAN) {
                    const days = [
                      "Sunday",
                      "Monday",
                      "Tuesday",
                      "Wednesday",
                      "Thursday",
                      "Friday",
                      "Saturday",
                    ];
                    const mealTimes = [
                      "breakfast",
                      "morningSnack",
                      "lunch",
                      "afternoonSnack",
                      "dinner",
                    ];
                    const migratedMealPlan = {};
                    days.forEach((day) => {
                      migratedMealPlan[day] = migratedMealPlan[day] || {};
                      mealTimes.forEach((mealTime) => {
                        const existingValue =
                          parsedLocalStorageData[day]?.[mealTime];
                        if (Array.isArray(existingValue)) {
                          migratedMealPlan[day][mealTime] = existingValue;
                        } else if (existingValue) {
                          migratedMealPlan[day][mealTime] = [existingValue];
                        } else {
                          migratedMealPlan[day][mealTime] = [];
                        }
                      });
                    });
                    dataToMigrate = migratedMealPlan;
                  } else if (
                    storeName === STORE_NAMES.RECIPES &&
                    Array.isArray(parsedLocalStorageData)
                  ) {
                    dataToMigrate = parsedLocalStorageData.map((recipe) => ({
                      ...recipe,
                      tags: recipe.tags || [],
                      description: recipe.description || "",
                      cuisine: recipe.cuisine || "",
                      dietaryTypes: recipe.dietaryTypes || [],
                      ingredients: recipe.ingredients || [],
                      directions: recipe.directions || [],
                      tipsAndTricks: recipe.tipsAndTricks || [],
                      yield: recipe.yield || "",
                    }));
                  }

                  if (Array.isArray(dataToMigrate)) {
                    for (const item of dataToMigrate) {
                      await addItem(storeName, item);
                    }
                  } else if (
                    typeof dataToMigrate === "object" &&
                    dataToMigrate !== null
                  ) {
                    try {
                      await updateItem(storeName, storeName, {
                        id: storeName,
                        data: dataToMigrate,
                      });
                    } catch (updateError) {
                      console.warn(
                        `updateItem failed for ${storeName}, trying addItem:`,
                        updateError,
                      );
                      try {
                        await addItem(storeName, {
                          id: storeName,
                          data: dataToMigrate,
                        });
                      } catch (addError) {
                        console.error(
                          `Both updateItem and addItem failed for ${storeName}:`,
                          addError,
                        );
                        throw addError;
                      }
                    }
                  }

                  localStorage.removeItem(storeName);
                  console.log(
                    `[${storeName}] Migration completed successfully`,
                  );
                  addToast(
                    `Migrated ${storeName} data from localStorage to IndexedDB!`,
                    "info",
                  );
                } catch (migrationError) {
                  console.error(
                    `Error migrating ${storeName} from localStorage:`,
                    migrationError,
                  );
                }
              } else if (existingDataCheck) {
                console.log(
                  `[${storeName}] Skipping migration - IndexedDB already has data`,
                );
              }

              let dataFromIndexedDB;
              if (storeName === STORE_NAMES.MEAL_PLAN) {
                try {
                  const store = await getStore(storeName, "readonly");
                  const req = store.get(storeName);
                  const mealPlanObj = await new Promise((resolve, reject) => {
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                  });
                  dataFromIndexedDB = mealPlanObj ? mealPlanObj.data : null;
                } catch (error) {
                  console.error(
                    "Error loading meal plan from IndexedDB:",
                    error,
                  );
                  dataFromIndexedDB = null;
                }

                if (!dataFromIndexedDB) {
                  dataFromIndexedDB = {};
                }
                const days = [
                  "Sunday",
                  "Monday",
                  "Tuesday",
                  "Wednesday",
                  "Thursday",
                  "Friday",
                  "Saturday",
                ];
                const mealTimes = [
                  "breakfast",
                  "morningSnack",
                  "lunch",
                  "afternoonSnack",
                  "dinner",
                ];
                const structuredPlan = {};
                days.forEach((day) => {
                  structuredPlan[day] = structuredPlan[day] || {};
                  mealTimes.forEach((mealTime) => {
                    const existingValue = dataFromIndexedDB[day]?.[mealTime];
                    if (Array.isArray(existingValue)) {
                      structuredPlan[day][mealTime] = existingValue;
                    } else if (existingValue) {
                      structuredPlan[day][mealTime] = [existingValue];
                    } else {
                      structuredPlan[day][mealTime] = [];
                    }
                  });
                });
                dataFromIndexedDB = structuredPlan;
              } else {
                dataFromIndexedDB = await getAllItems(storeName);
                console.log(
                  `[${storeName}] Loaded ${Array.isArray(dataFromIndexedDB) ? dataFromIndexedDB.length : "N/A"} items from IndexedDB`,
                );

                if (
                  storeName === STORE_NAMES.RECIPES &&
                  Array.isArray(dataFromIndexedDB)
                ) {
                  dataFromIndexedDB = dataFromIndexedDB.map((recipe) => ({
                    ...recipe,
                    tags: recipe.tags || [],
                    description: recipe.description || "",
                    cuisine: recipe.cuisine || "",
                    dietaryTypes: recipe.dietaryTypes || [],
                    ingredients: recipe.ingredients || [],
                    directions: recipe.directions || [],
                    tipsAndTricks: recipe.tipsAndTricks || [],
                    yield: recipe.yield || "",
                  }));
                }

                // If IndexedDB returned no items, attempt to restore from a localStorage backup
                try {
                  if (
                    Array.isArray(dataFromIndexedDB) &&
                    dataFromIndexedDB.length === 0
                  ) {
                    console.log(
                      `[${storeName}] IndexedDB empty, checking localStorage backup...`,
                    );
                    const backupRaw = localStorage.getItem(storeName);
                    if (backupRaw) {
                      const backup = JSON.parse(backupRaw);
                      console.log(
                        `[${storeName}] Found localStorage backup with ${backup.length} items`,
                      );
                      if (Array.isArray(backup) && backup.length > 0) {
                        let restoredCount = 0;
                        for (const originalItem of backup) {
                          const item = { ...originalItem };
                          if (!item.id)
                            item.id =
                              Date.now().toString(36) +
                              Math.random().toString(36).substr(2, 5);
                          try {
                            await addItem(storeName, item);
                            restoredCount++;
                          } catch (err) {
                            try {
                              await updateItem(storeName, item.id, item);
                              restoredCount++;
                            } catch (err2) {
                              console.warn(
                                `Failed to restore item ${item.id}:`,
                                err2,
                              );
                            }
                          }
                        }

                        const reloaded = await getAllItems(storeName);
                        console.log(
                          `[${storeName}] After restore: ${reloaded.length} items in IndexedDB`,
                        );
                        if (Array.isArray(reloaded) && reloaded.length > 0) {
                          dataFromIndexedDB = reloaded;
                          addToast(
                            `Restored ${restoredCount} ${storeName} items from backup.`,
                            "success",
                          );
                        }
                      }
                    } else {
                      console.log(
                        `[${storeName}] No localStorage backup found`,
                      );
                    }
                  }
                } catch (restoreErr) {
                  console.warn(
                    `Restore from local backup failed for ${storeName}:`,
                    restoreErr,
                  );
                }
              }

              setStoredValue(
                dataFromIndexedDB.length > 0 ||
                  (storeName === STORE_NAMES.MEAL_PLAN &&
                    Object.keys(dataFromIndexedDB).length > 0)
                  ? dataFromIndexedDB
                  : initialValue,
              );
              console.log(
                `[${storeName}] State set with ${Array.isArray(dataFromIndexedDB) ? dataFromIndexedDB.length : "N/A"} items`,
              );
            } catch (error) {
              console.error(
                `Error loading data from IndexedDB for ${storeName}:`,
                error,
              );
              addToast(`Error loading ${storeName} data.`, "error");
              setStoredValue(initialValue);
            } finally {
              if (isMounted.current) {
                setIsLoading(false);
              }
            }
          };

          loadData();

          return () => {
            isMounted.current = false;
          };
        }, [storeName, addToast]);

        const setValue = useCallback(
          async (value) => {
            const valueToStore =
              value instanceof Function ? value(storedValueRef.current) : value;

            console.log(
              `[${storeName}] setValue called with ${Array.isArray(valueToStore) ? valueToStore.length : "N/A"} items`,
            );

            setStoredValue(valueToStore);
            // update ref immediately to avoid races with concurrent updates
            storedValueRef.current = valueToStore;

            try {
              if (storeName === STORE_NAMES.MEAL_PLAN) {
                try {
                  await updateItem(storeName, storeName, {
                    id: storeName,
                    data: valueToStore,
                  });
                  console.log(`[${storeName}] Meal plan saved successfully`);
                } catch (updateError) {
                  console.warn(
                    `updateItem failed for ${storeName}, trying addItem:`,
                    updateError,
                  );
                  await addItem(storeName, {
                    id: storeName,
                    data: valueToStore,
                  });
                  console.log(`[${storeName}] Meal plan added successfully`);
                }
              } else {
                console.log(`[${storeName}] Clearing store...`);
                await clearStore(storeName);
                console.log(
                  `[${storeName}] Store cleared, adding ${Array.isArray(valueToStore) ? valueToStore.length : 0} items...`,
                );

                if (Array.isArray(valueToStore)) {
                  let successCount = 0;
                  for (const originalItem of valueToStore) {
                    // Ensure each pantry/store item has a stable id
                    const item = { ...originalItem };
                    if (!item.id) {
                      item.id =
                        Date.now().toString(36) +
                        Math.random().toString(36).substr(2, 5);
                    }

                    try {
                      await addItem(storeName, item);
                      successCount++;
                    } catch (addErr) {
                      // If add fails (e.g., duplicate key), try updating instead
                      try {
                        await updateItem(storeName, item.id, item);
                        successCount++;
                      } catch (updateErr) {
                        // As a last resort, try adding with a new id
                        try {
                          item.id =
                            Date.now().toString(36) +
                            Math.random().toString(36).substr(2, 5);
                          await addItem(storeName, item);
                          successCount++;
                        } catch (finalErr) {
                          console.error(
                            `Failed to persist item ${item.id} in ${storeName}:`,
                            finalErr,
                          );
                          // For pantry, avoid showing repeated toasts; but log and continue
                          if (storeName !== STORE_NAMES.PANTRY) {
                            addToast(
                              `Failed to save item ${item.id} to ${storeName}.`,
                              "error",
                            );
                          }
                        }
                      }
                    }
                  }
                  console.log(
                    `[${storeName}] Successfully saved ${successCount}/${valueToStore.length} items to IndexedDB`,
                  );

                  // Verify the save by reading back
                  const verifyData = await getAllItems(storeName);
                  console.log(
                    `[${storeName}] Verification: ${verifyData.length} items in IndexedDB after save`,
                  );

                  if (successCount > 0) {
                    addToast(
                      `Saved ${successCount} items to ${storeName}`,
                      "success",
                    );
                  }
                }

                // Also keep a localStorage backup copy for quick restoration if IndexedDB fails
                try {
                  localStorage.setItem(storeName, JSON.stringify(valueToStore));
                  console.log(`[${storeName}] localStorage backup saved`);
                } catch (lsErr) {
                  console.warn(
                    `Failed to write backup to localStorage for ${storeName}:`,
                    lsErr,
                  );
                }
              }
            } catch (error) {
              console.error(
                `Error saving data to IndexedDB for ${storeName}:`,
                error,
              );
              // Only show error toast for non-pantry stores
              if (storeName !== STORE_NAMES.PANTRY) {
                addToast(`Failed to save ${storeName} data.`, "error");
              }
            }
          },
          [storeName, addToast],
        );

        return [storedValue, setValue, isLoading];
      };

      const Toast = ({ message, type, onClose }) => {
        useEffect(() => {
          const timer = setTimeout(onClose, 3000);
          return () => clearTimeout(timer);
        }, [onClose]);

        const bgColor =
          type === "success"
            ? "bg-green-500"
            : type === "error"
              ? "bg-red-500"
              : "bg-blue-500";

        return (
          <div
            className={`p-3 rounded-lg shadow-lg text-white text-sm ${bgColor} animate-fade-in-out`}
          >
            {message}
          </div>
        );
      };

      // --- Smart Cooking Hooks & Components ---
      const useTimers = (addToast) => {
        const [timers, setTimers] = useState([]);
        const audioContextRef = useRef(null);
        const timerIntervalRef = useRef(null);

        const playSound = useCallback(() => {
          if (!audioContextRef.current) {
            audioContextRef.current = new (
              window.AudioContext || window.webkitAudioContext
            )();
          }
          const oscillator = audioContextRef.current.createOscillator();
          const gainNode = audioContextRef.current.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContextRef.current.destination);
          oscillator.type = "sine";
          oscillator.frequency.setValueAtTime(
            880,
            audioContextRef.current.currentTime,
          );
          gainNode.gain.setValueAtTime(
            0.5,
            audioContextRef.current.currentTime,
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.0001,
            audioContextRef.current.currentTime + 1,
          );
          oscillator.start(audioContextRef.current.currentTime);
          oscillator.stop(audioContextRef.current.currentTime + 1);
        }, []);

        useEffect(() => {
          timerIntervalRef.current = setInterval(() => {
            setTimers((prevTimers) => {
              if (prevTimers.length === 0) return prevTimers;

              const updatedTimers = prevTimers.map((timer) => {
                if (timer.isRunning && timer.remaining > 0) {
                  const newRemaining = timer.remaining - 1;
                  if (newRemaining <= 0) {
                    playSound();
                    addToast(`Timer "${timer.name}" is done!`, "success");
                    return { ...timer, remaining: 0, isRunning: false };
                  }
                  return { ...timer, remaining: newRemaining };
                }
                return timer;
              });
              // Filter out timers that are finished for more than 5 minutes
              return updatedTimers.filter(
                (t) =>
                  t.isRunning ||
                  t.remaining > 0 ||
                  Date.now() - t.finishedAt < 300000,
              );
            });
          }, 1000);

          return () => clearInterval(timerIntervalRef.current);
        }, [playSound, addToast]);

        const addTimer = useCallback(
          (durationInSeconds, name) => {
            setTimers((prev) => [
              ...prev,
              {
                id: Date.now(),
                name,
                duration: durationInSeconds,
                remaining: durationInSeconds,
                isRunning: true,
                finishedAt: null,
              },
            ]);
            addToast(`Timer "${name}" started!`, "info");
          },
          [addToast],
        );

        const toggleTimer = useCallback((id) => {
          setTimers((prev) =>
            prev.map((t) =>
              t.id === id ? { ...t, isRunning: !t.isRunning } : t,
            ),
          );
        }, []);

        const removeTimer = useCallback((id) => {
          setTimers((prev) => prev.filter((t) => t.id !== id));
        }, []);

        const resetTimer = useCallback((id) => {
          setTimers((prev) =>
            prev.map((t) =>
              t.id === id
                ? { ...t, remaining: t.duration, isRunning: true }
                : t,
            ),
          );
        }, []);

        return { timers, addTimer, toggleTimer, removeTimer, resetTimer };
      };

      const TimerTray = ({ timers, onToggle, onRemove, onReset }) => {
        if (timers.length === 0) return null;

        const formatTime = (seconds) => {
          const h = Math.floor(seconds / 3600)
            .toString()
            .padStart(2, "0");
          const m = Math.floor((seconds % 3600) / 60)
            .toString()
            .padStart(2, "0");
          const s = (seconds % 60).toString().padStart(2, "0");
          return `${h}:${m}:${s}`;
        };

        return (
          <div className="fixed bottom-0 right-0 p-4 space-y-2 z-[999]">
            {timers.map((timer) => (
              <div
                key={timer.id}
                className={`bg-white dark:bg-gray-700 p-3 rounded-lg shadow-lg w-64 border-l-4 ${
                  timer.remaining <= 0 ? "border-green-500" : "border-blue-500"
                }`}
              >
                <div className="flex justify-between items-center">
                  <p
                    className="text-sm font-semibold text-gray-800 dark:text-gray-200 truncate pr-2"
                    title={timer.name}
                  >
                    {timer.name}
                  </p>
                  <button
                    onClick={() => onRemove(timer.id)}
                    className="text-gray-400 hover:text-red-500 text-xs"
                  >
                    &times;
                  </button>
                </div>
                <p
                  className={`text-2xl font-mono my-1 ${
                    timer.remaining <= 0
                      ? "text-green-500"
                      : "text-gray-900 dark:text-gray-100"
                  }`}
                >
                  {formatTime(timer.remaining)}
                </p>
                <div className="flex items-center gap-2 text-xs">
                  <button
                    onClick={() => onToggle(timer.id)}
                    className="btn-modal btn-gray text-xs"
                  >
                    <i
                      className={`fas ${
                        timer.isRunning ? "fa-pause" : "fa-play"
                      } mr-1`}
                    ></i>
                    {timer.isRunning ? "Pause" : "Resume"}
                  </button>
                  <button
                    onClick={() => onReset(timer.id)}
                    className="btn-modal btn-gray text-xs"
                  >
                    <i className="fas fa-redo mr-1"></i>
                    Reset
                  </button>
                </div>
              </div>
            ))}
          </div>
        );
      };

      const App = () => {
        // Listen for openRecipeDetailsFromPantry event to open recipe details modal
        useEffect(() => {
          const handler = (e) => {
            if (e.detail && e.detail.recipeId) {
              const recipeId = e.detail.recipeId;
              let found = recipes.find((r) => r.id === recipeId);
              // Only use pantry fallback if it has recipe fields
              if (!found && Array.isArray(pantry)) {
                const pantryCandidate = pantry.find((r) => r.id === recipeId);
                if (
                  pantryCandidate &&
                  pantryCandidate.name &&
                  Array.isArray(pantryCandidate.ingredients) &&
                  Array.isArray(pantryCandidate.directions)
                ) {
                  found = pantryCandidate;
                }
              }
              if (
                found &&
                found.name &&
                Array.isArray(found.ingredients) &&
                Array.isArray(found.directions)
              ) {
                setShowRecipeDetails(found);
                setShowPantryModal(false);
              }
            }
          };
          window.addEventListener("openRecipeDetailsFromPantry", handler);
          return () =>
            window.removeEventListener("openRecipeDetailsFromPantry", handler);
        }, [recipes]);

        // Listen for openCollections event
        useEffect(() => {
          const handler = () => {
            setShowCollectionsModal(true);
          };
          document.addEventListener("openCollections", handler);
          return () => document.removeEventListener("openCollections", handler);
        }, []);

        const [toasts, setToasts] = useState([]);

        const addToast = useCallback((message, type = "info") => {
          const newToast = { id: Date.now(), message, type };
          setToasts((prevToasts) => [...prevToasts, newToast]);
          setTimeout(() => removeToast(newToast.id), 3000);
        }, []);

        const removeToast = useCallback((id) => {
          setToasts((prevToasts) =>
            prevToasts.filter((toast) => toast.id !== id),
          );
        }, []);

        const [recipes, setRecipes, isLoadingRecipes] = usePersistentStorage(
          STORE_NAMES.RECIPES,
          SAMPLE_RECIPES.map((r) => ({
            ...r,
            tags: r.tags || [],
            description: r.description || "",
            cuisine: r.cuisine || "",
            dietaryTypes: r.dietaryTypes || [],
            ingredients: r.ingredients || [],
            directions: r.directions || [],
            tipsAndTricks: r.tipsAndTricks || [],
            yield: r.yield || "",
          })),
          addToast,
        );
        const [mealPlan, setMealPlan, isLoadingMealPlan] = usePersistentStorage(
          STORE_NAMES.MEAL_PLAN,
          {},
          addToast,
        );
        const [shoppingList, setShoppingList, isLoadingShoppingList] =
          usePersistentStorage(STORE_NAMES.SHOPPING_LIST, [], addToast);

        // Pantry persistent storage
        const [pantry, setPantry, isLoadingPantry] = usePersistentStorage(
          STORE_NAMES.PANTRY,
          [],
          addToast,
        );

        // Recipe Collections persistent storage
        const [collections, setCollections, isLoadingCollections] =
          usePersistentStorage(STORE_NAMES.COLLECTIONS, [], addToast);

        const [isDarkMode, setIsDarkMode] = useState(() => {
          return (
            typeof window.matchMedia === "function" &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
          );
        });
        const [showAddRecipeModal, setShowAddRecipeModal] = useState(false);
        const [showPantryModal, setShowPantryModal] = useState(false);
        const [showRecipeDetails, setShowRecipeDetails] = useState(null);
        const [showMealPlanModal, setShowMealPlanModal] = useState(false);
        const [showShoppingListModal, setShowShoppingListModal] =
          useState(false);
        const [editingRecipe, setEditingRecipe] = useState(null);
        const [showRecipeSuggestions, setShowRecipeSuggestions] =
          useState(false);
        const [showCollectionsModal, setShowCollectionsModal] = useState(false);
        const [selectedCollection, setSelectedCollection] = useState(null);
        const [
          showAddRecipesToCollectionModal,
          setShowAddRecipesToCollectionModal,
        ] = useState(null);

        const [displayUnitSystem, setDisplayUnitSystem] = useState("imperial");

        // Fallback convertUnits function if not implemented
        const convertUnits = useCallback((quantity, unit, system) => {
          return { value: quantity, unit };
        }, []);

        // Smart features state
        const { timers, addTimer, toggleTimer, removeTimer, resetTimer } =
          useTimers(addToast);

        const isLoading =
          isLoadingRecipes || isLoadingMealPlan || isLoadingShoppingList;

        useEffect(() => {
          const root = window.document.documentElement;
          if (isDarkMode) {
            root.classList.add("dark");
          } else {
            root.classList.remove("dark");
          }

          const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
          const handleChange = (e) => setIsDarkMode(e.matches);
          mediaQuery.addEventListener("change", handleChange);

          return () => mediaQuery.removeEventListener("change", handleChange);
        }, [isDarkMode]);

        // Listen for add recipes to collection event
        useEffect(() => {
          const handleAddRecipesToCollection = (e) => {
            const collectionId = e.detail?.collectionId;
            if (collectionId) {
              const collection = collections.find((c) => c.id === collectionId);
              if (collection) {
                setShowAddRecipesToCollectionModal(collection);
              }
            }
          };

          document.addEventListener(
            "addRecipesToCollection",
            handleAddRecipesToCollection,
          );
          return () =>
            document.removeEventListener(
              "addRecipesToCollection",
              handleAddRecipesToCollection,
            );
        }, [collections]);

        useEffect(() => {
          const body = document.body;
          const isModalOpen =
            showAddRecipeModal ||
            !!showRecipeDetails ||
            showMealPlanModal ||
            showShoppingListModal;

          if (isModalOpen) {
            body.classList.add("modal-open");
          } else {
            body.classList.remove("modal-open");
          }
          return () => body.classList.remove("modal-open");
        }, [
          showAddRecipeModal,
          showRecipeDetails,
          showMealPlanModal,
          showShoppingListModal,
        ]);

        const exportRecipes = useCallback(async () => {
          try {
            const allRecipes = await getAllItems(STORE_NAMES.RECIPES);
            if (!Array.isArray(allRecipes) || allRecipes.length === 0) {
              throw new Error("No recipes found to export");
            }

            const dataStr = JSON.stringify(allRecipes, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });

            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "my-recipes.json";

            if (document.body) {
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
            } else {
              throw new Error("Document body not available");
            }

            URL.revokeObjectURL(url);
            addToast("Recipes exported successfully!", "success");
          } catch (err) {
            console.error("Export error:", err);
            addToast(`Error exporting recipes: ${err.message}`, "error");
          }
        }, [addToast]);

        const deleteAllRecipes = useCallback(async () => {
          if (
            !window.confirm(
              "Are you sure you want to delete ALL recipes, meal plans, and shopping list? This cannot be undone!",
            )
          ) {
            return;
          }
          try {
            await clearStore(STORE_NAMES.RECIPES);
            await clearStore(STORE_NAMES.MEAL_PLAN);
            await clearStore(STORE_NAMES.SHOPPING_LIST);
            setRecipes([]);
            setMealPlan({});
            setShoppingList([]);
            addToast(
              "All recipes and related data have been deleted.",
              "success",
            );
          } catch (error) {
            console.error("Error deleting all data:", error);
            addToast("Failed to delete all data.", "error");
          }
        }, [setRecipes, setMealPlan, setShoppingList, addToast]);

        const addRecipe = useCallback(
          async (recipeData) => {
            const newRecipe = {
              id:
                Date.now().toString(36) +
                Math.random().toString(36).substr(2, 5),
              ...recipeData,
              description: recipeData.description || "",
              cuisine: recipeData.cuisine || "",
              tags: recipeData.tags || [],
              dietaryTypes: recipeData.dietaryTypes || [],
              ingredients: recipeData.ingredients || [],
              directions: recipeData.directions || [],
              tipsAndTricks: recipeData.tipsAndTricks || [],
              yield: recipeData.yield || "",
              createdAt: new Date().toISOString(),
              isFavorite: false,
            };
            try {
              await addItem(STORE_NAMES.RECIPES, newRecipe);
              setRecipes((prev) => [...prev, newRecipe]);
              setShowAddRecipeModal(false);
              setEditingRecipe(null);
              addToast("Recipe added!", "success");
            } catch (error) {
              console.error("Error adding recipe:", error);
              addToast("Failed to add recipe.", "error");
            }
          },
          [setRecipes, addToast],
        );

        const updateRecipe = useCallback(
          async (id, recipeData) => {
            const updatedRecipe = {
              ...recipeData,
              id: id,
              updatedAt: new Date().toISOString(),
            };
            try {
              await updateItem(STORE_NAMES.RECIPES, id, updatedRecipe);
              setRecipes((prev) =>
                prev.map((r) => (r.id === id ? updatedRecipe : r)),
              );
              setShowAddRecipeModal(false);
              setEditingRecipe(null);
              addToast("Recipe updated!", "success");
            } catch (error) {
              console.error("Error updating recipe:", error);
              addToast("Failed to update recipe.", "error");
            }
          },
          [setRecipes, addToast],
        );

        const deleteRecipe = useCallback(
          async (id) => {
            if (
              !window.confirm(
                "Are you sure you want to delete this recipe permanently?",
              )
            )
              return;

            try {
              await deleteItem(STORE_NAMES.RECIPES, id);
              setRecipes((prev) => prev.filter((r) => r.id !== id));

              setMealPlan((prev) => {
                const newPlan = JSON.parse(JSON.stringify(prev));
                let changed = false;
                Object.keys(newPlan).forEach((day) => {
                  if (newPlan[day] && typeof newPlan[day] === "object") {
                    Object.keys(newPlan[day]).forEach((mealTime) => {
                      const currentRecipesInSlot = newPlan[day][mealTime] || [];
                      const updatedRecipesInSlot = currentRecipesInSlot.filter(
                        (recipeId) => recipeId !== id,
                      );
                      if (
                        updatedRecipesInSlot.length !==
                        currentRecipesInSlot.length
                      ) {
                        newPlan[day][mealTime] = updatedRecipesInSlot;
                        changed = true;
                      }
                    });
                  }
                });
                return changed ? newPlan : prev;
              });

              setShoppingList((prev) =>
                prev.filter((item) => item.recipeId !== id),
              );

              if (showRecipeDetails?.id === id) setShowRecipeDetails(null);
              addToast("Recipe deleted.", "success");
            } catch (error) {
              console.error("Error deleting recipe:", error);
              addToast("Failed to delete recipe.", "error");
            }
          },
          [
            setRecipes,
            setMealPlan,
            setShoppingList,
            addToast,
            showRecipeDetails,
          ],
        );

        const toggleFavorite = useCallback(
          async (id) => {
            let isNowFavorite = false;
            const recipeToUpdate = recipes.find((r) => r.id === id);
            if (!recipeToUpdate) return;

            isNowFavorite = !recipeToUpdate.isFavorite;
            const updatedRecipe = {
              ...recipeToUpdate,
              isFavorite: isNowFavorite,
            };

            try {
              await updateItem(STORE_NAMES.RECIPES, id, updatedRecipe);
              setRecipes((prev) =>
                prev.map((r) => (r.id === id ? updatedRecipe : r)),
              );
              addToast(
                isNowFavorite ? "Added to Favorites" : "Removed from Favorites",
                "success",
              );
            } catch (error) {
              console.error("Error toggling favorite:", error);
              addToast("Failed to update favorite status.", "error");
            }
          },
          [recipes, setRecipes, addToast],
        );

        const searchRecipes = useCallback(
          (query, filters) => {
            filters = filters || {};
            const normalizedQuery = query ? query.toLowerCase().trim() : "";

            return recipes.filter((recipe) => {
              if (!recipe || typeof recipe.name !== "string") return false;

              let matchesQuery = !normalizedQuery;
              if (normalizedQuery) {
                const nameMatch = recipe.name
                  .toLowerCase()
                  .includes(normalizedQuery);
                const typeMatch = recipe.type
                  ?.toLowerCase()
                  .includes(normalizedQuery);
                matchesQuery = nameMatch || typeMatch;
              }

              let matchesType = true;
              if (filters.type) {
                if (filters.type === "_NONE_") {
                  matchesType = !recipe.type || recipe.type.trim() === "";
                } else {
                  matchesType = recipe.type === filters.type;
                }
              }

              let matchesCourse = true;
              if (filters.course) {
                if (filters.course === "_NONE_") {
                  matchesCourse = !recipe.course || recipe.course.trim() === "";
                } else {
                  matchesCourse = recipe.course === filters.course;
                }
              }

              let matchesSubCategory = true;
              if (filters.subCategory) {
                if (filters.subCategory === "_NONE_") {
                  matchesSubCategory =
                    !recipe.subCategory || recipe.subCategory.trim() === "";
                } else {
                  matchesSubCategory =
                    recipe.subCategory === filters.subCategory;
                }
              }

              let matchesCuisine = true;
              if (filters.cuisine) {
                if (filters.cuisine === "_NONE_") {
                  matchesCuisine =
                    !recipe.cuisine || recipe.cuisine.trim() === "";
                } else {
                  matchesCuisine = recipe.cuisine === filters.cuisine;
                }
              }

              let matchesDietary = true;
              if (filters.dietaryType) {
                if (filters.dietaryType === "_NONE_") {
                  matchesDietary =
                    !recipe.dietaryTypes || recipe.dietaryTypes.length === 0;
                } else {
                  matchesDietary = recipe.dietaryTypes?.includes(
                    filters.dietaryType,
                  );
                }
              }

              let matchesTag = true;
              if (filters.tag) {
                if (filters.tag === "_NONE_") {
                  matchesTag = !recipe.tags || recipe.tags.length === 0;
                } else {
                  const normalizedTagQuery = filters.tag.toLowerCase().trim();
                  matchesTag = recipe.tags?.some(
                    (tag) => tag.toLowerCase() === normalizedTagQuery,
                  );
                }
              }

              const matchesFavorite = filters.favorites
                ? recipe.isFavorite === true
                : true;

              const totalTime =
                parseInt(recipe.prepTime || 0) +
                parseInt(recipe.cookTime || 0) +
                parseInt(recipe.additionalTime || 0);
              const filterCookTime = filters.cookTime
                ? parseInt(filters.cookTime)
                : Infinity;
              const matchesCookTime = filters.cookTime
                ? totalTime <= filterCookTime
                : true;

              // Filter by collection if specified
              const matchesCollection = filters.collectionRecipeIds
                ? filters.collectionRecipeIds.includes(recipe.id)
                : true;

              return (
                matchesQuery &&
                matchesType &&
                matchesCourse &&
                matchesSubCategory &&
                matchesCuisine &&
                matchesDietary &&
                matchesTag &&
                matchesFavorite &&
                matchesCookTime &&
                matchesCollection
              );
            });
          },
          [recipes],
        );

        const updateMealPlan = useCallback(
          async (day, mealTime, recipeId) => {
            setMealPlan((prev) => {
              const newPlan = { ...prev };
              newPlan[day] = newPlan[day] || {};
              const currentRecipesInSlot = newPlan[day][mealTime] || [];

              if (currentRecipesInSlot.includes(recipeId)) {
                newPlan[day][mealTime] = currentRecipesInSlot.filter(
                  (id) => id !== recipeId,
                );
                addToast("Recipe removed from meal slot.", "info");
              } else {
                newPlan[day][mealTime] = [...currentRecipesInSlot, recipeId];
                addToast("Recipe added to meal slot!", "success");
              }
              return newPlan;
            });
          },
          [setMealPlan, addToast],
        );

        const removeMealFromPlan = useCallback(
          async (day, mealTime, recipeIdToRemove) => {
            setMealPlan((prev) => {
              const newPlan = { ...prev };
              newPlan[day] = newPlan[day] || {};
              const currentRecipesInSlot = newPlan[day][mealTime] || [];
              const updatedRecipesInSlot = currentRecipesInSlot.filter(
                (id) => id !== recipeIdToRemove,
              );
              newPlan[day][mealTime] = updatedRecipesInSlot;
              addToast("Recipe removed from plan.", "success");
              return newPlan;
            });
          },
          [setMealPlan, addToast],
        );

        const addMultipleRecipesToShoppingList = useCallback(
          async (recipeIds) => {
            if (!Array.isArray(recipeIds) || recipeIds.length === 0) return;

            let totalIngredientsAdded = 0;
            const recipeNamesAdded = new Set();

            setShoppingList((prevList) => {
              const newList = [...prevList];

              recipeIds.forEach((recipeId) => {
                const recipe = recipes.find((r) => r.id === recipeId);
                if (
                  !recipe ||
                  !Array.isArray(recipe.ingredients) ||
                  recipe.ingredients.length === 0
                ) {
                  console.warn(
                    `Recipe ${recipeId} not found or has no ingredients.`,
                  );
                  return;
                }
                recipeNamesAdded.add(recipe.name);

                recipe.ingredients
                  .filter((ing) => typeof ing === "string" && ing.trim() !== "")
                  .forEach((ingredient) => {
                    const normalized = normalizeIngredient(ingredient);
                    const { quantity, unit, description } =
                      parseIngredient(ingredient);

                    newList.push({
                      id:
                        Date.now().toString(36) +
                        Math.random().toString(36).substr(2, 5),
                      originalText: ingredient.trim(),
                      quantity: quantity,
                      unit: unit,
                      description: description,
                      recipeId: recipe.id,
                      recipeName: recipe.name,
                      checked: false,
                      normalizedText: normalized,
                    });
                    totalIngredientsAdded++;
                  });
              });

              if (totalIngredientsAdded > 0) {
                addToast(
                  `Added ${totalIngredientsAdded} ingredient(s) from ${recipeNamesAdded.size} recipe(s).`,
                  "success",
                );
              } else if (recipeNamesAdded.size > 0) {
                addToast(
                  "No ingredients to add from selected recipe(s).",
                  "info",
                );
              }
              return newList;
            });
          },
          [recipes, setShoppingList, addToast],
        );

        const addToShoppingList = useCallback(
          (recipeId) => {
            addMultipleRecipesToShoppingList([recipeId]);
          },
          [addMultipleRecipesToShoppingList],
        );

        const toggleShoppingItem = useCallback(
          async (itemId, normalizedTextToToggle) => {
            setShoppingList((prevList) => {
              let targetChecked;
              let targetNormalizedText;

              if (itemId) {
                const clickedItem = prevList.find((item) => item.id === itemId);
                if (!clickedItem) return prevList;
                targetChecked = !clickedItem.checked;
                targetNormalizedText = clickedItem.normalizedText;
              } else if (normalizedTextToToggle) {
                const groupItems = prevList.filter(
                  (item) => item.normalizedText === normalizedTextToToggle,
                );
                if (groupItems.length === 0) return prevList;
                const allCurrentlyChecked = groupItems.every(
                  (item) => item.checked,
                );
                targetChecked = !allCurrentlyChecked;
                targetNormalizedText = normalizedTextToToggle;
              } else {
                return prevList;
              }

              // Find items to move to pantry (checked now)
              const itemsToMove = prevList.filter(
                (item) =>
                  item.normalizedText === targetNormalizedText &&
                  !item.checked &&
                  targetChecked,
              );

              if (itemsToMove.length > 0) {
                setPantry((prevPantry) => {
                  // Avoid duplicates by normalizedText
                  const pantryNames = new Set(
                    (prevPantry || []).map((i) =>
                      (i.normalizedText || i.name || "").toLowerCase(),
                    ),
                  );
                  const newItems = itemsToMove
                    .filter(
                      (item) =>
                        !pantryNames.has(
                          (
                            item.normalizedText ||
                            item.name ||
                            ""
                          ).toLowerCase(),
                        ),
                    )
                    .map((item) => ({
                      id:
                        Date.now().toString(36) +
                        Math.random().toString(36).substr(2, 5),
                      name: item.description || item.originalText || "",
                      quantity: item.quantity || 1,
                      unit: item.unit || "",
                      category: "Pantry",
                      expirationDate: "",
                      location: "Pantry",
                      notes: "",
                      normalizedText: item.normalizedText || "",
                    }));
                  return [...prevPantry, ...newItems];
                });
              }

              // Remove checked items from shopping list
              return prevList
                .map((item) => {
                  if (item.normalizedText === targetNormalizedText) {
                    return { ...item, checked: targetChecked };
                  }
                  return item;
                })
                .filter(
                  (item) =>
                    !(
                      item.normalizedText === targetNormalizedText &&
                      targetChecked
                    ),
                );
            });
          },
          [setShoppingList, setPantry],
        );

        const clearShoppingList = useCallback(async () => {
          if (
            window.confirm(
              "Are you sure you want to clear the entire shopping list?",
            )
          ) {
            try {
              await clearStore(STORE_NAMES.SHOPPING_LIST);
              setShoppingList([]);
              addToast("Shopping list cleared!", "success");
            } catch (error) {
              console.error("Error clearing shopping list:", error);
              addToast("Failed to clear shopping list.", "error");
            }
          }
        }, [setShoppingList, addToast]);

        const handleShareAll = useCallback(async () => {
          if (recipes.length === 0) {
            addToast("No recipes to share.", "info");
            return;
          }

          let allRecipesText =
            "Here are my recipes from Recipe Manager Pro:\n\n";

          recipes.forEach((recipe) => {
            allRecipesText += `----------------------------------------\n`;
            allRecipesText += `**${recipe.name}**\n\n`;
            if (recipe.description) {
              allRecipesText += `${recipe.description}\n\n`;
            }
            if (recipe.ingredients && recipe.ingredients.length > 0) {
              allRecipesText += "Ingredients:\n";
              recipe.ingredients.forEach((ing) => {
                allRecipesText += `- ${ing}\n`;
              });
              allRecipesText += "\n";
            }
            if (recipe.directions && recipe.directions.length > 0) {
              allRecipesText += "Directions:\n";
              recipe.directions.forEach((dir, index) => {
                allRecipesText += `${index + 1}. ${dir}\n`;
              });
              allRecipesText += "\n";
            }
          });

          const shareData = {
            title: "My Recipes",
            text: allRecipesText,
          };

          if (navigator.share) {
            try {
              await navigator.share(shareData);
              addToast("All recipes shared successfully!", "success");
            } catch (err) {
              if (err.name !== "AbortError") {
                console.error("Error sharing recipes:", err);
                addToast("Failed to share recipes.", "error");
              }
            }
          } else {
            try {
              const textarea = document.createElement("textarea");
              textarea.value = allRecipesText;
              textarea.style.position = "absolute";
              textarea.style.left = "-9999px";
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand("copy");
              document.body.removeChild(textarea);
              addToast("All recipes copied to clipboard!", "info");
            } catch (err) {
              console.error("Failed to copy recipes:", err);
              addToast("Failed to copy recipes.", "error");
            }
          }
        }, [recipes, addToast]);

        const generateRecipePDF = useCallback(
          async (recipe) => {
            if (!recipe || typeof recipe !== "object") {
              addToast("Invalid recipe data.", "error");
              return;
            }
            if (typeof html2pdf === "undefined") {
              addToast("PDF library not loaded. Please refresh.", "error");
              console.error("html2pdf is not defined");
              return;
            }

            addToast("Generating PDF...", "info");

            const content = document.createElement("div");
            content.style.cssText = `font-family: sans-serif; padding: 30px; line-height: 1.6; color: #333; font-size: 10pt; max-width: 8.5in;`;

            const recipeName = escapeHTML(recipe.name || "Untitled");
            const recipeDescriptionHtml = recipe.description
              ? `<p style="font-size: 10pt; color: #555; margin-bottom: 20px; text-align: center; font-style: italic;">${escapeHTML(
                  recipe.description,
                )}</p>`
              : "";
            const typeHtml = recipe.type
              ? `<p style="font-size: 9pt; color: #777;">Type: ${escapeHTML(
                  recipe.type,
                )}</p>`
              : "";
            const cuisineHtml = recipe.cuisine
              ? `<p style="font-size: 9pt; color: #777;">Cuisine: ${escapeHTML(
                  recipe.cuisine,
                )}</p>`
              : "";
            const dietaryTypesHtml =
              Array.isArray(recipe.dietaryTypes) &&
              recipe.dietaryTypes.length > 0
                ? `<p style="font-size: 9pt; color: #777;">Dietary: ${recipe.dietaryTypes
                    .map(escapeHTML)
                    .join(", ")}</p>`
                : "";
            const tagsHtml =
              Array.isArray(recipe.tags) && recipe.tags.length > 0
                ? `<p style="font-size: 9pt; color: #777;">Tags: ${recipe.tags
                    .map(escapeHTML)
                    .join(", ")}</p>`
                : "";

            let imageHtml = `<div style="text-align: center; margin-bottom: 25px; padding: 20px; border: 1px dashed #ccc; color: #888; border-radius: 8px;">No Image</div>`;
            if (recipe.image) {
              imageHtml = `<img src="${recipe.image}" style="max-width: 250px; max-height: 250px; display: block; margin: 0 auto 25px; border-radius: 8px; border: 1px solid #eee;" alt="${recipeName}"/>`;
            }

            const prepTimeFormatted = formatMinutesToHoursMinutes(
              recipe.prepTime,
            );
            const cookTimeFormatted = formatMinutesToHoursMinutes(
              recipe.cookTime,
            );
            const additionalTimeFormatted = formatMinutesToHoursMinutes(
              recipe.additionalTime,
            );
            const totalTimeFormatted = formatMinutesToHoursMinutes(
              (recipe.prepTime || 0) +
                (recipe.cookTime || 0) +
                (recipe.additionalTime || 0),
            );

            const yieldHtml = recipe.yield
              ? `<p style="margin: 6px 0;">Yield: ${escapeHTML(
                  recipe.yield,
                )}</p>`
              : "";

            const ingredientsHtml =
              Array.isArray(recipe.ingredients) && recipe.ingredients.length > 0
                ? recipe.ingredients
                    .map(
                      (ing) =>
                        `<li style="margin-bottom: 5px;">${escapeHTML(
                          ing || "",
                        )}</li>`,
                    )
                    .join("")
                : "<li>No ingredients listed.</li>";
            const directionsHtml =
              Array.isArray(recipe.directions) && recipe.directions.length > 0
                ? recipe.directions
                    .map(
                      (dir, i) =>
                        `<li style="margin-bottom: 12px; padding-left: 5px; border-left: 2px solid #2ecc71;"><strong>Step ${
                          i + 1
                        }:</strong> ${escapeHTML(dir || "")}</li>`,
                    )
                    .join("")
                : "<li>No directions listed.</li>";
            const tipsAndTricksHtml =
              Array.isArray(recipe.tipsAndTricks) &&
              recipe.tipsAndTricks.length > 0
                ? recipe.tipsAndTricks
                    .map(
                      (tip) =>
                        `<li style="margin-bottom: 8px; padding-left: 5px; border-left: 2px solid #f59e0b;"><strong>Tip:</strong> ${escapeHTML(
                          tip || "",
                        )}</li>`,
                    )
                    .join("")
                : "<li>No tips and tricks listed.</li>";

            content.innerHTML = `
                    <div style="text-align: center; margin-bottom: 10px;">
                      <h1 style="color: #2ecc71; margin: 0 0 8px 0; font-size: 20pt; font-weight: bold;">${recipeName}</h1>
                      <p style="margin: 0; font-size: 11pt; color: #555;">Servings: ${
                        recipe.servings || "N/A"
                      }</p>
                      ${typeHtml} ${cuisineHtml} ${dietaryTypesHtml} ${tagsHtml}
                    </div>
                    ${recipeDescriptionHtml} ${imageHtml}
                    <div style="display: flex; flex-wrap: wrap; justify-content: space-between; gap: 20px; margin-bottom: 30px; border-top: 1px solid #eee; border-bottom: 1px solid #eee; padding: 20px 0;">
                      <div style="flex: 1; min-width: 150px;">
                        <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Details</h3>
                        ${
                          prepTimeFormatted
                            ? `<p style="margin: 6px 0;">Prep: ${prepTimeFormatted}</p>`
                            : ""
                        }
                        ${
                          cookTimeFormatted
                            ? `<p style="margin: 6px 0;">Cook: ${cookTimeFormatted}</p>`
                            : ""
                        }
                        ${
                          additionalTimeFormatted
                            ? `<p style="margin: 6px 0;">Additional: ${additionalTimeFormatted}</p>`
                            : ""
                        }
                        <p style="margin: 10px 0 0 0; font-weight: bold;">Total: ${totalTimeFormatted}</p>
                        ${yieldHtml}
                      </div>
                      <div style="flex: 1; min-width: 150px;">
                        <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Nutrition (per serving)</h3>
                        <p style="margin: 6px 0;">Calories: ${
                          recipe.calories || "N/A"
                        }</p>
                        <p style="margin: 6px 0;">Protein: ${
                          recipe.protein ? recipe.protein + "g" : "N/A"
                        }</p>
                        <p style="margin: 6px 0;">Carbs: ${
                          recipe.carbs ? recipe.carbs + "g" : "N/A"
                        }</p>
                        <p style="margin: 6px 0;">Fat: ${
                          recipe.fat ? recipe.fat + "g" : "N/A"
                        }</p>
                      </div>
                    </div>
                    <div style="margin-bottom: 30px;">
                      <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Ingredients</h3>
                      <ul style="list-style: disc; padding-left: 25px; margin: 0;">${ingredientsHtml}</ul>
                    </div>
                    <div style="margin-bottom: 30px;">
                      <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Directions</h3>
                      <ol style="list-style: none; padding-left: 0; margin: 0;">${directionsHtml}</ol>
                    </div>
                    <div>
                      <h3 style="color: #f59e0b; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Tips & Tricks</h3>
                      <ul style="list-style: none; padding-left: 0; margin: 0;">${tipsAndTricksHtml}</ul>
                    </div>
                  `;

            const opt = {
              margin: 0.5,
              filename: `${recipe.name
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")}-recipe.pdf`,
              image: { type: "jpeg", quality: 0.95 },
              html2canvas: {
                scale: 2,
                useCORS: true,
                logging: false,
                allowTaint: true,
              },
              jsPDF: { unit: "in", format: "letter", orientation: "portrait" },
              pagebreak: { mode: ["avoid-all", "css", "legacy"] },
            };

            try {
              const worker = html2pdf().set(opt).from(content);
              await worker.save();
              addToast("PDF downloaded!", "success");
            } catch (error) {
              console.error("PDF Generation Error:", error);
              addToast(
                `PDF generation failed: ${error.message || "Unknown error"}`,
                "error",
              );
              if (error.stack) {
                console.error(error.stack);
              }
            }
          },
          [addToast],
        );

        return (
          <div className="min-h-screen flex flex-col">
            {showRecipeSuggestions && (
              <RecipeSuggestionsModal
                recipes={recipes}
                pantry={pantry}
                onClose={() => setShowRecipeSuggestions(false)}
                openRecipeDetails={(recipe) => {
                  setShowRecipeDetails(recipe);
                  setShowRecipeSuggestions(false);
                  setShowPantryModal(false);
                }}
                toggleFavorite={toggleFavorite}
              />
            )}
            <Header
              openAddRecipeModal={() => {
                setEditingRecipe(null);
                setShowAddRecipeModal(true);
              }}
              openMealPlanModal={() => setShowMealPlanModal(true)}
              openShoppingListModal={() => setShowShoppingListModal(true)}
              openPantryModal={() => setShowPantryModal(true)}
              openRecipeSuggestions={() => setShowRecipeSuggestions(true)}
              recipes={recipes}
              addToast={addToast}
              setRecipes={setRecipes}
              deleteAllRecipes={deleteAllRecipes}
              exportRecipes={exportRecipes}
              handleShareAll={handleShareAll}
            />
            <main className="flex-grow max-w-7xl mx-auto p-3 sm:p-4 w-full">
              {isLoading ? (
                <div className="text-center py-10 text-gray-500 dark:text-gray-400">
                  <div className="spinner"></div>
                  <p className="text-lg">Loading recipes...</p>
                  <p className="text-sm">
                    This might take a moment if migrating from old storage.
                  </p>
                </div>
              ) : (
                <RecipeList
                  recipes={recipes}
                  searchRecipes={searchRecipes}
                  openRecipeDetails={(recipe) => setShowRecipeDetails(recipe)}
                  toggleFavorite={toggleFavorite}
                  collections={collections}
                />
              )}
            </main>
            {showAddRecipeModal && (
              <AddRecipeModal
                onClose={() => {
                  setShowAddRecipeModal(false);
                  setEditingRecipe(null);
                }}
                addRecipe={addRecipe}
                updateRecipe={updateRecipe}
                editingRecipe={editingRecipe}
                addToast={addToast}
              />
            )}
            {showRecipeDetails && (
              <RecipeDetailsModal
                recipe={showRecipeDetails}
                onClose={() => setShowRecipeDetails(null)}
                addToShoppingList={addToShoppingList}
                generateRecipePDF={generateRecipePDF}
                deleteRecipe={deleteRecipe}
                editRecipe={(recipe) => {
                  setEditingRecipe(recipe);
                  setShowRecipeDetails(null);
                  setShowAddRecipeModal(true);
                }}
                toggleFavorite={toggleFavorite}
                addToast={addToast}
                updateMealPlan={updateMealPlan}
                mealPlan={mealPlan}
                recipes={recipes}
                addTimer={addTimer}
                pantry={pantry}
                shoppingList={shoppingList}
                setShoppingList={setShoppingList}
                collections={collections}
                setCollections={setCollections}
              />
            )}
            {showMealPlanModal && (
              <MealPlanModal
                mealPlan={mealPlan}
                recipes={recipes}
                updateMealPlan={updateMealPlan}
                removeMealFromPlan={removeMealFromPlan}
                addMultipleRecipesToShoppingList={
                  addMultipleRecipesToShoppingList
                }
                onClose={() => setShowMealPlanModal(false)}
              />
            )}
            {showShoppingListModal && (
              <ShoppingListModal
                shoppingList={shoppingList}
                toggleShoppingItem={toggleShoppingItem}
                clearShoppingList={clearShoppingList}
                addToast={addToast}
                onClose={() => setShowShoppingListModal(false)}
                displayUnitSystem={displayUnitSystem}
                setDisplayUnitSystem={setDisplayUnitSystem}
                convertUnits={convertUnits}
              />
            )}

            {showPantryModal && (
              <PantryModal
                inventory={pantry}
                addInventoryItem={async (item) => {
                  const newItem = {
                    ...item,
                    id:
                      Date.now().toString(36) +
                      Math.random().toString(36).substr(2, 5),
                  };
                  await setPantry((prev) => [...prev, newItem]);
                  addToast("Item added to inventory!", "success");
                }}
                updateInventoryItem={async (id, updated) => {
                  await setPantry((prev) =>
                    prev.map((item) =>
                      item.id === id ? { ...item, ...updated } : item,
                    ),
                  );
                  addToast("Item updated!", "success");
                }}
                deleteInventoryItem={async (id) => {
                  await setPantry((prev) =>
                    prev.filter((item) => item.id !== id),
                  );
                  addToast("Item removed from inventory!", "success");
                }}
                clearAllInventory={async () => {
                  await setPantry([]);
                  addToast("Inventory cleared!", "success");
                }}
                checkRecipeAvailability={(recipe) => {
                  // Use computeRecipeMatch for more detailed info
                  const match = (window.computeRecipeMatch &&
                    window.computeRecipeMatch(recipe, pantry)) || {
                    matchedCount: 0,
                    totalIngredients: Array.isArray(recipe.ingredients)
                      ? recipe.ingredients.length
                      : 0,
                    percentage: 0,
                    canMake: false,
                    missing: [],
                  };
                  return {
                    canMake: match.canMake,
                    percentage: match.percentage,
                    matchedCount: match.matchedCount,
                    totalIngredients: match.totalIngredients,
                    missing: match.missing,
                  };
                }}
                recipes={recipes}
                addToast={addToast}
                onClose={() => setShowPantryModal(false)}
              />
            )}
            {showCollectionsModal && (
              <RecipeCollectionsModal
                collections={collections}
                setCollections={setCollections}
                recipes={recipes}
                onClose={() => setShowCollectionsModal(false)}
                onSelectCollection={(collection) => {
                  setSelectedCollection(collection);
                  setShowCollectionsModal(false);
                  // Filter recipes to show only those in this collection
                  const filterEvent = new CustomEvent("searchRecipes", {
                    detail: {
                      type: "collection",
                      collectionId: collection.id,
                      recipeIds: collection.recipeIds || [],
                    },
                  });
                  document.dispatchEvent(filterEvent);
                  addToast(
                    `Showing "${collection.name}" (${collection.recipeIds?.length || 0} recipes)`,
                    "success",
                  );
                }}
                addToast={addToast}
              />
            )}
            {showAddRecipesToCollectionModal && (
              <AddRecipesToCollectionModal
                collection={showAddRecipesToCollectionModal}
                collections={collections}
                setCollections={setCollections}
                recipes={recipes}
                onClose={() => setShowAddRecipesToCollectionModal(null)}
                addToast={addToast}
              />
            )}
            <TimerTray
              timers={timers}
              onToggle={toggleTimer}
              onRemove={removeTimer}
              onReset={resetTimer}
            />
            <div className="fixed bottom-4 right-4 z-[100] space-y-2">
              {toasts.map((toast) => (
                <Toast
                  key={toast.id}
                  message={toast.message}
                  type={toast.type}
                  onClose={() => removeToast(toast.id)}
                />
              ))}
            </div>
            <Footer />
          </div>
        );
      };

      const Header = ({
        openAddRecipeModal,
        openMealPlanModal,
        openShoppingListModal,
        openPantryModal,
        openRecipeSuggestions,
        recipes,
        addToast,
        setRecipes,
        deleteAllRecipes,
        exportRecipes,
        handleShareAll,
      }) => {
        const [searchQuery, setSearchQuery] = useState("");
        const debounceTimeoutRef = useRef(null);
        const [isMenuOpen, setIsMenuOpen] = useState(false); // State for hamburger menu

        const handleSearchChange = useCallback((e) => {
          const query = e.target.value;
          setSearchQuery(query);

          if (debounceTimeoutRef.current)
            clearTimeout(debounceTimeoutRef.current);

          debounceTimeoutRef.current = setTimeout(() => {
            document.dispatchEvent(
              new CustomEvent("searchRecipes", {
                detail: { query, type: "search" },
              }),
            );
          }, 350);
        }, []);

        const handleToggleAllRecipes = useCallback(() => {
          document.dispatchEvent(
            new CustomEvent("searchRecipes", { detail: { type: "toggleAll" } }),
          );
          setSearchQuery("");
        }, []);

        const handleImport = useCallback(() => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json";
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const rawData = JSON.parse(e.target.result);
                let importedRecipes = [];

                if (Array.isArray(rawData)) {
                  importedRecipes = rawData;
                } else if (
                  typeof rawData === "object" &&
                  rawData !== null &&
                  rawData.name
                ) {
                  importedRecipes = [rawData];
                } else {
                  throw new Error(
                    "Invalid file format: Expected a recipe object or an array of recipes.",
                  );
                }

                const timestamp = Date.now();
                const processedRecipes = importedRecipes
                  .filter((recipe) => {
                    const isValid =
                      recipe &&
                      typeof recipe === "object" &&
                      typeof recipe.name === "string" &&
                      recipe.name.trim() !== "";
                    if (!isValid) {
                      console.warn("Skipping invalid recipe:", recipe);
                    }
                    return isValid;
                  })
                  .map((recipe, index) => {
                    const uniqueId = `${timestamp.toString(
                      36,
                    )}-${index}-${Math.random().toString(36).substr(2, 5)}`;
                    return {
                      id: uniqueId,
                      name: recipe.name?.trim() || "Untitled Recipe",
                      description: recipe.description?.trim() || "",
                      type: recipe.type?.trim() || "Other",
                      course:
                        recipe.course?.trim() || recipe.type?.trim() || "",
                      subCategory:
                        recipe.subCategory?.trim() ||
                        recipe.subcategory?.trim() ||
                        "",
                      cuisine: recipe.cuisine?.trim() || "",
                      dietaryTypes: Array.isArray(recipe.dietaryTypes)
                        ? recipe.dietaryTypes
                            .filter((t) => typeof t === "string" && t.trim())
                            .map((t) => t.trim())
                        : [],
                      tags: Array.isArray(recipe.tags)
                        ? recipe.tags
                            .filter((t) => typeof t === "string" && t.trim())
                            .map((t) => t.trim())
                        : [],
                      prepTime: recipe.prepTime
                        ? Math.max(0, parseInt(recipe.prepTime))
                        : 0,
                      cookTime: recipe.cookTime
                        ? Math.max(0, parseInt(recipe.cookTime))
                        : 0,
                      additionalTime: recipe.additionalTime
                        ? Math.max(0, parseInt(recipe.additionalTime))
                        : 0,
                      servings: recipe.servings
                        ? Math.max(1, parseInt(recipe.servings))
                        : 1,
                      yield: recipe.yield?.trim() || "",
                      ingredients: Array.isArray(recipe.ingredients)
                        ? recipe.ingredients
                            .filter((i) => typeof i === "string" && i.trim())
                            .map((i) => i.trim())
                        : [],
                      directions: Array.isArray(recipe.directions)
                        ? recipe.directions
                            .filter((d) => typeof d === "string" && d.trim())
                            .map((d) => d.trim())
                        : [],
                      tipsAndTricks: Array.isArray(recipe.tipsAndTricks)
                        ? recipe.tipsAndTricks
                            .filter(
                              (tip) => typeof tip === "string" && tip.trim(),
                            )
                            .map((tip) => tip.trim())
                        : [],
                      calories: recipe.calories
                        ? Math.max(0, parseInt(recipe.calories))
                        : null,
                      protein: recipe.protein
                        ? Math.max(0, parseFloat(recipe.protein))
                        : null,
                      carbs: recipe.carbs
                        ? Math.max(0, parseFloat(recipe.carbs))
                        : null,
                      fat: recipe.fat
                        ? Math.max(0, parseFloat(recipe.fat))
                        : null,
                      image:
                        typeof recipe.image === "string" ? recipe.image : null,
                      video:
                        typeof recipe.video === "string" ? recipe.video : null,
                      createdAt: new Date().toISOString(),
                      isFavorite: false,
                    };
                  });

                if (processedRecipes.length === 0) {
                  addToast("No valid recipes found in import file.", "error");
                  return;
                }

                for (const recipe of processedRecipes) {
                  await addItem(STORE_NAMES.RECIPES, recipe);
                }
                const updatedRecipesFromDB = await getAllItems(
                  STORE_NAMES.RECIPES,
                );
                setRecipes(updatedRecipesFromDB);

                addToast(
                  `Successfully imported ${processedRecipes.length} recipes!`,
                  "success",
                );
              } catch (err) {
                console.error("Import error:", err);
                addToast(
                  `Error importing recipes: ${
                    err.message || "Invalid file format"
                  }`,
                  "error",
                );
              }
            };
            reader.onerror = () => {
              addToast("Error reading file. Please try again.", "error");
            };
            reader.readAsText(file);
          };
          input.click();
        }, [addToast, setRecipes]);

        const menuItems = [
          {
            label: "Recipe Suggestions",
            icon: "fas fa-lightbulb",
            action: () => openRecipeSuggestions && openRecipeSuggestions(),
          },
          {
            label: "All Recipes",
            icon: "fas fa-list-alt",
            action: handleToggleAllRecipes,
          },
          {
            label: "Meal Plan",
            icon: "fas fa-calendar-alt",
            action: openMealPlanModal,
          },
          {
            label: "Shopping List",
            icon: "fas fa-shopping-cart",
            action: openShoppingListModal,
          },
          {
            label: "Pantry",
            icon: "fas fa-warehouse",
            action: openPantryModal,
          },
          {
            label: "Collections",
            icon: "fas fa-folder",
            action: () => {
              // Will be wired up in App component
              document.dispatchEvent(new CustomEvent("openCollections"));
            },
          },
          {
            label: "Share All Recipes",
            icon: "fas fa-share-alt",
            action: handleShareAll,
          },
          {
            label: "Import Recipes",
            icon: "fas fa-file-import",
            action: handleImport,
          },
          {
            label: "Export Recipes",
            icon: "fas fa-file-export",
            action: exportRecipes,
          },
          {
            label: "Delete All Recipes",
            icon: "fas fa-trash-alt",
            action: deleteAllRecipes,
            isDestructive: true,
          },
        ];

        useEffect(
          () => () => {
            if (debounceTimeoutRef.current)
              clearTimeout(debounceTimeoutRef.current);
          },
          [],
        );

        return (
          <header className="bg-white dark:bg-gray-800 shadow-md p-3 sticky top-0 z-30 transition-colors duration-300">
            <nav className="max-w-7xl mx-auto flex justify-between items-center flex-wrap gap-y-2 gap-x-3">
              <h1 className="text-lg sm:text-xl font-bold text-green-500 whitespace-nowrap flex items-center gap-2 order-1">
                <i className="fas fa-book-open text-green-500"></i>
                <span className="hidden sm:inline">Recipe Manager Pro</span>
                <span className="sm:hidden">Recipes</span>
              </h1>

              <div className="flex-grow flex items-center bg-gray-100 dark:bg-gray-700 rounded-full px-3 py-1.5 w-full sm:w-auto sm:flex-grow sm:max-w-md md:mx-auto order-3 sm:order-2">
                <i className="fas fa-search text-gray-400 dark:text-gray-500 mr-2 text-sm"></i>
                <input
                  type="search"
                  placeholder="Search recipes..."
                  value={searchQuery}
                  className="bg-transparent outline-none text-sm text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 w-full"
                  onChange={handleSearchChange}
                  aria-label="Search recipes"
                />
              </div>

              <div className="flex items-center gap-1.5 sm:gap-2 order-2 sm:order-3 relative">
                <button
                  onClick={openAddRecipeModal}
                  className="btn-header bg-green-500 text-white hover:bg-green-600 dark:hover:bg-green-600"
                  title="Add Recipe"
                >
                  <i className="fas fa-plus"></i>
                  <span className="hidden sm:inline ml-1">Add Recipe</span>
                </button>
                <button
                  onClick={() => setIsMenuOpen(!isMenuOpen)}
                  className="btn-header"
                  title="Menu"
                >
                  <i
                    className={`fas ${
                      isMenuOpen ? "fa-times" : "fa-bars"
                    } text-green-500`}
                  ></i>
                </button>

                {isMenuOpen && (
                  <div
                    className="absolute top-full right-0 mt-2 w-56 bg-white dark:bg-gray-800 rounded-md shadow-lg ring-1 ring-black ring-opacity-5 z-40"
                    role="menu"
                    aria-orientation="vertical"
                    aria-labelledby="menu-button"
                  >
                    <div className="py-1" role="none">
                      {menuItems.map((item, index) => (
                        <button
                          key={index}
                          onClick={() => {
                            item.action();
                            setIsMenuOpen(false);
                          }}
                          className={`w-full text-left px-4 py-2 text-sm flex items-center gap-3 ${
                            item.isDestructive
                              ? "text-red-700 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/50"
                              : "text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700"
                          }`}
                          role="menuitem"
                        >
                          <i
                            className={`${item.icon} w-4 text-center text-green-500`}
                          ></i>
                          <span>{item.label}</span>
                        </button>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </nav>
            {isMenuOpen && (
              <div
                onClick={() => setIsMenuOpen(false)}
                className="fixed inset-0 z-30"
              ></div>
            )}
          </header>
        );
      };

      // Modal wrapper for RecipeSuggestions
      const RecipeSuggestionsModal = ({
        recipes,
        pantry,
        onClose,
        openRecipeDetails,
        toggleFavorite,
      }) => {
        console.log(
          `[RecipeSuggestionsModal] Rendered with ${pantry?.length || 0} pantry items`,
        );

        // Close on ESC
        useEffect(() => {
          const handleKey = (e) => {
            if (e.key === "Escape") onClose && onClose();
          };
          document.addEventListener("keydown", handleKey);
          return () => document.removeEventListener("keydown", handleKey);
        }, [onClose]);

        // Focus the close button when opened
        useEffect(() => {
          const btn = document.querySelector(".rs-modal .close-btn");
          if (btn && typeof btn.focus === "function") btn.focus();
        }, []);

        const [showAll, setShowAll] = useState(false);

        const suggested = useMemo(() => {
          if (!Array.isArray(recipes) || recipes.length === 0) return [];

          const withMatch = recipes.map((r) => {
            const match = (window.computeRecipeMatch &&
              window.computeRecipeMatch(r, pantry)) || {
              matchedCount: 0,
              totalIngredients: Array.isArray(r.ingredients)
                ? r.ingredients.length
                : 0,
              percentage: 0,
              canMake: false,
              missing: [],
            };
            return { ...r, __match: match };
          });

          withMatch.sort((a, b) => {
            if (a.__match.canMake !== b.__match.canMake)
              return a.__match.canMake ? -1 : 1;
            if (b.__match.percentage !== a.__match.percentage)
              return b.__match.percentage - a.__match.percentage;
            if ((b.isFavorite ? 1 : 0) !== (a.isFavorite ? 1 : 0))
              return b.isFavorite ? 1 : -1;
            return Math.random() - 0.5;
          });

          return withMatch; // return all matches, UI controls how many to show
        }, [recipes, pantry]);

        const displayedSuggestions = showAll
          ? suggested
          : suggested.slice(0, 12);

        return (
          <div
            className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4"
            role="dialog"
            aria-modal="true"
            aria-label="Recipe Suggestions"
            onClick={onClose}
          >
            <div
              className="rs-modal bg-white dark:bg-gray-800 rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto shadow-2xl relative modal-fade border border-gray-100 dark:border-gray-700"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="flex items-start justify-between p-5 border-b border-gray-100 dark:border-gray-700">
                <div>
                  <h2 className="text-xl sm:text-2xl font-bold text-gray-900 dark:text-gray-100 flex items-center gap-3">
                    <i className="fas fa-lightbulb text-yellow-500"></i>
                    Recipe Suggestions
                  </h2>
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                    Personalized picks based on your favorites and pantry.
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <button
                    className="close-btn btn-modal btn-gray"
                    onClick={onClose}
                    aria-label="Close suggestions modal"
                  >
                    <i className="fas fa-times"></i>
                  </button>
                </div>
              </div>

              <div className="p-5">
                {suggested.length === 0 ? (
                  <p className="text-center text-gray-500 dark:text-gray-400">
                    No suggestions available right now.
                  </p>
                ) : (
                  <>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                      {displayedSuggestions.map((recipe) => (
                        <article
                          key={recipe.id}
                          className="bg-white dark:bg-gray-700 rounded-lg overflow-hidden shadow hover:shadow-lg transition-shadow cursor-pointer flex flex-col"
                          onClick={() =>
                            openRecipeDetails && openRecipeDetails(recipe)
                          }
                          tabIndex="0"
                          aria-label={`Open ${recipe.name}`}
                        >
                          <div className="aspect-video bg-gray-200 dark:bg-gray-600 overflow-hidden relative">
                            {recipe.image ? (
                              <img
                                src={recipe.image}
                                alt={recipe.name}
                                className="w-full h-full object-cover"
                              />
                            ) : (
                              <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                                <i className="fas fa-image text-3xl opacity-50"></i>
                              </div>
                            )}
                            {recipe.isFavorite && (
                              <div className="absolute top-2 left-2 bg-yellow-50 text-yellow-600 p-1 rounded-full text-sm">
                                <i className="fas fa-star"></i>
                              </div>
                            )}

                            {recipe.__match && recipe.__match.canMake && (
                              <div className="absolute top-2 right-2 bg-green-600 text-white px-2 py-0.5 rounded-full text-xs">
                                Can make now
                              </div>
                            )}

                            {recipe.__match && !recipe.__match.canMake && (
                              <div className="absolute bottom-2 left-2 bg-white/90 dark:bg-gray-800/90 px-2 py-0.5 rounded-full text-xs text-gray-700 dark:text-gray-200">
                                {recipe.__match.percentage}%
                              </div>
                            )}
                          </div>
                          <div className="p-3 flex flex-col flex-grow">
                            <div className="flex items-start justify-between gap-2">
                              <h3 className="text-sm font-semibold text-gray-900 dark:text-gray-100 line-clamp-1">
                                {recipe.name}
                              </h3>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  toggleFavorite && toggleFavorite(recipe.id);
                                }}
                                className={`text-lg ${recipe.isFavorite ? "text-yellow-400" : "text-gray-300 dark:text-gray-400"}`}
                                aria-label={
                                  recipe.isFavorite
                                    ? "Remove favorite"
                                    : "Add favorite"
                                }
                              >
                                <i className="fas fa-star"></i>
                              </button>
                            </div>
                            {recipe.description && (
                              <p className="text-xs text-gray-500 dark:text-gray-400 mt-1 line-clamp-2">
                                {recipe.description}
                              </p>
                            )}

                            {recipe.__match &&
                              !recipe.__match.canMake &&
                              recipe.__match.missing &&
                              recipe.__match.missing.length > 0 && (
                                <p className="text-xs text-red-500 dark:text-red-400 mt-2 line-clamp-2">
                                  Missing:{" "}
                                  {recipe.__match.missing
                                    .slice(0, 3)
                                    .join(", ")}
                                  {recipe.__match.missing.length > 3
                                    ? ` +${recipe.__match.missing.length - 3} more`
                                    : ""}
                                </p>
                              )}

                            <div className="mt-4 flex items-center justify-between gap-2">
                              <div className="flex items-center gap-2">
                                <span className="inline-block bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 text-xs px-2 py-0.5 rounded-full">
                                  {recipe.type}
                                </span>
                                {recipe.__match && (
                                  <span className="text-xs text-gray-500 dark:text-gray-400">
                                    {recipe.__match.matchedCount}/
                                    {recipe.__match.totalIngredients}
                                  </span>
                                )}
                              </div>
                              <div className="flex items-center gap-2">
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    openRecipeDetails &&
                                      openRecipeDetails(recipe);
                                    onClose && onClose();
                                  }}
                                  className="btn-modal btn-green text-sm"
                                >
                                  View
                                </button>
                              </div>
                            </div>
                          </div>
                        </article>
                      ))}
                    </div>
                    {suggested.length > 12 && (
                      <div className="mt-4 pt-4 border-t border-gray-100 dark:border-gray-700 flex justify-center">
                        <button
                          className="btn-modal btn-gray"
                          onClick={(e) => {
                            e.stopPropagation();
                            setShowAll((s) => !s);
                          }}
                          aria-expanded={showAll}
                        >
                          {showAll
                            ? "Show less"
                            : `Show all (${suggested.length})`}
                        </button>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          </div>
        );
      };
      // The original RecipeSuggestions section (for inline use, not modal)
      const RecipeSuggestions = ({
        recipes,
        pantry,
        openRecipeDetails,
        toggleFavorite,
      }) => {
        const [isExpanded, setIsExpanded] = useState(false);

        const suggested = useMemo(() => {
          if (!Array.isArray(recipes) || recipes.length === 0) return [];

          // Compute match info for each recipe
          const withMatch = recipes.map((r) => {
            const match = (window.computeRecipeMatch &&
              window.computeRecipeMatch(r, pantry)) || {
              matchedCount: 0,
              totalIngredients: Array.isArray(r.ingredients)
                ? r.ingredients.length
                : 0,
              percentage: 0,
              canMake: false,
              missing: [],
            };
            return { ...r, __match: match };
          });

          // Sort: canMake first, then percentage desc, then favorites, then random
          withMatch.sort((a, b) => {
            if (a.__match.canMake !== b.__match.canMake)
              return a.__match.canMake ? -1 : 1;
            if (b.__match.percentage !== a.__match.percentage)
              return b.__match.percentage - a.__match.percentage;
            if ((b.isFavorite ? 1 : 0) !== (a.isFavorite ? 1 : 0))
              return b.isFavorite ? 1 : -1;
            return Math.random() - 0.5;
          });

          // pick top 3 unique
          const unique = [];
          const seen = new Set();
          for (const r of withMatch) {
            if (!r?.id || seen.has(r.id)) continue;
            unique.push(r);
            seen.add(r.id);
            if (unique.length === 3) break;
          }
          return unique;
        }, [recipes, pantry]);

        if (!suggested || suggested.length === 0) return null;

        return (
          <section className="mb-6 sm:mb-8 p-3 sm:p-4 bg-gray-50 dark:bg-gray-800 rounded-lg shadow">
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="flex justify-between items-center w-full text-left mb-3 sm:mb-4"
              aria-expanded={isExpanded}
              aria-controls="suggestions-content"
            >
              <h2 className="text-lg sm:text-xl font-semibold text-gray-800 dark:text-gray-200">
                Suggestions For You
              </h2>
              <i
                className={`fas fa-chevron-down text-gray-500 dark:text-gray-400 transform transition-transform duration-200 ${
                  isExpanded ? "rotate-180" : ""
                }`}
                aria-hidden="true"
              ></i>
            </button>
            <div
              id="suggestions-content"
              className={`collapsible-content ${isExpanded ? "expanded" : ""}`}
            >
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
                {suggested.map((recipe) => (
                  <div
                    key={recipe.id}
                    className="bg-white dark:bg-gray-700 rounded-lg shadow overflow-hidden cursor-pointer hover:shadow-lg transition-shadow duration-300 flex flex-col"
                    onClick={() => openRecipeDetails(recipe)}
                    tabIndex="0"
                    aria-label={`View suggestion: ${recipe.name}`}
                  >
                    <div className="aspect-video w-full bg-gray-200 dark:bg-gray-600 overflow-hidden relative">
                      {recipe.image ? (
                        <img
                          src={recipe.image}
                          alt={recipe.name}
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                          <i className="fas fa-image text-3xl opacity-50"></i>
                        </div>
                      )}
                      {recipe.isFavorite && (
                        <div className="absolute top-2 right-2 bg-black bg-opacity-40 text-yellow-400 p-1 rounded-full text-xs">
                          <i className="fas fa-star"></i>
                        </div>
                      )}
                      {recipe.__match && recipe.__match.canMake && (
                        <div className="absolute top-2 left-2 bg-green-600 text-white px-2 py-0.5 rounded-full text-xs">
                          Can make now
                        </div>
                      )}
                      {recipe.__match && !recipe.__match.canMake && (
                        <div className="absolute bottom-2 left-2 bg-white/80 dark:bg-gray-800/80 px-2 py-0.5 rounded-full text-xs text-gray-700 dark:text-gray-200">
                          {recipe.__match.percentage}%
                        </div>
                      )}
                    </div>
                    <div className="p-3 flex-grow flex flex-col">
                      <h3
                        className="text-base font-semibold mb-1 line-clamp-1 flex-grow"
                        title={recipe.name}
                      >
                        {recipe.name}
                      </h3>
                      {recipe.description && (
                        <p
                          className="text-xs text-gray-500 dark:text-gray-400 mb-1 line-clamp-2"
                          title={recipe.description}
                        >
                          {recipe.description}
                        </p>
                      )}
                      <div className="flex justify-between items-center mt-auto pt-1">
                        <div className="flex items-center gap-2">
                          <span className="inline-block bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 text-xs px-2 py-0.5 rounded-full">
                            {recipe.type}
                          </span>
                          {recipe.__match && (
                            <span className="text-xs text-gray-500 dark:text-gray-400">
                              {recipe.__match.matchedCount}/
                              {recipe.__match.totalIngredients}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </section>
        );
      };

      const RecipeList = ({
        recipes,
        searchRecipes,
        openRecipeDetails,
        toggleFavorite,
        collections,
      }) => {
        const [filteredRecipes, setFilteredRecipes] = useState([]);
        const [tagModal, setTagModal] = useState({ open: false, tag: null });
        const [activeCollection, setActiveCollection] = useState(null);
        const [filters, setFilters] = useState({
          query: "",
          type: "",
          cuisine: "",
          dietaryType: "",
          tag: "",
          cookTime: "",
          favorites: false,
          collectionRecipeIds: null,
        });
        const [hideAllExplicitly, setHideAllExplicitly] = useState(false);

        useEffect(() => {
          const isFilterActive =
            filters.query ||
            filters.type ||
            filters.cuisine ||
            filters.dietaryType ||
            filters.tag ||
            filters.cookTime ||
            filters.favorites;
          let results = recipes;
          if (isFilterActive || !hideAllExplicitly) {
            results = searchRecipes(filters.query, filters);
          }
          const sorted = [...results].sort((a, b) => {
            if (!a.createdAt && !b.createdAt) return 0;
            if (!a.createdAt) return 1;
            if (!b.createdAt) return -1;
            return new Date(b.createdAt) - new Date(a.createdAt);
          });
          setFilteredRecipes(sorted);
        }, [recipes, filters, searchRecipes, hideAllExplicitly]);

        useEffect(() => {
          const handler = (e) => {
            if (e.detail.type === "toggleAll") {
              setHideAllExplicitly((prev) => !prev);
              setActiveCollection(null);
              setFilters({
                query: "",
                type: "",
                cuisine: "",
                dietaryType: "",
                tag: "",
                cookTime: "",
                favorites: false,
                collectionRecipeIds: null,
              });
            } else if (e.detail.type === "search") {
              setHideAllExplicitly(false);
              setActiveCollection(null);
              setFilters((prev) => ({
                ...prev,
                query: e.detail.query,
                collectionRecipeIds: null,
              }));
            } else if (e.detail.type === "collection") {
              setHideAllExplicitly(false);
              const collection = collections?.find(
                (c) => c.id === e.detail.collectionId,
              );
              setActiveCollection(collection || null);
              setFilters({
                query: "",
                type: "",
                cuisine: "",
                dietaryType: "",
                tag: "",
                cookTime: "",
                favorites: false,
                collectionRecipeIds: e.detail.recipeIds || [],
              });
            }
          };
          document.addEventListener("searchRecipes", handler);
          return () => document.removeEventListener("searchRecipes", handler);
        }, [collections]);

        const handleFilterChange = useCallback((e) => {
          const { name, value, type, checked } = e.target;
          setHideAllExplicitly(false);
          setFilters((prev) => ({
            ...prev,
            [name]: type === "checkbox" ? checked : value,
          }));
        }, []);

        const recipesToDisplay = hideAllExplicitly ? [] : filteredRecipes;
        const hasActiveFiltersExcludingQuery =
          filters.type ||
          filters.cuisine ||
          filters.dietaryType ||
          filters.tag ||
          filters.cookTime ||
          filters.favorites;

        return (
          <section>
            {/* Active Collection Banner */}
            {activeCollection && (
              <div className="mb-4 bg-green-100 dark:bg-green-900/30 border-2 border-green-500 dark:border-green-600 rounded-lg p-4 flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <i className="fas fa-folder text-green-600 dark:text-green-400 text-2xl"></i>
                  <div>
                    <h3 className="text-lg font-bold text-gray-900 dark:text-white">
                      {activeCollection.name}
                    </h3>
                    <p className="text-sm text-gray-600 dark:text-gray-400">
                      Showing {filters.collectionRecipeIds?.length || 0} recipe
                      {filters.collectionRecipeIds?.length !== 1
                        ? "s"
                        : ""}{" "}
                      from this collection
                    </p>
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => {
                      // Trigger add recipes modal
                      document.dispatchEvent(
                        new CustomEvent("addRecipesToCollection", {
                          detail: { collectionId: activeCollection.id },
                        }),
                      );
                    }}
                    className="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition flex items-center gap-2"
                    title="Add recipes to this collection"
                  >
                    <i className="fas fa-plus"></i>
                    Add Recipes
                  </button>
                  <button
                    onClick={() => {
                      setActiveCollection(null);
                      document.dispatchEvent(
                        new CustomEvent("searchRecipes", {
                          detail: { type: "toggleAll" },
                        }),
                      );
                    }}
                    className="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition flex items-center gap-2"
                  >
                    <i className="fas fa-times"></i>
                    Exit Collection
                  </button>
                </div>
              </div>
            )}
            <div className="mb-4 sm:mb-6 flex flex-wrap gap-5 items-center bg-gray-50 dark:bg-gray-800 p-2 sm:p-3 rounded-lg shadow-sm">
              <span className="text-sm font-medium mr-1 hidden md:inline text-gray-700 dark:text-gray-300">
                Filter:
              </span>
              {/* Course Filter */}
              <select
                name="course"
                value={filters.course || ""}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter by Course"
              >
                <option value="">All Courses</option>
                <option value="_NONE_">No Course</option>
                {[...new Set(recipes.map((r) => r?.course).filter(Boolean))]
                  .sort()
                  .map((c) => (
                    <option key={c} value={c}>
                      {c}
                    </option>
                  ))}
              </select>
              <select
                name="cuisine"
                value={filters.cuisine}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter by Cuisine"
              >
                <option value="">All Cuisines</option>{" "}
                <option value="_NONE_">No Cuisine</option>
                {[...new Set(recipes.map((r) => r?.cuisine).filter(Boolean))]
                  .sort()
                  .map((c) => (
                    <option key={c} value={c}>
                      {c}
                    </option>
                  ))}
              </select>
              <select
                name="dietaryType"
                value={filters.dietaryType}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Dietary Type"
              >
                <option value="">All Dietary</option>{" "}
                <option value="_NONE_">No Dietary Tags</option>
                {[
                  ...new Set(
                    recipes
                      .flatMap((r) => r?.dietaryTypes || [])
                      .filter(Boolean),
                  ),
                ]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              {/* Sub-Category Filter (dependent on Course) */}
              <select
                name="subCategory"
                value={filters.subCategory || ""}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter by Sub-Category"
              >
                <option value="">All Sub-Categories</option>
                <option value="_NONE_">No Sub-Category</option>
                {(() => {
                  // If a course is selected, only show sub-categories from recipes with that course
                  let filtered = recipes;
                  if (filters.course && filters.course !== "_NONE_") {
                    filtered = recipes.filter(
                      (r) => r.course === filters.course,
                    );
                  }
                  return [
                    ...new Set(
                      filtered.map((r) => r?.subCategory).filter(Boolean),
                    ),
                  ]
                    .sort()
                    .map((sc) => (
                      <option key={sc} value={sc}>
                        {sc}
                      </option>
                    ));
                })()}
              </select>
              <select
                name="cookTime"
                value={filters.cookTime}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Total Time"
              >
                <option value="">Any Time</option>
                {[15, 30, 45, 60, 90, 120].map((t) => (
                  <option key={t} value={t}>
                    ‚â§ {t} min
                  </option>
                ))}
              </select>
              <label
                className="flex items-center gap-1 cursor-pointer text-xs sm:text-sm whitespace-nowrap ml-1 sm:ml-2 text-gray-700 dark:text-gray-300"
                title="Favorites Only"
              >
                <input
                  type="checkbox"
                  name="favorites"
                  checked={filters.favorites}
                  onChange={handleFilterChange}
                  className="w-3.5 h-3.5 sm:w-4 sm:h-4 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-600"
                />
                <i className="fas fa-star text-yellow-400"></i>{" "}
                <span className="hidden sm:inline">Favs</span>
              </label>
              <div className="ml-auto text-sm font-semibold text-gray-700 dark:text-gray-300 flex items-center gap-1">
                <i className="fas fa-utensils text-green-500"></i> Recipes:{" "}
                {recipesToDisplay.length}
              </div>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-5">
              {recipesToDisplay.length > 0 ? (
                recipesToDisplay.map((recipe) => (
                  <div
                    key={recipe.id}
                    onClick={() => openRecipeDetails(recipe)}
                    tabIndex="0"
                    aria-label={`View recipe: ${recipe.name}`}
                    className="bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden cursor-pointer hover:shadow-xl hover:bg-green-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 flex flex-col recipe-card card-appear"
                  >
                    <div className="aspect-video w-full bg-gray-200 dark:bg-gray-700 overflow-hidden relative">
                      {recipe.image ? (
                        <img
                          src={recipe.image}
                          alt={recipe.name}
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                          <i className="fas fa-image text-4xl mb-3 opacity-50"></i>
                        </div>
                      )}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          toggleFavorite(recipe.id);
                        }}
                        aria-label={
                          recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                        }
                        className={`absolute top-2 right-2 text-2xl ${
                          recipe.isFavorite
                            ? "text-yellow-400 filter drop-shadow(0 1px 1px rgba(0,0,0,0.5))"
                            : "text-white text-opacity-50"
                        } hover:text-yellow-300 hover:text-opacity-100 transition-colors duration-200 z-10`}
                      >
                        <i
                          className={`fa-star ${
                            recipe.isFavorite ? "fas" : "far"
                          }`}
                        ></i>
                      </button>
                    </div>
                    <div className="p-3 sm:p-4 flex flex-col flex-grow">
                      <h3
                        className="text-base sm:text-lg font-semibold leading-tight mb-1 text-gray-900 dark:text-gray-100 line-clamp-2"
                        title={recipe.name}
                      >
                        {recipe.name}
                      </h3>
                      {recipe.description && (
                        <p
                          className="text-xs sm:text-sm text-gray-600 dark:text-gray-400 mt-1 mb-2 line-clamp-2"
                          title={recipe.description}
                        >
                          {recipe.description}
                        </p>
                      )}
                      {/* Course and Sub-Category display */}
                      <div className="flex flex-wrap gap-2 mb-2">
                        {recipe.course && (
                          <span className="inline-flex items-center gap-1 bg-pink-100 dark:bg-pink-900 text-pink-700 dark:text-pink-300 px-2 py-0.5 rounded-full">
                            <i className="fas fa-layer-group"></i>{" "}
                            {recipe.course}
                          </span>
                        )}
                        {recipe.subCategory && (
                          <span className="inline-flex items-center gap-1 bg-orange-100 dark:bg-orange-900 text-orange-700 dark:text-orange-300 px-2 py-0.5 rounded-full">
                            <i className="fas fa-th-list"></i>{" "}
                            {recipe.subCategory}
                          </span>
                        )}
                      </div>
                      <div className="flex flex-wrap gap-1 my-1 text-xs">
                        <span className="inline-flex items-center gap-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-2 py-0.5 rounded-full">
                          <i className="fas fa-utensils op-70"></i>{" "}
                          {recipe.type}
                        </span>
                        {recipe.cuisine && (
                          <span className="inline-flex items-center gap-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300 px-2 py-0.5 rounded-full">
                            <i className="fas fa-globe op-70"></i>{" "}
                            {recipe.cuisine}
                          </span>
                        )}
                        {recipe.dietaryTypes?.map((diet) => (
                          <span
                            key={diet}
                            className="inline-flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full"
                          >
                            <i className="fas fa-leaf opacity-70"></i> {diet}
                          </span>
                        ))}
                        {recipe.tags?.map((tag) => (
                          <span
                            key={tag}
                            className="inline-flex items-center gap-1 bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded-full tag-hover"
                            style={{ cursor: "pointer" }}
                            onClick={(e) => {
                              e.stopPropagation();
                              setTagModal({ open: true, tag });
                            }}
                            title={`Show other recipes with tag: ${tag}`}
                          >
                            <i className="fas fa-tag opacity-70"></i> {tag}
                          </span>
                        ))}
                      </div>
                      <div className="mt-auto pt-2 text-xs text-gray-500 dark:text-gray-400 grid grid-cols-2 gap-x-2 gap-y-1">
                        {recipe.prepTime > 0 && (
                          <span title="Prep Time">
                            <i className="fas fa-clock w-3 tc mr-0.5 op-70"></i>{" "}
                            Prep: {formatMinutesToHoursMinutes(recipe.prepTime)}
                          </span>
                        )}
                        {recipe.cookTime > 0 && (
                          <span title="Cook Time">
                            <i className="fas fa-fire w-3 tc mr-0.5 op-70"></i>{" "}
                            Cook: {formatMinutesToHoursMinutes(recipe.cookTime)}
                          </span>
                        )}
                        {recipe.additionalTime > 0 && (
                          <span title="Additional Time">
                            <i className="fas fa-hourglass-half w-3 tc mr-0.5 op-70"></i>{" "}
                            Additional:{" "}
                            {formatMinutesToHoursMinutes(recipe.additionalTime)}
                          </span>
                        )}
                        <span
                          className="col-span-2 text-green-600 dark:text-green-400 font-medium text-sm mt-1 inline-flex items-center gap-1"
                          title="Total Time"
                        >
                          <i className="fas fa-stopwatch"></i> Total:{" "}
                          {formatMinutesToHoursMinutes(
                            parseInt(recipe.prepTime || 0) +
                              parseInt(recipe.cookTime || 0) +
                              parseInt(recipe.additionalTime || 0),
                          )}
                        </span>
                      </div>
                    </div>
                  </div>
                ))
              ) : (
                <div className="col-span-full text-center text-gray-500 dark:text-gray-400 py-10 px-4 bg-white dark:bg-gray-800 rounded-lg shadow">
                  <i className="fas fa-search text-4xl mb-3 opacity-50"></i>
                  <p className="font-semibold">
                    {hideAllExplicitly
                      ? "Recipes are currently hidden."
                      : filters.query
                        ? "No recipes found matching your search."
                        : hasActiveFiltersExcludingQuery
                          ? "No recipes found matching your filters."
                          : "No recipes added yet."}
                  </p>
                  <p className="text-sm">
                    {hideAllExplicitly
                      ? "Click 'All' to show them."
                      : filters.query || hasActiveFiltersExcludingQuery
                        ? "Try adjusting filters or search terms."
                        : "Click 'Add' to create your first recipe!"}
                  </p>
                </div>
              )}
            </div>
            {/* Tag Modal */}
            {tagModal.open && (
              <div
                className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-40 modal-fade"
                onClick={() => setTagModal({ open: false, tag: null })}
              >
                <div
                  className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 max-w-lg w-full relative modal-fade"
                  onClick={(e) => e.stopPropagation()}
                >
                  <button
                    className="absolute top-2 right-2 text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 text-xl ripple"
                    onClick={() => setTagModal({ open: false, tag: null })}
                  >
                    &times;
                  </button>
                  <h2 className="text-lg font-semibold mb-3">
                    Recipes with tag:{" "}
                    <span className="text-purple-600 dark:text-purple-300">
                      {tagModal.tag}
                    </span>
                  </h2>
                  <div className="space-y-2 max-h-80 overflow-y-auto">
                    {recipes.filter(
                      (r) => r.tags && r.tags.includes(tagModal.tag),
                    ).length === 0 ? (
                      <div className="text-gray-400">
                        No other recipes found with this tag.
                      </div>
                    ) : (
                      recipes
                        .filter((r) => r.tags && r.tags.includes(tagModal.tag))
                        .map((r) => (
                          <div
                            key={r.id}
                            className="p-2 rounded hover:bg-purple-50 dark:hover:bg-purple-900 cursor-pointer flex items-center gap-3"
                            onClick={() => {
                              setTagModal({ open: false, tag: null });
                              openRecipeDetails(r);
                            }}
                          >
                            {r.image ? (
                              <img
                                src={r.image}
                                alt={r.name}
                                className="w-14 h-14 object-cover rounded shadow"
                              />
                            ) : (
                              <div className="w-14 h-14 flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded">
                                <i className="fas fa-image text-2xl text-gray-400 dark:text-gray-500"></i>
                              </div>
                            )}
                            <div className="flex flex-col flex-1 min-w-0">
                              <div className="font-medium truncate">
                                {r.name}
                              </div>
                              <div className="text-xs text-gray-500 dark:text-gray-400 line-clamp-1">
                                {r.description}
                              </div>
                            </div>
                          </div>
                        ))
                    )}
                  </div>
                </div>
              </div>
            )}
          </section>
        );
      };

      const TagInput = ({ tags, setTags, maxTags = 10, addToast }) => {
        const [inputValue, setInputValue] = useState("");

        const handleKeyDown = (e) => {
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault();
            const newTag = inputValue.trim();

            if (
              newTag &&
              tags.length < maxTags &&
              !tags.some((t) => t.toLowerCase() === newTag.toLowerCase())
            ) {
              setTags([...tags, newTag]);
            } else if (tags.length >= maxTags) {
              addToast(`Maximum ${maxTags} tags allowed.`, "error");
            } else if (
              newTag &&
              tags.some((t) => t.toLowerCase() === newTag.toLowerCase())
            ) {
              addToast(`Tag "${newTag}" already added.`, "info");
            }
            setInputValue("");
          } else if (e.key === "Backspace" && !inputValue && tags.length > 0) {
            removeTag(tags.length - 1);
          }
        };

        const removeTag = (indexToRemove) => {
          setTags(tags.filter((_, index) => index !== indexToRemove));
        };

        return (
          <div className="tag-input-container">
            {tags.map((tag, index) => (
              <span key={index} className="tag-item">
                {tag}
                <button
                  type="button"
                  className="tag-item-remove"
                  onClick={() => removeTag(index)}
                  aria-label={`Remove tag ${tag}`}
                >
                  &times;
                </button>
              </span>
            ))}
            <input
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="Add a tag"
              className="flex-grow border-none outline-none text-sm text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 bg-transparent"
              aria-label="Tag input"
            />
          </div>
        );
      };

      const AddRecipeModal = ({
        onClose,
        addRecipe,
        updateRecipe,
        editingRecipe,
        addToast,
      }) => {
        const initialFormState = useMemo(
          () => ({
            name: "",
            description: "",
            type: "",
            course: "",
            subCategory: "",
            cuisine: "",
            dietaryTypes: "",
            prepHours: "",
            prepMinutes: "",
            cookHours: "",
            cookMinutes: "",
            additionalHours: "",
            additionalMinutes: "",
            calories: "",
            protein: "",
            carbs: "",
            fat: "",
            servings: "4",
            yield: "",
            ingredients: "",
            directions: "",
            tipsAndTricks: "",
            image: null,
            video: null,
          }),
          [],
        );
        const [formData, setFormData] = useState(initialFormState);
        const [tags, setTags] = useState([]);
        const [tipsAndTricks, setTipsAndTricks] = useState([]);
        const [imagePreview, setImagePreview] = useState(null);
        const [videoPreview, setVideoPreview] = useState(null);
        const [formErrors, setFormErrors] = useState({});

        useEffect(() => {
          if (editingRecipe) {
            const getHours = (totalMins) => Math.floor(totalMins / 60);
            const getMinutes = (totalMins) => totalMins % 60;

            setFormData({
              name: editingRecipe.name || "",
              description: editingRecipe.description || "",
              type: editingRecipe.type || "",
              course: editingRecipe.course || "",
              subCategory: editingRecipe.subCategory || "",
              cuisine: editingRecipe.cuisine || "",
              dietaryTypes: Array.isArray(editingRecipe.dietaryTypes)
                ? editingRecipe.dietaryTypes.join(", ")
                : "",
              prepHours: getHours(editingRecipe.prepTime || 0),
              prepMinutes: getMinutes(editingRecipe.prepTime || 0),
              cookHours: getHours(editingRecipe.cookTime || 0),
              cookMinutes: getMinutes(editingRecipe.cookTime || 0),
              additionalHours: getHours(editingRecipe.additionalTime || 0),
              additionalMinutes: getMinutes(editingRecipe.additionalTime || 0),
              calories: editingRecipe.calories ?? "",
              protein: editingRecipe.protein ?? "",
              carbs: editingRecipe.carbs ?? "",
              fat: editingRecipe.fat ?? "",
              servings: editingRecipe.servings ?? "4",
              yield: editingRecipe.yield || "",
              ingredients: Array.isArray(editingRecipe.ingredients)
                ? editingRecipe.ingredients.join("\n")
                : "",
              directions: Array.isArray(editingRecipe.directions)
                ? editingRecipe.directions.join("\n")
                : "",
              tipsAndTricks: Array.isArray(editingRecipe.tipsAndTricks)
                ? editingRecipe.tipsAndTricks.join("\n")
                : "",
              image: editingRecipe.image || null,
              video: editingRecipe.video || null,
            });
            setTags(
              Array.isArray(editingRecipe.tags) ? editingRecipe.tags : [],
            );
            setTipsAndTricks(
              Array.isArray(editingRecipe.tipsAndTricks)
                ? editingRecipe.tipsAndTricks
                : [],
            );
            setImagePreview(editingRecipe.image || null);
            setVideoPreview(editingRecipe.video || null);
          } else {
            setFormData(initialFormState);
            setTags([]);
            setTipsAndTricks([]);
            setImagePreview(null);
            setVideoPreview(null);
          }
          setFormErrors({});
        }, [editingRecipe, initialFormState]);

        const handleChange = useCallback(
          (e) => {
            const { name, value } = e.target;
            setFormData((prev) => ({ ...prev, [name]: value }));
            if (formErrors[name])
              setFormErrors((prev) => ({ ...prev, [name]: null }));
          },
          [formErrors],
        );

        const handleFileChange = useCallback((e) => {
          const { name, files } = e.target;
          if (!files || files.length === 0) return;
          const file = files[0];

          const MAX_SIZE = 5 * 1024 * 1024;
          if (name === "image" && !file.type.startsWith("image/")) {
            setFormErrors((p) => ({ ...p, [name]: "File must be an image." }));
            return;
          }
          if (name === "video" && !file.type.startsWith("video/")) {
            setFormErrors((p) => ({ ...p, [name]: "File must be a video." }));
            return;
          }
          if (file.size > MAX_SIZE) {
            setFormErrors((p) => ({
              ...p,
              [name]: `File too large (Max ${MAX_SIZE / 1024 / 1024}MB).`,
            }));
            return;
          }

          const reader = new FileReader();
          reader.onload = (loadEvent) => {
            setFormData((prev) => ({
              ...prev,
              [name]: loadEvent.target.result,
            }));
            if (name === "image") setImagePreview(loadEvent.target.result);
            if (name === "video") setVideoPreview(loadEvent.target.result);
            setFormErrors((prev) => ({ ...prev, [name]: null }));
          };
          reader.onerror = () => {
            console.error("Error reading file:", reader.error);
            setFormErrors((prev) => ({ ...p, [name]: "Error reading file." }));
          };
          reader.readAsDataURL(file);
        }, []);

        const removeMedia = useCallback((mediaType) => {
          setFormData((prev) => ({ ...prev, [mediaType]: null }));
          if (mediaType === "image") setImagePreview(null);
          if (mediaType === "video") setVideoPreview(null);
          const fileInput = document.querySelector(`input[name=${mediaType}]`);
          if (fileInput) fileInput.value = "";
        }, []);

        const validateForm = useCallback(() => {
          const errors = {};
          if (!formData.name.trim()) errors.name = "Recipe name is required.";
          if (!formData.type.trim()) errors.type = "Recipe type is required.";
          if (!formData.ingredients.trim())
            errors.ingredients = "Ingredients are required.";
          if (!formData.directions.trim())
            errors.directions = "Directions are required.";
          const timeFields = ["prep", "cook", "additional"];
          timeFields.forEach((field) => {
            const hours = parseInt(formData[`${field}Hours`]) || 0;
            const minutes = parseInt(formData[`${field}Minutes`]) || 0;
            if (isNaN(hours) || hours < 0) {
              errors[`${field}Hours`] = `Invalid ${field} hours.`;
            }
            if (isNaN(minutes) || minutes < 0 || minutes >= 60) {
              errors[`${field}Minutes`] = `Invalid ${field} minutes (0-59).`;
            }
          });

          if (
            isNaN(parseInt(formData.servings)) ||
            parseInt(formData.servings) < 1
          )
            errors.servings = "Servings must be 1 or more.";
          if (formData.calories && isNaN(parseInt(formData.calories)))
            errors.calories = "Calories must be a number.";
          if (formData.protein && isNaN(parseFloat(formData.protein)))
            errors.protein = "Protein must be a number.";
          if (formData.carbs && isNaN(parseFloat(formData.carbs)))
            errors.carbs = "Carbs must be a number.";
          if (formData.fat && isNaN(parseFloat(formData.fat)))
            errors.fat = "Fat must be a number.";
          if (formData.yield && !formData.yield.trim()) {
            errors.yield = "Yield cannot be just empty spaces.";
          }

          setFormErrors(errors);
          return Object.keys(errors).length === 0;
        }, [formData]);

        const handleSubmit = useCallback(
          (e) => {
            e.preventDefault();
            if (!validateForm()) {
              addToast("Please fix errors before saving.", "error");
              return;
            }

            const calculateTotalMinutes = (hours, minutes) => {
              return (parseInt(hours) || 0) * 60 + (parseInt(minutes) || 0);
            };

            const recipeData = {
              name: formData.name.trim(),
              description: formData.description.trim(),
              type: formData.type.trim(),
              course: formData.course.trim(),
              subCategory: formData.subCategory.trim(),
              cuisine: formData.cuisine.trim(),
              dietaryTypes: formData.dietaryTypes
                .split(",")
                .map((t) => t.trim())
                .filter(Boolean),
              tags: tags,
              prepTime: calculateTotalMinutes(
                formData.prepHours,
                formData.prepMinutes,
              ),
              cookTime: calculateTotalMinutes(
                formData.cookHours,
                formData.cookMinutes,
              ),
              additionalTime: calculateTotalMinutes(
                formData.additionalHours,
                formData.additionalMinutes,
              ),
              calories: formData.calories ? parseInt(formData.calories) : null,
              protein: formData.protein ? parseFloat(formData.protein) : null,
              carbs: formData.carbs ? parseFloat(formData.carbs) : null,
              fat: formData.fat ? parseFloat(formData.fat) : null,
              servings: parseInt(formData.servings) || 1,
              yield: formData.yield.trim(),
              ingredients: formData.ingredients
                .split("\n")
                .map((i) => i.trim())
                .filter(Boolean),
              directions: formData.directions
                .split("\n")
                .map((d) => d.trim())
                .filter(Boolean),
              tipsAndTricks: formData.tipsAndTricks
                .split("\n")
                .map((tip) => tip.trim())
                .filter(Boolean),
              image: formData.image,
              video: formData.video,
            };

            if (editingRecipe) {
              updateRecipe(editingRecipe.id, recipeData);
            } else {
              addRecipe(recipeData);
            }
          },
          [
            formData,
            tags,
            editingRecipe,
            validateForm,
            addRecipe,
            updateRecipe,
            addToast,
          ],
        );

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose],
        );
        const mealTypes = [
          "Appetizers",
          "Burgers",
          "Desserts",
          "Garnishes",
          "Hotdogs/Bratwurst/Etc",
          "Loins",
          "Meatloafs",
          "Pastas",
          "Ribs",
          "Roasts",
          "Salads",
          "Sandwiches",
          "Seafood",
          "Soups/Stews",
          "Spices/Seasoning/Marinades",
          "Steaks",
          "Wraps",
        ].sort();
        const cuisineTypes = [
          "American",
          "Asian",
          "Mexican",
          "Italian",
          "Indian",
          "Mediterranean",
          "French",
          "Japanese",
          "Chinese",
          "Thai",
          "Vietnamese",
          "Korean",
          "Middle Eastern",
          "African",
          "Caribbean",
          "South American",
          "German",
          "Spanish",
          "Greek",
          "British",
          "Australian",
          "Canadian",
          "Fusion",
          "Other",
        ].sort();
        const dietaryTypesList = [
          "Gluten-Free",
          "Dairy-Free",
          "Nut-Free",
          "Vegan",
          "Vegetarian",
          "Pescatarian",
          "Keto",
          "Paleo",
          "Low-Carb",
          "Low-Fat",
          "Sugar-Free",
          "Soy-Free",
        ];

        const ErrorMessage = ({ name }) =>
          formErrors[name] ? (
            <p className="text-red-500 text-xs mt-1">{formErrors[name]}</p>
          ) : null;

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-5 sm:p-6 w-full max-w-3xl max-h-[90vh] overflow-y-auto modal-scale-enter">
              <div className="flex justify-between items-center mb-5 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h2 className="text-xl sm:text-2xl font-semibold text-gray-900 dark:text-gray-100">
                  {editingRecipe ? "Edit Recipe" : "Add New Recipe"}
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>
              <form onSubmit={handleSubmit} className="space-y-4" noValidate>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="name"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Name *
                    </label>
                    <input
                      type="text"
                      id="name"
                      name="name"
                      value={formData.name}
                      onChange={handleChange}
                      required
                      className={`modal-input ${formErrors.name ? "border-red-500" : "border-gray-300 dark:border-gray-600"}`}
                    />
                    <ErrorMessage name="name" />
                  </div>
                  <div>
                    <label
                      htmlFor="course"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Course *
                    </label>
                    <select
                      id="course"
                      name="course"
                      value={formData.course}
                      onChange={handleChange}
                      required
                      className={`modal-input ${formErrors.course ? "border-red-500" : "border-gray-300 dark:border-gray-600"}`}
                    >
                      <option value="">Select a course</option>
                      <option value="Appetizers">Appetizers</option>
                      <option value="Beverages">Beverages</option>
                      <option value="Breads">Breads</option>
                      <option value="Desserts">Desserts</option>
                      <option value="Main">Main</option>
                      <option value="Dressings/Marinades/Sauces/Seasonings">
                        Dressings/Marinades/Sauces/Seasonings
                      </option>
                      <option value="Salads">Salads</option>
                      <option value="Soups/Stews">Soups/Stews</option>
                    </select>
                    <ErrorMessage name="course" />
                  </div>
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="subCategory"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Sub-Category *
                    </label>
                    <input
                      type="text"
                      id="subCategory"
                      name="subCategory"
                      value={formData.subCategory}
                      onChange={handleChange}
                      required
                      className={`modal-input ${formErrors.subCategory ? "border-red-500" : "border-gray-300 dark:border-gray-600"}`}
                      placeholder="e.g., Pasta, Grilled, Soups and Stews, Baked"
                    />
                    <ErrorMessage name="subCategory" />
                  </div>
                  <div>
                    <label
                      htmlFor="type"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Type <span className="text-xs">(optional)</span>
                    </label>
                    <input
                      type="text"
                      id="type"
                      name="type"
                      value={formData.type}
                      onChange={handleChange}
                      list="meal-types"
                      className={`modal-input ${formErrors.type ? "border-red-500" : "border-gray-300 dark:border-gray-600"}`}
                    />
                    <datalist id="meal-types">
                      {mealTypes.map((t) => (
                        <option key={t} value={t} />
                      ))}
                    </datalist>
                    <ErrorMessage name="type" />
                  </div>
                </div>
                <div>
                  <label
                    htmlFor="description"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Description <span className="text-xs">(optional)</span>
                  </label>
                  <textarea
                    id="description"
                    name="description"
                    value={formData.description}
                    onChange={handleChange}
                    rows="2"
                    className="modal-textarea border-gray-300 dark:border-gray-600"
                  ></textarea>
                  <ErrorMessage name="description" />
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="servings"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Servings *
                    </label>
                    <input
                      type="number"
                      id="servings"
                      name="servings"
                      value={formData.servings}
                      onChange={handleChange}
                      min="1"
                      required
                      className={`modal-input ${
                        formErrors.servings
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <ErrorMessage name="servings" />
                  </div>
                  <div>
                    <label
                      htmlFor="yield"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Yield <span className="text-xs">(e.g., 1.5 cups)</span>
                    </label>
                    <input
                      type="text"
                      id="yield"
                      name="yield"
                      value={formData.yield}
                      onChange={handleChange}
                      className={`modal-input ${
                        formErrors.yield
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                      placeholder="e.g., 8 servings, 2 dozen, 1 gallon"
                    />
                    <ErrorMessage name="yield" />
                  </div>
                </div>
                <div>
                  <label
                    htmlFor="cuisine"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Cuisine <span className="text-xs">(optional)</span>
                  </label>
                  <input
                    type="text"
                    id="cuisine"
                    name="cuisine"
                    value={formData.cuisine}
                    onChange={handleChange}
                    list="cuisine-types"
                    className="modal-input border-gray-300 dark:border-gray-600"
                    placeholder="e.g., Italian, Mexican, American"
                  />
                  <datalist id="cuisine-types">
                    {cuisineTypes.map((c) => (
                      <option key={c} value={c} />
                    ))}
                  </datalist>
                </div>
                <div>
                  <label
                    htmlFor="dietaryTypes"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Dietary <span className="text-xs">(comma-sep)</span>
                  </label>
                  <input
                    type="text"
                    id="dietaryTypes"
                    name="dietaryTypes"
                    value={formData.dietaryTypes}
                    onChange={handleChange}
                    list="dietary-types"
                    className="modal-input border-gray-300 dark:border-gray-600"
                  />
                  <datalist id="dietary-types">
                    {dietaryTypesList.map((t) => (
                      <option key={t} value={t} />
                    ))}
                  </datalist>
                </div>
                <div>
                  <label
                    htmlFor="tags"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Tags <span className="text-xs">(press Enter/comma)</span>
                  </label>
                  <TagInput tags={tags} setTags={setTags} addToast={addToast} />
                  <ErrorMessage name="tags" />
                </div>
                <fieldset className="border border-gray-300 dark:border-gray-600 p-3 rounded">
                  <legend className="text-sm font-medium px-1 text-gray-700 dark:text-gray-300">
                    Time
                  </legend>
                  <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Prep Time *
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="prepHours"
                          value={formData.prepHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.prepHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="prepMinutes"
                          value={formData.prepMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.prepMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="prepHours" />{" "}
                      <ErrorMessage name="prepMinutes" />
                    </div>
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Cook Time *
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="cookHours"
                          value={formData.cookHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.cookHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="cookMinutes"
                          value={formData.cookMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.cookMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="cookHours" />{" "}
                      <ErrorMessage name="cookMinutes" />
                    </div>
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Additional Time
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="additionalHours"
                          value={formData.additionalHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.additionalHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="additionalMinutes"
                          value={formData.additionalMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.additionalMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="additionalHours" />{" "}
                      <ErrorMessage name="additionalMinutes" />
                    </div>
                  </div>
                </fieldset>
                <fieldset className="border border-gray-300 dark:border-gray-600 p-3 rounded">
                  <legend className="text-sm font-medium px-1 text-gray-700 dark:text-gray-300">
                    Nutrition (per serving, optional)
                  </legend>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                    <div>
                      <label
                        htmlFor="calories"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Calories
                      </label>
                      <input
                        type="number"
                        id="calories"
                        name="calories"
                        value={formData.calories}
                        onChange={handleChange}
                        min="0"
                        className={`modal-input-sm ${
                          formErrors.calories
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="calories" />
                    </div>
                    <div>
                      <label
                        htmlFor="protein"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Protein (g)
                      </label>
                      <input
                        type="number"
                        id="protein"
                        name="protein"
                        value={formData.protein}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.protein
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="protein" />
                    </div>
                    <div>
                      <label
                        htmlFor="carbs"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Carbs (g)
                      </label>
                      <input
                        type="number"
                        id="carbs"
                        name="carbs"
                        value={formData.carbs}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.carbs
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="carbs" />
                    </div>
                    <div>
                      <label
                        htmlFor="fat"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Fat (g)
                      </label>
                      <input
                        type="number"
                        id="fat"
                        name="fat"
                        value={formData.fat}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.fat
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="fat" />
                    </div>
                  </div>
                </fieldset>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="ingredients"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Ingredients *{" "}
                      <span className="text-xs">(one per line)</span>
                    </label>
                    <textarea
                      id="ingredients"
                      name="ingredients"
                      value={formData.ingredients}
                      onChange={handleChange}
                      rows="6"
                      required
                      className={`modal-textarea ${
                        formErrors.ingredients
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    ></textarea>
                    <ErrorMessage name="ingredients" />
                  </div>
                  <div>
                    <label
                      htmlFor="directions"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Directions *{" "}
                      <span className="text-xs">(one step per line)</span>
                    </label>
                    <textarea
                      id="directions"
                      name="directions"
                      value={formData.directions}
                      onChange={handleChange}
                      rows="6"
                      required
                      className={`modal-textarea ${
                        formErrors.directions
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    ></textarea>
                    <ErrorMessage name="directions" />
                  </div>
                </div>
                <div>
                  <label
                    htmlFor="tipsAndTricks"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Tips & Tricks{" "}
                    <span className="text-xs">(one tip per line)</span>
                  </label>
                  <textarea
                    id="tipsAndTricks"
                    name="tipsAndTricks"
                    value={formData.tipsAndTricks}
                    onChange={handleChange}
                    rows="4"
                    className="modal-textarea border-gray-300 dark:border-gray-600"
                    placeholder="e.g., If you don't have fresh basil, use 1 tsp dried basil. This recipe freezes well!"
                  ></textarea>
                </div>
                <div>
                  <label
                    htmlFor="image"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Image
                  </label>
                  <input
                    type="file"
                    id="image"
                    name="image"
                    accept="image/*"
                    onChange={handleFileChange}
                    className={`block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 dark:file:bg-gray-600 file:text-green-700 dark:file:text-gray-200 hover:file:bg-green-100 dark:hover:file:bg-gray-500 cursor-pointer ${
                      formErrors.image ? "border border-red-500 rounded-md" : ""
                    }`}
                  />
                  <ErrorMessage name="image" />
                  {imagePreview && (
                    <div className="mt-2 relative group w-32 h-32 border border-gray-300 dark:border-gray-600 rounded overflow-hidden">
                      <img
                        src={imagePreview}
                        alt="Preview"
                        className="w-full h-full object-cover"
                      />
                      <button
                        type="button"
                        onClick={() => removeMedia("image")}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                        aria-label="Remove image"
                      >
                        &times;
                      </button>
                    </div>
                  )}
                </div>
                <div>
                  <label
                    htmlFor="video"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Video
                  </label>
                  <input
                    type="file"
                    id="video"
                    name="video"
                    accept="video/*"
                    onChange={handleFileChange}
                    className={`block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-600 file:text-blue-700 dark:file:text-gray-200 hover:file:bg-blue-100 dark:hover:file:bg-gray-500 cursor-pointer ${
                      formErrors.video ? "border border-red-500 rounded-md" : ""
                    }`}
                  />
                  <ErrorMessage name="video" />
                  {videoPreview && (
                    <div className="mt-2 relative group max-w-xs border border-gray-300 dark:border-gray-600 rounded overflow-hidden">
                      <video
                        controls
                        className="w-full rounded max-h-40 block bg-black"
                      >
                        <source src={videoPreview} /> No video support.
                      </video>
                      <button
                        type="button"
                        onClick={() => removeMedia("video")}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                        aria-label="Remove video"
                      >
                        &times;
                      </button>
                    </div>
                  )}
                </div>
                <div className="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-600 mt-5">
                  <button
                    type="button"
                    onClick={onClose}
                    className="btn-modal btn-gray"
                  >
                    Cancel
                  </button>
                  <button type="submit" className="btn-modal btn-green">
                    {editingRecipe ? "Save Changes" : "Add Recipe"}
                  </button>
                </div>
              </form>
            </div>
          </div>
        );
      };

      const AddToMealPlanSelectorModal = ({
        recipe,
        mealPlan,
        updateMealPlan,
        onClose,
        addToast,
        recipes,
      }) => {
        const days = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];
        const mealTimes = [
          { id: "breakfast", label: "Breakfast", icon: "fa-coffee" },
          { id: "morningSnack", label: "M. Snack", icon: "fa-apple-alt" },
          { id: "lunch", label: "Lunch", icon: "fa-utensils" },
          { id: "afternoonSnack", label: "A. Snack", icon: "fa-cookie-bite" },
          { id: "dinner", label: "Dinner", icon: "fa-drumstick-bite" },
        ];
        const [selectedDay, setSelectedDay] = useState(days[0]);
        const [selectedMealTime, setSelectedMealTime] = useState(
          mealTimes[0].id,
        );

        const currentRecipesInSlot = useMemo(() => {
          return mealPlan?.[selectedDay]?.[selectedMealTime] || [];
        }, [mealPlan, selectedDay, selectedMealTime]);

        const handleAdd = useCallback(() => {
          if (recipe && selectedDay && selectedMealTime) {
            if (currentRecipesInSlot.includes(recipe.id)) {
              addToast("Recipe is already in this slot.", "info");
            } else {
              updateMealPlan(selectedDay, selectedMealTime, recipe.id);
            }
            onClose();
          } else {
            addToast("Please select a day and meal time.", "error");
          }
        }, [
          recipe,
          selectedDay,
          selectedMealTime,
          updateMealPlan,
          onClose,
          addToast,
          currentRecipesInSlot,
        ]);

        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose],
        );

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[60] p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-5 w-full max-w-sm modal-scale-enter">
              <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h3 className="text-lg sm:text-xl font-semibold text-gray-900 dark:text-gray-100">
                  Add "{escapeHTML(recipe.name)}" to Meal Plan
                </h3>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-2xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>
              <div className="space-y-4">
                <div>
                  <label
                    htmlFor="selectDay"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Select Day:
                  </label>
                  <select
                    id="selectDay"
                    value={selectedDay}
                    onChange={(e) => setSelectedDay(e.target.value)}
                    className="modal-input-sm"
                  >
                    {days.map((day) => (
                      <option key={day} value={day}>
                        {day}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label
                    htmlFor="selectMealTime"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Select Meal Time:
                  </label>
                  <select
                    id="selectMealTime"
                    value={selectedMealTime}
                    onChange={(e) => setSelectedMealTime(e.target.value)}
                    className="modal-input-sm"
                  >
                    {mealTimes.map((time) => (
                      <option key={time.id} value={time.id}>
                        {time.label}
                      </option>
                    ))}
                  </select>
                </div>
                <div className="text-sm text-gray-600 dark:text-gray-400">
                  Current assignment for {selectedDay}{" "}
                  {mealTimes.find((mt) => mt.id === selectedMealTime)?.label}:
                  <div className="font-semibold mt-1">
                    {currentRecipesInSlot.length > 0
                      ? currentRecipesInSlot.map((id, index) => {
                          const assignedRecipe = recipes.find(
                            (r) => r.id === id,
                          );
                          return (
                            <span key={id} className="block">
                              {assignedRecipe?.name || "Unknown Recipe"}
                              {index < currentRecipesInSlot.length - 1 && ", "}
                            </span>
                          );
                        })
                      : "None"}
                  </div>
                </div>
                <div className="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-600">
                  <button
                    type="button"
                    onClick={onClose}
                    className="btn-modal btn-gray"
                  >
                    Cancel
                  </button>
                  <button
                    type="button"
                    onClick={handleAdd}
                    className="btn-modal btn-green"
                  >
                    Add to Plan
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // ===== COOKING MODE COMPONENT =====
      const CookingModeModal = ({
        recipe,
        onClose,
        addTimer,
        servingsMultiplier = 1,
      }) => {
        const [currentStep, setCurrentStep] = useState(0);
        const directions = recipe?.directions || [];
        const totalSteps = directions.length;

        const parseTimeFromDirection = (text) => {
          const timePartRegex = /(\d+(\.\d+)?)\s+(seconds?|minutes?|hours?)/gi;
          const matches = [...text.matchAll(timePartRegex)];
          if (matches.length === 0) return null;
          let maxSeconds = 0;
          for (const match of matches) {
            const value = parseFloat(match[1]);
            const unit = match[3].toLowerCase();
            let currentSeconds = 0;
            if (unit.startsWith("second")) currentSeconds = value;
            else if (unit.startsWith("minute")) currentSeconds = value * 60;
            else if (unit.startsWith("hour")) currentSeconds = value * 3600;
            if (currentSeconds > maxSeconds) maxSeconds = currentSeconds;
          }
          return maxSeconds > 0 ? maxSeconds : null;
        };

        const currentStepTime = parseTimeFromDirection(directions[currentStep]);

        const goNext = () => {
          if (currentStep < totalSteps - 1) setCurrentStep(currentStep + 1);
        };

        const goPrevious = () => {
          if (currentStep > 0) setCurrentStep(currentStep - 1);
        };

        const handleKeyDown = useCallback(
          (e) => {
            if (e.key === "ArrowRight" || e.key === " ") {
              e.preventDefault();
              goNext();
            } else if (e.key === "ArrowLeft") {
              e.preventDefault();
              goPrevious();
            } else if (e.key === "Escape") {
              onClose();
            }
          },
          [currentStep],
        );

        useEffect(() => {
          document.addEventListener("keydown", handleKeyDown);
          return () => document.removeEventListener("keydown", handleKeyDown);
        }, [handleKeyDown]);

        if (!recipe || totalSteps === 0) return null;

        return (
          <div
            className="fixed inset-0 bg-black z-50 flex flex-col"
            onClick={(e) => {
              if (e.target === e.currentTarget) goNext();
            }}
          >
            {/* Header */}
            <div className="bg-gray-900 text-white p-4 flex justify-between items-center">
              <div className="flex-1">
                <h2 className="text-xl md:text-2xl font-bold">{recipe.name}</h2>
                <p className="text-sm text-gray-400">
                  Cooking Mode ‚Ä¢ Step {currentStep + 1} of {totalSteps}
                </p>
              </div>
              <button
                onClick={onClose}
                className="text-white hover:text-red-500 text-3xl px-4"
                aria-label="Exit cooking mode"
              >
                √ó
              </button>
            </div>

            {/* Main Content - Tap anywhere to advance */}
            <div
              className="flex-1 flex flex-col items-center justify-center p-8 text-white cursor-pointer"
              onClick={goNext}
            >
              <div className="max-w-4xl w-full">
                <div className="text-6xl md:text-8xl font-bold text-green-500 mb-8 text-center">
                  {currentStep + 1}
                </div>
                <p className="text-2xl md:text-4xl leading-relaxed text-center mb-8">
                  {directions[currentStep]}
                </p>
                {currentStepTime && (
                  <div className="flex justify-center">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        addTimer(
                          currentStepTime,
                          `Step ${currentStep + 1}: ${recipe.name}`,
                        );
                      }}
                      className="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg text-lg flex items-center gap-2"
                    >
                      <i className="fas fa-stopwatch"></i>
                      Start Timer ({Math.round(currentStepTime / 60)} min)
                    </button>
                  </div>
                )}
              </div>
            </div>

            {/* Navigation Footer */}
            <div className="bg-gray-900 text-white p-4 flex justify-between items-center">
              <button
                onClick={goPrevious}
                disabled={currentStep === 0}
                className={`px-6 py-3 rounded-lg text-lg ${
                  currentStep === 0
                    ? "bg-gray-700 text-gray-500 cursor-not-allowed"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                <i className="fas fa-arrow-left mr-2"></i> Previous
              </button>
              <div className="text-sm text-gray-400">
                Tap anywhere or press{" "}
                <kbd className="bg-gray-700 px-2 py-1 rounded">Space</kbd> to
                advance
              </div>
              <button
                onClick={goNext}
                disabled={currentStep === totalSteps - 1}
                className={`px-6 py-3 rounded-lg text-lg ${
                  currentStep === totalSteps - 1
                    ? "bg-gray-700 text-gray-500 cursor-not-allowed"
                    : "bg-green-500 hover:bg-green-600"
                }`}
              >
                {currentStep === totalSteps - 1 ? "Done" : "Next"}{" "}
                <i className="fas fa-arrow-right ml-2"></i>
              </button>
            </div>
          </div>
        );
      };

      // ===== RECIPE COLLECTIONS MODAL =====
      const RecipeCollectionsModal = ({
        collections,
        setCollections,
        recipes,
        onClose,
        onSelectCollection,
        addToast,
      }) => {
        const [newCollectionName, setNewCollectionName] = useState("");
        const [editingId, setEditingId] = useState(null);
        const [editingName, setEditingName] = useState("");

        const handleCreateCollection = () => {
          if (!newCollectionName.trim()) {
            addToast("Please enter a collection name", "error");
            return;
          }
          const newCollection = {
            id: Date.now().toString(),
            name: newCollectionName,
            recipeIds: [],
            createdAt: new Date().toISOString(),
          };
          setCollections([...collections, newCollection]);
          setNewCollectionName("");
          addToast(`Collection "${newCollectionName}" created!`, "success");
        };

        const handleDeleteCollection = (id) => {
          if (confirm("Are you sure you want to delete this collection?")) {
            setCollections(collections.filter((c) => c.id !== id));
            addToast("Collection deleted", "success");
          }
        };

        const handleRenameCollection = (id) => {
          if (!editingName.trim()) {
            addToast("Please enter a collection name", "error");
            return;
          }
          setCollections(
            collections.map((c) =>
              c.id === id ? { ...c, name: editingName } : c,
            ),
          );
          setEditingId(null);
          setEditingName("");
          addToast("Collection renamed", "success");
        };

        const getRecipeCount = (collection) => {
          return collection.recipeIds ? collection.recipeIds.length : 0;
        };

        return (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col">
              <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
                  <i className="fas fa-folder mr-2 text-green-500"></i>
                  Recipe Collections
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 hover:text-red-500 text-3xl leading-none"
                >
                  √ó
                </button>
              </div>

              <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                <div className="flex gap-2">
                  <input
                    type="text"
                    placeholder="New collection name..."
                    value={newCollectionName}
                    onChange={(e) => setNewCollectionName(e.target.value)}
                    onKeyPress={(e) =>
                      e.key === "Enter" && handleCreateCollection()
                    }
                    className="modal-input flex-1"
                  />
                  <button
                    onClick={handleCreateCollection}
                    className="btn-modal bg-green-500 hover:bg-green-600 text-white"
                  >
                    <i className="fas fa-plus mr-1"></i> Create
                  </button>
                </div>
              </div>

              <div className="flex-1 overflow-y-auto p-4">
                {collections.length === 0 ? (
                  <div className="text-center py-12 text-gray-500 dark:text-gray-400">
                    <i className="fas fa-folder-open text-6xl mb-4 opacity-50"></i>
                    <p>No collections yet. Create your first one above!</p>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {collections.map((collection) => (
                      <div
                        key={collection.id}
                        className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 border-2 border-gray-200 dark:border-gray-600 hover:border-green-500 transition cursor-pointer"
                        onClick={() => {
                          onSelectCollection(collection);
                          onClose();
                        }}
                      >
                        {editingId === collection.id ? (
                          <div
                            className="flex gap-2"
                            onClick={(e) => e.stopPropagation()}
                          >
                            <input
                              type="text"
                              value={editingName}
                              onChange={(e) => setEditingName(e.target.value)}
                              onKeyPress={(e) => {
                                if (e.key === "Enter")
                                  handleRenameCollection(collection.id);
                              }}
                              className="modal-input-sm flex-1"
                              autoFocus
                            />
                            <button
                              onClick={() =>
                                handleRenameCollection(collection.id)
                              }
                              className="text-green-500 hover:text-green-700"
                            >
                              <i className="fas fa-check"></i>
                            </button>
                            <button
                              onClick={() => {
                                setEditingId(null);
                                setEditingName("");
                              }}
                              className="text-red-500 hover:text-red-700"
                            >
                              <i className="fas fa-times"></i>
                            </button>
                          </div>
                        ) : (
                          <>
                            <div className="flex justify-between items-start mb-2">
                              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                                <i className="fas fa-folder text-green-500 mr-2"></i>
                                {collection.name}
                              </h3>
                              <div
                                className="flex gap-2"
                                onClick={(e) => e.stopPropagation()}
                              >
                                <button
                                  onClick={() => {
                                    setEditingId(collection.id);
                                    setEditingName(collection.name);
                                  }}
                                  className="text-blue-500 hover:text-blue-700 text-sm"
                                  title="Rename"
                                >
                                  <i className="fas fa-edit"></i>
                                </button>
                                <button
                                  onClick={() =>
                                    handleDeleteCollection(collection.id)
                                  }
                                  className="text-red-500 hover:text-red-700 text-sm"
                                  title="Delete"
                                >
                                  <i className="fas fa-trash"></i>
                                </button>
                              </div>
                            </div>
                            <p className="text-sm text-gray-600 dark:text-gray-400">
                              {getRecipeCount(collection)} recipe
                              {getRecipeCount(collection) !== 1 ? "s" : ""}
                            </p>
                          </>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      // Modal for adding recipes to a collection
      const AddRecipesToCollectionModal = ({
        collection,
        collections,
        setCollections,
        recipes,
        onClose,
        addToast,
      }) => {
        const [selectedRecipes, setSelectedRecipes] = useState(new Set());
        const [searchQuery, setSearchQuery] = useState("");

        // Get recipes not already in this collection
        const availableRecipes = recipes.filter(
          (recipe) => !collection.recipeIds?.includes(recipe.id),
        );

        // Filter by search
        const filteredRecipes = availableRecipes.filter((recipe) =>
          recipe.name.toLowerCase().includes(searchQuery.toLowerCase()),
        );

        const toggleRecipe = (recipeId) => {
          const newSet = new Set(selectedRecipes);
          if (newSet.has(recipeId)) {
            newSet.delete(recipeId);
          } else {
            newSet.add(recipeId);
          }
          setSelectedRecipes(newSet);
        };

        const handleAddRecipes = () => {
          if (selectedRecipes.size === 0) {
            addToast("Please select at least one recipe", "error");
            return;
          }

          setCollections(
            collections.map((c) =>
              c.id === collection.id
                ? {
                    ...c,
                    recipeIds: [
                      ...(c.recipeIds || []),
                      ...Array.from(selectedRecipes),
                    ],
                  }
                : c,
            ),
          );

          addToast(
            `Added ${selectedRecipes.size} recipe${selectedRecipes.size !== 1 ? "s" : ""} to "${collection.name}"`,
            "success",
          );
          onClose();
        };

        return (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-3xl w-full max-h-[90vh] overflow-hidden flex flex-col">
              <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                <h2 className="text-2xl font-bold text-gray-900 dark:text-white">
                  <i className="fas fa-plus-circle mr-2 text-green-500"></i>
                  Add Recipes to "{collection.name}"
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 hover:text-red-500 text-3xl leading-none"
                >
                  √ó
                </button>
              </div>

              <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                <input
                  type="text"
                  placeholder="Search recipes..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="modal-input w-full"
                />
                <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">
                  {selectedRecipes.size} recipe
                  {selectedRecipes.size !== 1 ? "s" : ""} selected
                </p>
              </div>

              <div className="flex-1 overflow-y-auto p-4">
                {filteredRecipes.length === 0 ? (
                  <div className="text-center py-12 text-gray-500 dark:text-gray-400">
                    <i className="fas fa-search text-6xl mb-4 opacity-50"></i>
                    <p>
                      {availableRecipes.length === 0
                        ? "All recipes are already in this collection!"
                        : "No recipes found matching your search."}
                    </p>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    {filteredRecipes.map((recipe) => (
                      <div
                        key={recipe.id}
                        onClick={() => toggleRecipe(recipe.id)}
                        className={`p-3 rounded-lg border-2 cursor-pointer transition ${
                          selectedRecipes.has(recipe.id)
                            ? "bg-green-50 dark:bg-green-900/20 border-green-500"
                            : "bg-gray-50 dark:bg-gray-700 border-gray-200 dark:border-gray-600 hover:border-green-300"
                        }`}
                      >
                        <div className="flex items-start gap-3">
                          <div className="flex-shrink-0 pt-1">
                            <div
                              className={`w-5 h-5 rounded border-2 flex items-center justify-center ${
                                selectedRecipes.has(recipe.id)
                                  ? "bg-green-500 border-green-500"
                                  : "border-gray-300 dark:border-gray-500"
                              }`}
                            >
                              {selectedRecipes.has(recipe.id) && (
                                <i className="fas fa-check text-white text-xs"></i>
                              )}
                            </div>
                          </div>
                          <div className="flex-1 min-w-0">
                            <h3 className="font-semibold text-gray-900 dark:text-white truncate">
                              {recipe.name}
                            </h3>
                            <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                              {recipe.type || "No type"} ‚Ä¢{" "}
                              {recipe.course || "No course"}
                            </p>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end gap-2">
                <button onClick={onClose} className="btn-modal btn-gray">
                  Cancel
                </button>
                <button
                  onClick={handleAddRecipes}
                  disabled={selectedRecipes.size === 0}
                  className="btn-modal bg-green-500 hover:bg-green-600 text-white disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <i className="fas fa-plus mr-1"></i>
                  Add {selectedRecipes.size > 0 && `(${selectedRecipes.size})`}
                </button>
              </div>
            </div>
          </div>
        );
      };

      const RecipeDetailsModal = ({
        recipe,
        onClose,
        addToShoppingList,
        generateRecipePDF,
        deleteRecipe,
        editRecipe,
        toggleFavorite,
        addToast,
        updateMealPlan,
        mealPlan,
        recipes,
        addTimer,
        pantry,
        shoppingList,
        setShoppingList,
        collections,
        setCollections,
      }) => {
        const baseServings = recipe?.servings > 0 ? recipe.servings : 1;
        const [currentServings, setCurrentServings] = useState(baseServings);
        const servingsMultiplier = currentServings / baseServings;
        const [showAddToMealPlanSelector, setShowAddToMealPlanSelector] =
          useState(false);
        const [showCookingMode, setShowCookingMode] = useState(false);
        const [showCollectionSelector, setShowCollectionSelector] =
          useState(false);
        const [showSubstitutions, setShowSubstitutions] = useState(false);

        // Calculate missing ingredients
        const missingIngredients = useMemo(() => {
          if (!pantry || !recipe?.ingredients) return recipe?.ingredients || [];
          const match = computeRecipeMatch(recipe, pantry);
          return match.missing || [];
        }, [recipe, pantry]);

        const handleServingsChange = useCallback((value) => {
          setCurrentServings(Math.max(1, parseInt(value) || 1));
        }, []);
        const totalTime = useMemo(
          () =>
            parseInt(recipe?.prepTime || 0) +
            parseInt(recipe?.cookTime || 0) +
            parseInt(recipe?.additionalTime || 0),
          [recipe],
        );
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose],
        );
        const scaledYield = useMemo(() => {
          if (recipe.yield) {
            return formatScaledYield(recipe.yield, servingsMultiplier);
          }
          return null;
        }, [recipe.yield, servingsMultiplier]);

        const getShareableText = useCallback(() => {
          let text = `Check out this recipe: ${recipe.name}\n\n`;
          if (recipe.description) {
            text += `${recipe.description}\n\n`;
          }
          text += `Servings: ${recipe.servings}\n`;
          text += `Total Time: ${formatMinutesToHoursMinutes(totalTime)}\n\n`;
          if (recipe.ingredients && recipe.ingredients.length > 0) {
            text += "Ingredients:\n";
            recipe.ingredients.forEach((ing) => {
              const { quantity, unit, description } = parseIngredient(ing);
              const scaledQuantity = quantity
                ? quantity * servingsMultiplier
                : null;
              text += `- ${
                scaledQuantity !== null
                  ? formatQuantity(scaledQuantity) + " "
                  : ""
              }${unit ? unit + " " : ""}${description}\n`;
            });
            text += "\n";
          }
          if (recipe.directions && recipe.directions.length > 0) {
            text += "Directions:\n";
            recipe.directions.forEach((dir, index) => {
              text += `${index + 1}. ${dir}\n`;
            });
            text += "\n";
          }
          if (recipe.tipsAndTricks && recipe.tipsAndTricks.length > 0) {
            text += "Tips & Tricks:\n";
            recipe.tipsAndTricks.forEach((tip) => {
              text += `- ${tip}\n`;
            });
            text += "\n";
          }
          text += "Find more recipes with Recipe Manager Pro!";
          return text;
        }, [recipe, totalTime, servingsMultiplier]);

        const handleShareRecipe = useCallback(async () => {
          const shareData = {
            title: `Recipe: ${recipe.name}`,
            text: getShareableText(),
          };
          if (navigator.share) {
            try {
              await navigator.share(shareData);
              addToast("Recipe shared successfully!", "success");
            } catch (err) {
              if (err.name === "AbortError") {
                addToast("Sharing cancelled.", "info");
              } else {
                console.error("Error sharing recipe:", err);
                addToast("Failed to share recipe.", "error");
              }
            }
          } else {
            try {
              const textToCopy = shareData.text;
              const textarea = document.createElement("textarea");
              textarea.value = textToCopy;
              textarea.style.position = "absolute";
              textarea.style.left = "-9999px";
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand("copy");
              document.body.removeChild(textarea);
              addToast("Recipe details copied to clipboard!", "info");
            } catch (err) {
              console.error("Failed to copy recipe to clipboard:", err);
              addToast("Failed to copy recipe details.", "error");
            }
          }
        }, [recipe, getShareableText, addToast]);

        const handleExportSingleRecipe = useCallback(async () => {
          try {
            const dataStr = JSON.stringify(recipe, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${recipe.name
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, "-")}-recipe.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            addToast("Recipe exported successfully!", "success");
          } catch (err) {
            console.error("Export single recipe error:", err);
            addToast("Error exporting recipe.", "error");
          }
        }, [recipe, addToast]);

        // Add missing ingredients to shopping list
        const handleAddMissingToShoppingList = useCallback(async () => {
          if (missingIngredients.length === 0) {
            addToast("All ingredients are already in your pantry!", "info");
            return;
          }

          const newItems = missingIngredients.map((ing, idx) => {
            const { quantity, unit, description } = parseIngredient(ing);
            const normalized = normalizeIngredient(ing);
            return {
              id:
                (Date.now() + idx).toString(36) +
                Math.random().toString(36).substr(2, 5),
              name: description || ing,
              description: description || ing,
              originalText: ing,
              normalizedText: normalized || (description || ing).toLowerCase(),
              quantity: quantity || 1,
              unit: unit || "",
              checked: false,
              category: "Groceries",
              recipeName: recipe?.name || "Manually Added",
              recipeId: recipe?.id || null,
            };
          });

          await setShoppingList((prev) => [...prev, ...newItems]);

          addToast(
            `Added ${missingIngredients.length} missing ingredient${missingIngredients.length !== 1 ? "s" : ""} to shopping list!`,
            "success",
          );
        }, [
          missingIngredients,
          setShoppingList,
          addToast,
          recipe,
          shoppingList,
        ]);

        // Print recipe
        const handlePrint = useCallback(() => {
          window.print();
        }, []);

        // Add to collection
        const handleAddToCollection = useCallback(
          (collection) => {
            if (!collection.recipeIds) collection.recipeIds = [];
            if (collection.recipeIds.includes(recipe.id)) {
              addToast("Recipe already in this collection", "info");
              return;
            }
            const updated = collections.map((c) =>
              c.id === collection.id
                ? { ...c, recipeIds: [...c.recipeIds, recipe.id] }
                : c,
            );
            setCollections(updated);
            addToast(`Added to "${collection.name}"`, "success");
            setShowCollectionSelector(false);
          },
          [recipe, collections, setCollections, addToast],
        );

        const parseTimeFromDirection = (text) => {
          // This regex finds all instances of a number (integer or decimal)
          // followed by a time unit (seconds, minutes, hours).
          // e.g., "2 hours", "30 minutes", "1.5 hours"
          const timePartRegex = /(\d+(\.\d+)?)\s+(seconds?|minutes?|hours?)/gi;
          const matches = [...text.matchAll(timePartRegex)];

          if (matches.length === 0) {
            return null;
          }

          let maxSeconds = 0;

          // In a direction like "cook for 30 minutes to 1 hour", we should take the longer time.
          // This loop finds all time mentions and returns the largest one in seconds.
          for (const match of matches) {
            const value = parseFloat(match[1]);
            const unit = match[3].toLowerCase();
            let currentSeconds = 0;

            if (unit.startsWith("second")) {
              currentSeconds = value;
            } else if (unit.startsWith("minute")) {
              currentSeconds = value * 60;
            } else if (unit.startsWith("hour")) {
              currentSeconds = value * 3600;
            }

            if (currentSeconds > maxSeconds) {
              maxSeconds = currentSeconds;
            }
          }

          return maxSeconds > 0 ? maxSeconds : null;
        };

        if (!recipe) return null;

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-5 sm:p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto modal-scale-enter">
              <div className="flex justify-between items-start mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 gap-4">
                <div className="flex-1">
                  <h2 className="text-2xl md:text-3xl font-bold mb-1 text-gray-900 dark:text-gray-100">
                    {escapeHTML(recipe.name)}
                  </h2>
                  {recipe.description && (
                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-3 italic">
                      {escapeHTML(recipe.description)}
                    </p>
                  )}
                  <div className="flex flex-wrap gap-x-2 gap-y-1 items-center text-xs sm:text-sm">
                    <span className="inline-flex items-center gap-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-2 py-0.5 rounded-full">
                      <i className="fas fa-utensils op-70"></i>{" "}
                      {escapeHTML(recipe.type)}
                    </span>
                    {recipe.cuisine && (
                      <span className="inline-flex items-center gap-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300 px-2 py-0.5 rounded-full">
                        <i className="fas fa-globe op-70"></i>{" "}
                        {escapeHTML(recipe.cuisine)}
                      </span>
                    )}
                    {recipe.dietaryTypes?.map((t) => (
                      <span
                        key={t}
                        className="inline-flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full"
                      >
                        <i className="fas fa-leaf op-70"></i> {escapeHTML(t)}
                      </span>
                    ))}
                    {recipe.tags?.map((tag) => (
                      <span
                        key={tag}
                        className="inline-flex items-center gap-1 bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded-full"
                      >
                        <i className="fas fa-tag opacity-70"></i>{" "}
                        {escapeHTML(tag)}
                      </span>
                    ))}
                  </div>
                </div>
                <div className="flex items-center gap-2 flex-shrink-0">
                  <button
                    onClick={() => toggleFavorite(recipe.id)}
                    className={`text-2xl p-1 rounded-full ${
                      recipe.isFavorite
                        ? "text-yellow-400 hover:text-yellow-500"
                        : "text-gray-400 hover:text-gray-500 dark:text-gray-500 dark:hover:text-gray-400"
                    }`}
                    title={
                      recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                    }
                    aria-label={
                      recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                    }
                  >
                    <i
                      className={`fa-star ${recipe.isFavorite ? "fas" : "far"}`}
                    ></i>
                  </button>
                  <button
                    onClick={onClose}
                    className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                    aria-label="Close"
                  >
                    &times;
                  </button>
                </div>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div className="md:col-span-1 space-y-4">
                  {recipe.image && (
                    <img
                      src={recipe.image}
                      alt={recipe.name}
                      className="w-full aspect-video object-cover rounded-lg shadow-md border border-gray-200 dark:border-gray-700"
                    />
                  )}
                  {recipe.video && (
                    <div>
                      <h3 className="text-base font-semibold mb-1 text-gray-800 dark:text-gray-200">
                        Video
                      </h3>
                      <video
                        controls
                        className="w-full rounded-lg shadow-md max-h-48 border border-gray-200 dark:border-gray-700 block bg-black"
                      >
                        <source src={recipe.video} /> No video support.
                      </video>
                    </div>
                  )}
                  <div className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md shadow-sm">
                    <label
                      htmlFor="servingsAdj"
                      className="font-medium text-sm mb-1.5 block text-gray-700 dark:text-gray-300"
                    >
                      Servings:
                    </label>
                    <div className="flex items-center justify-between gap-2">
                      <span className="text-xs text-gray-600 dark:text-gray-400">
                        Base: {baseServings}
                      </span>
                      <div className="flex items-center gap-1">
                        <button
                          onClick={() =>
                            handleServingsChange(currentServings - 1)
                          }
                          className="adjust-btn"
                          disabled={currentServings <= 1}
                          aria-label="Decrease servings"
                        >
                          -
                        </button>
                        <input
                          type="number"
                          id="servingsAdj"
                          value={currentServings}
                          onChange={(e) => handleServingsChange(e.target.value)}
                          min="1"
                          className="w-12 tc p-1 rounded border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-600 text-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-gray-900 dark:text-gray-100"
                          aria-label="Current servings"
                        />
                        <button
                          onClick={() =>
                            handleServingsChange(currentServings + 1)
                          }
                          className="adjust-btn"
                          aria-label="Increase servings"
                        >
                          +
                        </button>
                      </div>
                    </div>
                    {recipe.yield && (
                      <div className="mt-2 text-sm text-gray-700 dark:text-gray-300 flex justify-between items-center border-t border-gray-200 dark:border-gray-600 pt-2">
                        <span className="font-medium">Yield:</span>
                        <span>{scaledYield}</span>
                      </div>
                    )}
                  </div>
                  <div className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md shadow-sm space-y-1.5 text-sm text-gray-700 dark:text-gray-300">
                    <h4 className="font-semibold border-b border-gray-200 dark:border-gray-600 pb-1 mb-1.5 text-gray-800 dark:text-gray-200">
                      Quick Info{" "}
                      <span className="text-xs font-normal text-gray-500">
                        (per serving)
                      </span>
                    </h4>
                    <div className="flex justify-between">
                      <span>Prep:</span>{" "}
                      <span className="font-medium">
                        {formatMinutesToHoursMinutes(recipe.prepTime)}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Cook:</span>{" "}
                      <span className="font-medium">
                        {formatMinutesToHoursMinutes(recipe.cookTime)}
                      </span>
                    </div>
                    {recipe.additionalTime > 0 && (
                      <div className="flex justify-between">
                        <span>Additional:</span>{" "}
                        <span className="font-medium">
                          {formatMinutesToHoursMinutes(recipe.additionalTime)}
                        </span>
                      </div>
                    )}
                    <div className="flex justify-between font-semibold pt-1 border-t border-gray-200 dark:border-gray-600 mt-1">
                      <span>Total:</span>{" "}
                      <span>{formatMinutesToHoursMinutes(totalTime)}</span>
                    </div>
                    <div className="flex justify-between pt-1 border-t border-gray-200 dark:border-gray-600 mt-1">
                      <span>Calories:</span>{" "}
                      <span className="font-medium">
                        {recipe.calories || "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Protein:</span>{" "}
                      <span className="font-medium">
                        {recipe.protein ? `${recipe.protein}g` : "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Carbs:</span>
                      <span className="font-medium">
                        {recipe.carbs ? `${recipe.carbs}g` : "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Fat:</span>
                      <span className="font-medium">
                        {recipe.fat ? `${recipe.fat}g` : "N/A"}
                      </span>
                    </div>
                  </div>
                </div>
                <div className="md:col-span-2">
                  <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                      <i className="fas fa-list text-green-500"></i>Ingredients{" "}
                      <span className="text-base font-normal text-gray-500">
                        ({currentServings} servings)
                      </span>
                    </h3>
                    <ul className="list-none space-y-1 text-sm border border-gray-200 dark:border-gray-700 rounded-md p-3 bg-gray-50 dark:bg-gray-900 shadow-inner text-gray-800 dark:text-gray-200">
                      {recipe.ingredients?.map((ing, index) => {
                        const { quantity, unit, description } =
                          parseIngredient(ing);
                        const scaledQuantity = quantity
                          ? quantity * servingsMultiplier
                          : null;
                        return (
                          <li
                            key={index}
                            className="flex items-baseline gap-2 py-1 border-b border-gray-200 dark:border-gray-700 last:border-b-0"
                          >
                            <i className="fas fa-check text-green-500 op-70 text-xs pt-1"></i>
                            <span className="flex-grow">
                              {scaledQuantity !== null && (
                                <strong className="mr-1 font-medium">
                                  {(typeof formatQuantity === "function"
                                    ? formatQuantity
                                    : (v) => v)(scaledQuantity)}{" "}
                                  {unit || ""}
                                </strong>
                              )}
                              {escapeHTML(description)}
                            </span>
                          </li>
                        );
                      }) || (
                        <li className="text-gray-500 italic">
                          No ingredients.
                        </li>
                      )}
                    </ul>
                  </div>
                  <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                      <i className="fas fa-shoe-prints text-green-500 -rotate-90 transform"></i>
                      Directions
                    </h3>
                    <ol className="list-none space-y-3">
                      {recipe.directions?.map((dir, index) => {
                        const timeInSeconds = parseTimeFromDirection(dir);
                        return (
                          <li
                            key={index}
                            className="flex items-start gap-3 p-3 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm text-gray-800 dark:text-gray-200"
                          >
                            <span className="bg-green-500 text-white w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold mt-0.5 flex-shrink-0 shadow">
                              {index + 1}
                            </span>
                            <p className="text-sm flex-1">{escapeHTML(dir)}</p>
                            {timeInSeconds && (
                              <button
                                onClick={() =>
                                  addTimer(
                                    timeInSeconds,
                                    `Step ${index + 1}: ${recipe.name}`,
                                  )
                                }
                                className="text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300 text-xs"
                                title="Start timer for this step"
                              >
                                <i className="fas fa-stopwatch"></i>
                              </button>
                            )}
                          </li>
                        );
                      }) || (
                        <li className="text-gray-500 italic p-3 bg-gray-50 dark:bg-gray-700 rounded-md">
                          No directions.
                        </li>
                      )}
                    </ol>
                  </div>
                  {recipe.tipsAndTricks && recipe.tipsAndTricks.length > 0 && (
                    <div className="mt-6">
                      <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                        <i className="fas fa-lightbulb text-yellow-500"></i>Tips
                        & Tricks
                      </h3>
                      <ul className="list-none space-y-2 p-3 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm text-gray-800 dark:text-gray-200">
                        {recipe.tipsAndTricks.map((tip, index) => (
                          <li key={index} className="text-sm">
                            <i className="fas fa-caret-right text-yellow-500 mr-2"></i>
                            {escapeHTML(tip)}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>
              <div className="flex flex-wrap gap-3 mt-6 pt-4 border-t border-gray-200 dark:border-gray-600">
                {/* First Row - Primary Actions */}
                <button
                  onClick={() => setShowCookingMode(true)}
                  className="btn-modal bg-green-500 hover:bg-green-600 text-white"
                  title="Enter cooking mode"
                >
                  <i className="fas fa-fire mr-1.5"></i>Cook
                </button>
                {missingIngredients.length > 0 && (
                  <button
                    onClick={handleAddMissingToShoppingList}
                    className="btn-modal bg-orange-500 hover:bg-orange-600 text-white"
                    title="Add missing ingredients to shopping list"
                  >
                    <i className="fas fa-shopping-basket mr-1.5"></i>
                    Add Missing ({missingIngredients.length})
                  </button>
                )}
                <button
                  onClick={() => addToShoppingList(recipe.id)}
                  className="btn-modal btn-gray"
                >
                  <i className="fas fa-cart-plus mr-1.5"></i>All to List
                </button>
                <button
                  onClick={() => setShowAddToMealPlanSelector(true)}
                  className="btn-modal bg-indigo-500 hover:bg-indigo-600 text-white"
                >
                  <i className="fas fa-calendar-plus mr-1.5"></i>Meal Plan
                </button>
                <button
                  onClick={() => setShowCollectionSelector(true)}
                  className="btn-modal bg-yellow-600 hover:bg-yellow-700 text-white"
                  title="Add to collection"
                >
                  <i className="fas fa-folder-plus mr-1.5"></i>Collection
                </button>
                {missingIngredients.length > 0 && (
                  <button
                    onClick={() => setShowSubstitutions(!showSubstitutions)}
                    className="btn-modal bg-teal-500 hover:bg-teal-600 text-white"
                    title="Show ingredient substitutions"
                  >
                    <i className="fas fa-exchange-alt mr-1.5"></i>Substitutions
                  </button>
                )}
                <button
                  onClick={handlePrint}
                  className="btn-modal bg-cyan-600 hover:bg-cyan-700 text-white"
                  title="Print recipe"
                >
                  <i className="fas fa-print mr-1.5"></i>Print
                </button>
                <button
                  onClick={() => generateRecipePDF(recipe)}
                  className="btn-modal bg-pink-500 hover:bg-pink-600 text-white"
                >
                  <i className="fas fa-file-pdf mr-1.5"></i>PDF
                </button>
                <button
                  onClick={handleShareRecipe}
                  className="btn-modal bg-purple-700 hover:bg-purple-800 text-white"
                >
                  <i className="fas fa-share-alt mr-1.5"></i>Share
                </button>
                <button
                  onClick={handleExportSingleRecipe}
                  className="btn-modal bg-green-600 hover:bg-green-700 text-white"
                  title="Export this recipe"
                >
                  <i className="fas fa-file-export mr-1.5"></i>Export
                </button>
                <button
                  onClick={() => editRecipe(recipe)}
                  className="btn-modal btn-blue"
                >
                  <i className="fas fa-edit mr-1.5"></i>Edit
                </button>
                <button
                  onClick={() => deleteRecipe(recipe.id)}
                  className="btn-modal btn-red ml-auto"
                >
                  <i className="fas fa-trash mr-1.5"></i>Delete
                </button>
              </div>

              {/* Substitutions Section */}
              {showSubstitutions && missingIngredients.length > 0 && (
                <div className="mt-4 p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg">
                  <h3 className="text-lg font-semibold mb-3 text-gray-900 dark:text-white">
                    <i className="fas fa-lightbulb text-yellow-500 mr-2"></i>
                    Suggested Substitutions
                  </h3>
                  <div className="space-y-3">
                    {missingIngredients.map((ing, idx) => {
                      const subs = findSubstitutions(ing);
                      if (subs.length === 0) return null;
                      return (
                        <div key={idx} className="text-sm">
                          <p className="font-medium text-gray-800 dark:text-gray-200 mb-1">
                            <i className="fas fa-times text-red-500 mr-1"></i>
                            {ing}
                          </p>
                          <p className="text-gray-600 dark:text-gray-400 ml-4">
                            <i className="fas fa-arrow-right text-green-500 mr-1"></i>
                            Try: {subs.join(", ")}
                          </p>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>

            {/* Cooking Mode Modal */}
            {showCookingMode && (
              <CookingModeModal
                recipe={recipe}
                onClose={() => setShowCookingMode(false)}
                addTimer={addTimer}
                servingsMultiplier={servingsMultiplier}
              />
            )}

            {/* Collection Selector */}
            {showCollectionSelector && (
              <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[60] p-4">
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full max-h-[70vh] overflow-hidden flex flex-col">
                  <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <h3 className="text-xl font-bold text-gray-900 dark:text-white">
                      Add to Collection
                    </h3>
                    <button
                      onClick={() => setShowCollectionSelector(false)}
                      className="text-gray-500 hover:text-red-500 text-2xl"
                    >
                      √ó
                    </button>
                  </div>
                  <div className="flex-1 overflow-y-auto p-4">
                    {collections && collections.length > 0 ? (
                      <div className="space-y-2">
                        {collections.map((collection) => (
                          <button
                            key={collection.id}
                            onClick={() => handleAddToCollection(collection)}
                            className="w-full text-left p-3 bg-gray-50 dark:bg-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 border border-gray-200 dark:border-gray-600"
                          >
                            <i className="fas fa-folder text-green-500 mr-2"></i>
                            {collection.name}
                            <span className="text-sm text-gray-500 dark:text-gray-400 ml-2">
                              ({collection.recipeIds?.length || 0} recipes)
                            </span>
                          </button>
                        ))}
                      </div>
                    ) : (
                      <div className="text-center py-8 text-gray-500 dark:text-gray-400">
                        <i className="fas fa-folder-open text-4xl mb-2 opacity-50"></i>
                        <p>No collections yet.</p>
                        <p className="text-sm">Create one from the menu.</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}

            {showAddToMealPlanSelector && (
              <AddToMealPlanSelectorModal
                recipe={recipe}
                mealPlan={mealPlan}
                updateMealPlan={updateMealPlan}
                onClose={() => setShowAddToMealPlanSelector(false)}
                addToast={addToast}
                recipes={recipes}
              />
            )}
          </div>
        );
      };

      const MealPlanModal = ({
        mealPlan,
        recipes,
        updateMealPlan,
        removeMealFromPlan,
        addMultipleRecipesToShoppingList,
        onClose,
      }) => {
        const days = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];
        const mealTimes = [
          { id: "breakfast", label: "Breakfast", icon: "fa-coffee" },
          { id: "morningSnack", label: "M. Snack", icon: "fa-apple-alt" },
          { id: "lunch", label: "Lunch", icon: "fa-utensils" },
          { id: "afternoonSnack", label: "A. Snack", icon: "fa-cookie-bite" },
          { id: "dinner", label: "Dinner", icon: "fa-drumstick-bite" },
        ];
        const [showRecipeSelector, setShowRecipeSelector] = useState(null);
        const [selectorSearch, setSelectorSearch] = useState("");

        const filteredRecipesForSelector = useMemo(() => {
          const query = selectorSearch.toLowerCase().trim();
          if (!query)
            return recipes.sort((a, b) => a.name.localeCompare(b.name));
          return recipes
            .filter(
              (r) =>
                r?.name?.toLowerCase().includes(query) ||
                r?.type?.toLowerCase().includes(query) ||
                r?.cuisine?.toLowerCase().includes(query),
            )
            .sort((a, b) => a.name.localeCompare(b.name));
        }, [recipes, selectorSearch]);

        const handleSelectRecipeClick = useCallback((day, mealTimeId) => {
          setShowRecipeSelector({ day, mealTime: mealTimeId });
          setSelectorSearch("");
        }, []);
        const handleRecipeSelect = useCallback(
          (recipeId) => {
            if (showRecipeSelector) {
              updateMealPlan(
                showRecipeSelector.day,
                showRecipeSelector.mealTime,
                recipeId,
              );
            }
            setShowRecipeSelector(null);
          },
          [showRecipeSelector, updateMealPlan],
        );
        const handleRemoveMeal = useCallback(
          (e, day, mealTimeId, recipeIdToRemove) => {
            e.stopPropagation();
            removeMealFromPlan(day, mealTimeId, recipeIdToRemove);
          },
          [removeMealFromPlan],
        );
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose],
        );
        const handleSelectorOverlayClick = useCallback((e) => {
          if (e.target === e.currentTarget) setShowRecipeSelector(null);
        }, []);

        const getRecipeIdsForDays = useCallback(
          (daysToGet) => {
            const recipeIds = new Set();
            daysToGet.forEach((day) => {
              if (mealPlan && mealPlan[day]) {
                Object.values(mealPlan[day]).forEach((recipeIdsInSlot) => {
                  if (Array.isArray(recipeIdsInSlot)) {
                    recipeIdsInSlot.forEach((recipeId) => {
                      if (recipeId) {
                        recipeIds.add(recipeId);
                      }
                    });
                  }
                });
              }
            });
            return Array.from(recipeIds);
          },
          [mealPlan],
        );

        const handleAddDayToList = useCallback(
          (day) => {
            const recipeIds = getRecipeIdsForDays([day]);
            if (recipeIds.length > 0) {
              addMultipleRecipesToShoppingList(recipeIds);
            }
          },
          [getRecipeIdsForDays, addMultipleRecipesToShoppingList],
        );

        const handleAddWeekToList = useCallback(() => {
          const recipeIds = getRecipeIdsForDays(days);
          if (recipeIds.length > 0) {
            addMultipleRecipesToShoppingList(recipeIds);
          }
        }, [getRecipeIdsForDays, addMultipleRecipesToShoppingList, days]);

        return (
          <>
            <div
              className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-2 sm:p-4"
              onClick={handleOverlayClick}
            >
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-7xl h-[90vh] flex flex-col modal-scale-enter">
                <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 flex-shrink-0 gap-4">
                  <h2 className="text-xl sm:text-2xl font-bold flex items-center gap-2 text-gray-900 dark:text-gray-100">
                    <i className="fas fa-calendar-alt text-green-500"></i>Weekly
                    Meal Plan
                  </h2>
                  <button
                    onClick={handleAddWeekToList}
                    className="btn-modal btn-green text-xs sm:text-sm ml-auto mr-2"
                    title="Add all ingredients for the week to the shopping list"
                  >
                    <i className="fas fa-cart-plus mr-1"></i> Add Week to List
                  </button>
                  <button
                    onClick={onClose}
                    className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                    aria-label="Close"
                  >
                    &times;
                  </button>
                </div>
                <div className="flex-1 overflow-y-auto pb-4 pr-2">
                  <div className="grid grid-cols-1 md:grid-cols-7 gap-3 md:gap-4">
                    {days.map((day) => (
                      <div
                        key={day}
                        className="bg-gray-50 dark:bg-gray-900 p-2 rounded-lg flex flex-col gap-2 shadow-inner"
                      >
                        <div className="flex justify-between items-center mb-1">
                          <h3 className="text-center text-sm font-semibold py-1 flex-grow text-gray-800 dark:text-gray-200">
                            {day}
                          </h3>
                          <button
                            onClick={() => handleAddDayToList(day)}
                            className="text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 text-xs p-1"
                            title={`Add ${day}'s ingredients to shopping list`}
                          >
                            <i className="fas fa-cart-plus"></i>
                          </button>
                        </div>
                        <div className="flex flex-col gap-2">
                          {mealTimes.map(({ id, label, icon }) => {
                            const recipeIdsInSlot = mealPlan?.[day]?.[id] || [];
                            return (
                              <div
                                key={id}
                                onClick={() => handleSelectRecipeClick(day, id)}
                                className="bg-white dark:bg-gray-700 rounded-md p-1.5 sm:p-2 shadow-sm flex flex-col min-h-[65px] border border-transparent hover:border-green-400 transition-colors cursor-pointer group relative"
                              >
                                <div className="flex justify-between items-center mb-1 text-xs text-gray-500 dark:text-gray-400">
                                  <span className="flex items-center gap-1 font-medium">
                                    <i
                                      className={`fas ${icon} w-3 tc op-80`}
                                    ></i>{" "}
                                    {label}
                                  </span>
                                </div>
                                <div className="flex-grow flex flex-col items-center justify-center text-center">
                                  {recipeIdsInSlot.length > 0 ? (
                                    recipeIdsInSlot.map((recipeId) => {
                                      const recipe = recipes.find(
                                        (r) => r?.id === recipeId,
                                      );
                                      return (
                                        <div
                                          key={recipeId}
                                          className="relative w-full"
                                        >
                                          <p
                                            className="text-xs sm:text-sm text-green-600 dark:text-green-400 font-medium leading-tight group-hover:underline line-clamp-3"
                                            title={
                                              recipe?.name || "Unknown Recipe"
                                            }
                                          >
                                            {escapeHTML(
                                              recipe?.name || "Unknown Recipe",
                                            )}
                                          </p>
                                          <button
                                            onClick={(e) =>
                                              handleRemoveMeal(
                                                e,
                                                day,
                                                id,
                                                recipeId,
                                              )
                                            }
                                            className="text-red-400 hover:text-red-600 text-xs absolute top-0 right-0 bg-white dark:bg-gray-700 rounded-full w-4 h-4 flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                                            title="Remove"
                                            aria-label="Remove"
                                          >
                                            <i className="fas fa-times"></i>
                                          </button>
                                        </div>
                                      );
                                    })
                                  ) : (
                                    <p className="text-[10px] sm:text-xs text-gray-400 dark:text-gray-500 italic group-hover:text-gray-600 dark:group-hover:text-gray-300">
                                      + Add Recipe
                                    </p>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
            {showRecipeSelector && (
              <div
                className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[60] p-4"
                onClick={handleSelectorOverlayClick}
              >
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-5 w-full max-w-md max-h-[70vh] flex flex-col modal-scale-enter">
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="text-base sm:text-lg font-semibold text-gray-900 dark:text-gray-100">
                      Select for{" "}
                      <span className="text-green-500">
                        {showRecipeSelector?.day}{" "}
                        {
                          mealTimes.find(
                            (mt) => mt.id === showRecipeSelector?.mealTime,
                          )?.label
                        }
                      </span>
                    </h3>
                    <button
                      onClick={() => setShowRecipeSelector(null)}
                      className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-2xl leading-none"
                      aria-label="Close"
                    >
                      &times;
                    </button>
                  </div>
                  <div className="relative mb-3">
                    <input
                      type="search"
                      placeholder="Search recipes..."
                      value={selectorSearch}
                      onChange={(e) => setSelectorSearch(e.target.value)}
                      className="w-full p-2 pl-8 rounded border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-green-500 text-sm text-gray-900 dark:text-gray-100"
                      aria-label="Search recipes"
                    />
                    <i className="fas fa-search absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 text-xs"></i>
                  </div>
                  <div className="flex-1 overflow-y-auto space-y-1.5 pr-1">
                    {filteredRecipesForSelector.length > 0 ? (
                      filteredRecipesForSelector.map((recipe) => (
                        <div
                          key={recipe.id}
                          onClick={() => handleRecipeSelect(recipe.id)}
                          role="button"
                          className="bg-gray-50 dark:bg-gray-700 rounded p-2 cursor-pointer hover:bg-green-100 dark:hover:bg-green-900 hover:shadow-sm transition-all duration-150 flex items-center gap-2 border border-transparent hover:border-green-200 dark:hover:border-green-700"
                        >
                          {recipe.image ? (
                            <img
                              src={recipe.image}
                              alt=""
                              className="w-10 h-10 rounded object-cover flex-shrink-0 border border-gray-200 dark:border-gray-600"
                            />
                          ) : (
                            <div className="w-10 h-10 rounded bg-gray-200 dark:bg-gray-600 flex items-center justify-center text-gray-400 text-sm flex-shrink-0 border border-gray-300 dark:border-gray-600">
                              <i className="fas fa-image"></i>
                            </div>
                          )}
                          <div className="flex-grow overflow-hidden">
                            <h4
                              className="text-sm font-medium leading-tight truncate text-gray-800 dark:text-gray-200"
                              title={recipe.name}
                            >
                              {escapeHTML(recipe.name)}
                            </h4>
                            <p className="text-xs text-gray-500 dark:text-gray-400">
                              {escapeHTML(recipe.type)}
                            </p>
                          </div>
                        </div>
                      ))
                    ) : (
                      <div className="text-center text-gray-500 dark:text-gray-400 text-sm py-6">
                        <i className="fas fa-ghost text-2xl mb-2 op-50"></i>
                        <p>No recipes found.</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </>
        );
      };

      const ShoppingListModal = ({
        shoppingList,
        toggleShoppingItem,
        clearShoppingList,
        addToast,
        onClose,
        displayUnitSystem,
        setDisplayUnitSystem,
        convertUnits,
      }) => {
        const [showChecked, setShowChecked] = useState(true);

        const groupedByRecipe = useMemo(() => {
          const groups = {};
          if (!Array.isArray(shoppingList)) return groups;
          const safeNormalize =
            typeof normalizeIngredient === "function"
              ? normalizeIngredient
              : (x) => (x ? x.toLowerCase() : "");
          shoppingList.forEach((item) => {
            if (!item || typeof item !== "object") return;
            const recipeName = item.recipeName || "Manually Added";
            const normalized =
              item.normalizedText ||
              safeNormalize(item.originalText || item.description || "");
            if (!normalized) return;
            if (!groups[recipeName]) {
              groups[recipeName] = {
                id: item.recipeId || "manual",
                name: recipeName,
                items: [],
              };
            }
            groups[recipeName].items.push({
              ...item,
              normalizedText: normalized,
              originalText: item.originalText || item.description || "",
              description: item.description || item.originalText || "",
            });
          });
          Object.values(groups).forEach((group) => {
            group.items.sort((a, b) =>
              (a.originalText || "").localeCompare(b.originalText || ""),
            );
          });
          return groups;
        }, [shoppingList]);

        const commonIngredientsData = useMemo(() => {
          const normalizedDetails = {};
          const safeCapitalize =
            typeof capitalizeFirstLetter === "function"
              ? capitalizeFirstLetter
              : (x) => x;
          shoppingList.forEach((item) => {
            const norm =
              item.normalizedText ||
              (typeof normalizeIngredient === "function"
                ? normalizeIngredient(
                    item.originalText || item.description || "",
                  )
                : (item.originalText || item.description || "").toLowerCase());
            if (!norm) return;
            if (!normalizedDetails[norm]) {
              normalizedDetails[norm] = {
                display_name: safeCapitalize(norm),
                checked: item.checked,
                recipeSources: new Set(),
                instanceCount: 0,
                uncheckedCount: 0,
                quantity: 0,
                unit: item.unit,
                originalItems: [],
              };
            }
            if (
              item.quantity !== null &&
              item.unit === normalizedDetails[norm].unit
            ) {
              normalizedDetails[norm].quantity += item.quantity;
            } else if (
              item.quantity !== null &&
              !normalizedDetails[norm].unit
            ) {
              normalizedDetails[norm].unit = item.unit;
              normalizedDetails[norm].quantity += item.quantity;
            }
            normalizedDetails[norm].originalItems.push(item);
            normalizedDetails[norm].recipeSources.add(
              item.recipeName || "Manually Added",
            );
            normalizedDetails[norm].instanceCount++;
            if (!item.checked) normalizedDetails[norm].uncheckedCount++;
            if (!item.checked) {
              normalizedDetails[norm].checked = false;
            } else if (normalizedDetails[norm].uncheckedCount === 0) {
              normalizedDetails[norm].checked = true;
            }
          });
          const commonList = Object.entries(normalizedDetails)
            .filter(([norm, details]) => details.recipeSources.size > 1)
            .map(([norm, details]) => ({
              normalizedText: norm,
              text: details.display_name,
              checked: details.uncheckedCount === 0,
              recipeSources: Array.from(details.recipeSources),
              quantity: details.quantity,
              unit: details.unit,
              originalItems: details.originalItems,
            }));
          return commonList.sort((a, b) => a.text.localeCompare(b.text));
        }, [shoppingList]);

        const commonNormalizedTexts = useMemo(() => {
          return new Set(
            commonIngredientsData.map((item) => item.normalizedText),
          );
        }, [commonIngredientsData]);

        const displayRecipeGroups = useMemo(() => {
          return Object.values(groupedByRecipe)
            .map((group) => ({
              ...group,
              items: (showChecked
                ? group.items
                : group.items.filter((item) => !item.checked)
              ).filter(
                (item) => !commonNormalizedTexts.has(item.normalizedText),
              ),
            }))
            .filter((group) => group.items.length > 0)
            .sort((a, b) => a.name.localeCompare(b.name));
        }, [groupedByRecipe, showChecked, commonNormalizedTexts]);

        const displayCommonIngredients = useMemo(() => {
          return showChecked
            ? commonIngredientsData
            : commonIngredientsData.filter((item) => !item.checked);
        }, [commonIngredientsData, showChecked]);

        const getFormattedListText = useCallback(() => {
          let listText = "Shopping List\n==============\n\n";
          const itemsToInclude = showChecked
            ? shoppingList
            : shoppingList.filter((item) => !item.checked);
          if (itemsToInclude.length === 0) return "";
          const outputGroups = {};
          itemsToInclude.forEach((item) => {
            const recipeName = item.recipeName || "Other Items";
            if (!outputGroups[recipeName]) outputGroups[recipeName] = [];
            const { value, unit: convertedUnit } = convertUnits(
              item.quantity,
              item.unit,
              displayUnitSystem,
            );
            const displayQuantity = value !== null ? formatQuantity(value) : "";
            const displayUnit = convertedUnit || "";
            const displayIngredient =
              `${displayQuantity} ${displayUnit} ${item.description}`.trim();
            outputGroups[recipeName].push(
              `${item.checked ? "[x]" : "[ ]"} ${displayIngredient}`,
            );
          });
          const sortedGroupNames = Object.keys(outputGroups).sort((a, b) => {
            if (a === "Other Items") return 1;
            if (b === "Other Items") return -1;
            return a.localeCompare(b);
          });
          sortedGroupNames.forEach((groupName) => {
            listText += `--- ${groupName} ---\n`;
            outputGroups[groupName]
              .sort((a, b) => a.substring(4).localeCompare(b.substring(4)))
              .forEach((itemText) => {
                listText += `${itemText}\n`;
              });
            listText += "\n";
          });
          return listText.trim();
        }, [shoppingList, showChecked, convertUnits, displayUnitSystem]);

        const copyToClipboard = useCallback(async () => {
          try {
            const listText = getFormattedListText();
            if (!listText) {
              addToast("List is empty or all items hidden.", "info");
              return;
            }
            const textarea = document.createElement("textarea");
            textarea.value = listText;
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
            addToast("List copied to clipboard!", "success");
          } catch (err) {
            console.error("Failed to copy list:", err);
            addToast("Failed to copy list.", "error");
          }
        }, [getFormattedListText, addToast]);

        const handleToggleItem = useCallback(
          (itemId) => {
            toggleShoppingItem(itemId, null);
          },
          [toggleShoppingItem],
        );
        const handleToggleCommonItem = useCallback(
          (normalizedText) => {
            toggleShoppingItem(null, normalizedText);
          },
          [toggleShoppingItem],
        );
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose],
        );
        const handleClearList = useCallback(() => {
          if (
            shoppingList.length > 0 &&
            window.confirm(
              "Are you sure you want to clear the entire shopping list? This cannot be undone.",
            )
          ) {
            clearShoppingList();
          } else if (shoppingList.length === 0) {
            addToast("Shopping list is already empty.", "info");
          }
        }, [shoppingList, clearShoppingList, addToast]);

        const totalUncheckedItems = useMemo(
          () => shoppingList.filter((item) => !item.checked).length,
          [shoppingList],
        );

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick}
          >
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-2xl max-h-[90vh] flex flex-col modal-scale-enter">
              <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h2 className="text-xl sm:text-2xl font-bold flex items-center gap-2 text-gray-900 dark:text-gray-100">
                  <i className="fas fa-shopping-cart text-green-500"></i>{" "}
                  Shopping List ({totalUncheckedItems} items)
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>
              <div className="flex justify-between items-center mb-4 gap-4 flex-wrap">
                <label className="flex items-center gap-1.5 cursor-pointer text-sm order-2 sm:order-1 text-gray-700 dark:text-gray-300">
                  <input
                    type="checkbox"
                    checked={showChecked}
                    onChange={() => setShowChecked((p) => !p)}
                    className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-600"
                  />{" "}
                  Show purchased
                </label>
                <div className="flex gap-2 order-3 sm:order-2">
                  <div className="flex items-center text-sm">
                    <label
                      htmlFor="unitSystem"
                      className="mr-2 text-gray-700 dark:text-gray-300"
                    >
                      Units:
                    </label>
                    <select
                      id="unitSystem"
                      className="filter-select text-xs"
                      value={displayUnitSystem}
                      onChange={(e) => setDisplayUnitSystem(e.target.value)}
                    >
                      <option value="imperial">Imperial</option>
                      <option value="metric">Metric</option>
                    </select>
                  </div>
                  <button
                    onClick={copyToClipboard}
                    className="btn-modal btn-gray text-xs"
                    title="Copy list to clipboard"
                    disabled={shoppingList.length === 0}
                  >
                    <i className="fas fa-copy mr-1"></i> Copy
                  </button>
                </div>
                <button
                  onClick={handleClearList}
                  className="btn-modal btn-red text-xs order-1 sm:order-3 ml-auto sm:ml-0"
                  disabled={shoppingList.length === 0}
                >
                  <i className="fas fa-trash mr-1"></i>Clear List
                </button>
              </div>
              <div className="flex-1 overflow-y-auto pr-2 space-y-4">
                {displayRecipeGroups.length === 0 &&
                displayCommonIngredients.length === 0 ? (
                  <div className="text-center text-gray-500 dark:text-gray-400 py-8 px-4">
                    <i className="fas fa-clipboard-list text-4xl mb-3 opacity-50"></i>
                    <p className="font-semibold">Shopping list is empty</p>
                    <p className="text-sm">
                      {showChecked
                        ? "Add ingredients from recipes!"
                        : "All items purchased."}
                    </p>
                  </div>
                ) : (
                  <>
                    {displayCommonIngredients.length > 0 && (
                      <div className="pb-3 mb-3 border-b border-gray-200 dark:border-gray-600">
                        <h3 className="text-sm font-semibold mb-1 text-blue-600 dark:text-blue-400">
                          Common Ingredients
                        </h3>
                        <ul className="space-y-1 mt-1">
                          {displayCommonIngredients.map((item) => {
                            const { value, unit: convertedUnit } = convertUnits(
                              item.quantity,
                              item.unit,
                              displayUnitSystem,
                            );
                            const safeFormatQuantity =
                              typeof formatQuantity === "function"
                                ? formatQuantity
                                : (v) => v;
                            const displayQuantity =
                              value !== null ? safeFormatQuantity(value) : "";
                            const displayUnit = convertedUnit || "";
                            let displayIngredient = "";
                            if (displayQuantity) {
                              displayIngredient += `${displayQuantity} `;
                            }
                            if (displayUnit) {
                              displayIngredient += `${displayUnit} `;
                            }
                            displayIngredient += item.text;
                            return (
                              <li
                                key={item.normalizedText}
                                className={`p-1 rounded flex items-start gap-2 transition-opacity duration-200 ${
                                  item.checked
                                    ? "opacity-50 hover:opacity-70"
                                    : "hover:bg-gray-50 dark:hover:bg-gray-700"
                                }`}
                              >
                                <input
                                  type="checkbox"
                                  checked={item.checked}
                                  onChange={() =>
                                    handleToggleCommonItem(item.normalizedText)
                                  }
                                  className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-500 flex-shrink-0 cursor-pointer"
                                  aria-label={`Mark all '${item.text}' as ${
                                    item.checked ? "not purchased" : "purchased"
                                  }`}
                                />
                                <span
                                  className={`block leading-tight text-sm font-medium ${
                                    item.checked
                                      ? "line-through text-gray-500 dark:text-gray-400"
                                      : "text-gray-800 dark:text-gray-100"
                                  }`}
                                >
                                  {escapeHTML(displayIngredient.trim())}
                                  <span className="text-xs text-gray-400 dark:text-gray-500 ml-2 font-normal">
                                    ({item.recipeSources.join(", ")})
                                  </span>
                                </span>
                              </li>
                            );
                          })}
                        </ul>
                      </div>
                    )}
                    {displayRecipeGroups.length > 0 && (
                      <div>
                        <h3 className="text-sm font-semibold mb-1 text-green-600 dark:text-green-400 border-b border-green-200 dark:border-green-700 pb-0.5">
                          Ingredients by Recipe
                        </h3>
                        <ul className="space-y-1 mt-1">
                          {displayRecipeGroups.map((group) => (
                            <li key={group.id}>
                              <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mt-2 mb-1">
                                {escapeHTML(group.name)}
                              </h4>
                              <ul className="space-y-0.5 pl-4">
                                {group.items.map((item) => {
                                  const { value, unit: convertedUnit } =
                                    convertUnits(
                                      item.quantity,
                                      item.unit,
                                      displayUnitSystem,
                                    );
                                  const safeFormatQuantity =
                                    typeof formatQuantity === "function"
                                      ? formatQuantity
                                      : (v) => v;
                                  const displayQuantity =
                                    value !== null
                                      ? safeFormatQuantity(value)
                                      : "";
                                  const displayUnit = convertedUnit || "";
                                  let displayIngredient = "";
                                  if (displayQuantity) {
                                    displayIngredient += `${displayQuantity} `;
                                  }
                                  if (displayUnit) {
                                    displayIngredient += `${displayUnit} `;
                                  }
                                  displayIngredient += item.description;
                                  return (
                                    <li
                                      key={item.id}
                                      className={`flex items-start gap-2 transition-opacity duration-200 ${
                                        item.checked
                                          ? "opacity-50 hover:opacity-70"
                                          : "hover:bg-gray-50 dark:hover:bg-gray-700"
                                      }`}
                                    >
                                      <input
                                        type="checkbox"
                                        checked={item.checked}
                                        onChange={() =>
                                          handleToggleItem(item.id)
                                        }
                                        className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-500 flex-shrink-0 cursor-pointer"
                                        aria-label={`Mark ${
                                          item.originalText
                                        } as ${
                                          item.checked
                                            ? "not purchased"
                                            : "purchased"
                                        }`}
                                      />
                                      <span
                                        className={`block leading-tight text-sm ${
                                          item.checked
                                            ? "line-through text-gray-500 dark:text-gray-400"
                                            : "text-gray-800 dark:text-gray-100"
                                        }`}
                                      >
                                        {escapeHTML(displayIngredient.trim())}
                                      </span>
                                    </li>
                                  );
                                })}
                              </ul>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          </div>
        );
      };

      const Footer = () => {
        const currentYear = new Date().getFullYear();
        const emailAddress = "BarrTechSolutions@gmail.com";

        return (
          <footer className="bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-300 py-4 text-center text-sm mt-8">
            <div className="max-w-7xl mx-auto px-4">
              <p>
                &copy; {currentYear} BarrTech Solutions. All rights reserved.
              </p>
              <p className="mt-1">
                Contact:{" "}
                <a
                  href={`mailto:${emailAddress}`}
                  className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-green-500"
                >
                  {emailAddress}
                </a>
              </p>
            </div>
          </footer>
        );
      };

      const rootElement = document.getElementById("root");
      if (rootElement) {
        const reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(<App />);
      } else {
        console.error("Root element not found! React app cannot be mounted.");
      }
    </script>
  </body>
</html>
